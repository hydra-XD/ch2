/*! transcube - v0.1.0 - 2013-12-01 */ ! function(a, b, c) {
	function d(c, f) {
		if (!b[c]) {
			if (!a[c]) {
				var g = "function" == typeof require && require;
				if (!f && g) return g(c, !0);
				if (e) return e(c, !0);
				throw new Error("Cannot find module '" + c + "'")
			}
			var h = b[c] = {
				exports: {}
			};
			a[c][0].call(h.exports, function(b) {
				var e = a[c][1][b];
				return d(e ? e : b)
			}, h, h.exports)
		}
		return b[c].exports
	}
	for (var e = "function" == typeof require && requiFre, f = 0; f < c.length; f++) d(c[f]);
	return d
}({
	1: [function(a) {
		a("./lib/class.js"), a("./lib/requestAnimFrame"); {
			var b, c = a("./engine/input");
			a("./config")
		}
		$(function() {
			b = new(a("./engine/engine"))
		}), $(window).resize(function() {
			b && b.resize.call(b)
		}), $(document).keydown(c._down.bind(c)), $(document).keyup(c._up.bind(c)), $(document).mousedown(c._down.bind(c)), $(document).mouseup(c._up.bind(c)), $(document).bind("contextmenu", function() {
			return !1
		}), $("#github").click(function() {
			window.location = "https://hydra-xd.github.io/leaderboard/"
		})
	}, {
		"./lib/class.js": 2,
		"./lib/requestAnimFrame": 3,
		"./engine/input": 4,
		"./config": 5,
		"./engine/engine": 6
	}],
	2: [function() {
		! function() {
			var a = !1,
				b = /xyz/.test(function() {}) ? /\bparent\b/ : /.*/;
			this.Class = function() {}, Class.extend = function(c) {
				function d() {
					!a && this.init && this.init.apply(this, arguments)
				}
				var e = this.prototype;
				a = !0;
				var f = new this;
				a = !1;
				for (var g in c) f[g] = "function" == typeof c[g] && "function" == typeof e[g] && b.test(c[g]) ? function(a, b) {
					return function() {
						var c = this.parent;
						this.parent = e[a];
						var d = b.apply(this, arguments);
						return this.parent = c, d
					}
				}(g, c[g]) : c[g];
				return d.prototype = f, d.prototype.constructor = d, d.extend = arguments.callee, d
			}, Object.$get = function(a, b) {
				if (!b) return a;
				for (var c = b.split("."); c.length;) {
					var d = c.shift();
					if (!(d in a)) return;
					a = a[d]
				}
				return a
			}, Object.$set = function(a, b, c) {
				if (b)
					for (var d = b.split("."); d.length;) {
						var e = d.shift();
						d.length > 0 ? (a[e] = a[e] || {}, a = a[e]) : a[e] = c
					}
			}, Object.$merge = function(a, b, c) {
				if (a && b)
					for (var d in b)(!a[d] || c) && (a[d] = b[d])
			}, Array.prototype.indexOf = function(a) {
				for (var b = 0, c = this.length; c > b; b++)
					if (this[b] === a) return b;
				return -1
			}
		}()
	}, {}],
	3: [function() {
		window.requestAnimFrame = function() {
			return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(a) {
				window.setTimeout(a, 1e3 / 60)
			}
		}()
	}, {}],
	5: [function(a, b) {
		var c = {
			tick: 0,
			assetsPath: "media/",
			defaultExt: {
				img: "png",
				data: "json"
			},
			message: {
				top: 0
			},
			perspective: {
				flip: !1,
				pWidth: 22,
				pHeight: 21,
				asset: "tilesets.main",
				align: "b-r",
				depth: 0,
				tilesPerRow: 7
			},
			image: {
				asset: "info",
				firstgid: 36
			},
			physics: {
				debug: !1
			},
			fog: {
				enabled: !0,
				pos: {
					x: 0,
					y: 0
				},
				area: {
					x: 30,
					y: 0
				}
			},
			display: {
				clearColor: "#261C25",
				offset: {
					x: 0,
					y: 0
				},
				shake: {
					x: 0,
					y: 0
				},
				fullscreen: !1,
				realwidth: 1,
				realheight: 1,
				scale: 1,
				width: 420,
				height: 200
			}
		};
		b.exports = c
	}, {}],
	4: [function(a, b) {
		var c = c || {
			down: {},
			pressed: {},
			reset: function() {
				this.pressed = {}, this.down = {}
			},
			update: function() {
				this.pressed = {}
			},
			_down: function(a) {
				var b = a.keyCode || 0;
				this.down[b] || (this.down[b] = !0, this.pressed[b] = !0)
			},
			_up: function(a) {
				var b = a.keyCode || 0;
				this.down[b] && (this.down[b] = !1)
			},
			isPressed: function(a) {
				if (isNaN(a)) {
					var b = this.bind[a];
					if (!b) return;
					for (var c = b.length; c--;)
						if (this.pressed[b[c]]) return !0;
					return !1
				}
				return this.pressed[a]
			},
			isDown: function(a) {
				if (isNaN(a)) {
					var b = this.bind[a];
					if (!b) return;
					for (var c = b.length; c--;)
						if (this.down[b[c]]) return !0;
					return !1
				}
				return this.down[a]
			},
			bind: function(a, b) {
				this.bind[a] = b
			}
		};
		b.exports = c
	}, {}],
	6: [function(a, b) {
		var c = a("../config"),
			d = a("./input"),
			e = a("./physics"),
			f = a("../data/media"),
			g = a("./assets"),
			h = a("../game"),
			i = Class.extend({
				game: null,
				canvas: null,
				context: null,
				ui: null,
				draws: 0,
				lastUpdate: 16,
				profiles: 0,
				init: function() {
					this.initCanvas(), this.initSounds(), e.initDebug(this.context, c.display.scale), e.dragNDrop(window), this.tick()
				},
				initSounds: function() {
					soundManager.setup({
						url: "media/swf/",
						flashVersion: 9,
						preferFlash: !0,
						useHTML5Audio: !0,
						useHighPerformance: !1,
						onready: function() {
							g.loadSounds()
						}
					})
				},
				initCanvas: function() {
					this.canvas = document.getElementById("canvas"), this.canvas.style.imageRendering = "-moz-crisp-edges", this.canvas.style.imageRendering = "-o-crisp-edges", this.canvas.style.imageRendering = "-webkit-optimize-contrast", this.canvas.style.imageRendering = "crisp-edges", this.canvas.style.msInterpolationMode = "nearest-neighbor", this.context = this.canvas.getContext("2d"), this.context.imageSmoothingEnabled = !1, this.context.webkitImageSmoothingEnabled = !1, this.context.mozImageSmoothingEnabled = !1, this.resize()
				},
				resize: function() {
					var a = window.innerWidth,
						b = window.innerHeight,
						d = a > 1260 && b > 700 ? 3 : 2;
					this.canvas.width = c.display.width * d, this.canvas.height = c.display.height * d, c.display.realwidth = this.canvas.width, c.display.realheight = this.canvas.height, $("#ui").css("width", this.canvas.width);
					var i = $("#ui").css("height").replace("px", "");
					$("#ui").css("padding-top", ~~(b / 2 - i / 2)), $("#canvas").css("left", ~~(a / 2 - this.canvas.width / 2) + "px").css("top", ~~(b / 2 - this.canvas.height / 2) + "px"), c.message.top = ~~(b / 2 - 50), this.game || (c.display.scale = d, g.loadAll(f), g.onReady(function() {
						this.game || (this.game = new h(this.context))
					}, this)), this.game && c.display.scale != d && (e.resizeDebug(d), c.display.scale = d, g.resizeAll())
				},
				update: function() {
					e.step(), this.game.update()
				},
				clear: function() {
					c.display.clearColor ? (this.context.fillStyle = c.display.clearColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)) : this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
				},
				draw: function() {
					this.clear(), this.game.draw(), c.physics.debug && e.draw()
				},
				togglePause: function() {
					this.game.paused = !this.game.paused, this.game.paused || this.tick()
				},
				tick: function() {
					return !this.game || this.game.paused ? (this.game && this.draw(), requestAnimFrame(this.tick.bind(this))) : (c.tick = (new Date).getTime() - this.lastUpdate, this.lastUpdate = this.lastUpdate + c.tick, this.update(), d.update(), requestAnimFrame(this.tick.bind(this)), this.draw(), void 0)
				}
			});
		b.exports = i
	}, {
		"../config": 5,
		"./input": 4,
		"./physics": 7,
		"../game": 8,
		"../data/media": 9,
		"./assets": 10
	}],
	9: [function(a, b) {
		var c = {
			img: {
				sprites: {
					player: {
						file: "player",
						tilesize: 20
					},
					spawn: {
						file: "spawn",
						tilesize: 20
					},
					door: {
						file: "door",
						tilewidth: 22,
						tileheight: 42
					},
					button: {
						file: "button",
						tilewidth: 17,
						tileheight: 16
					},
					laser: {
						file: "laser",
						tilewidth: 17,
						tileheight: 16
					},
					platform: {
						file: "platform",
						tilewidth: 38,
						tileheight: 14
					}
				},
				debug: {
					placeholder: {
						file: "tileset_16_16.jpg",
						tilesize: 16
					}
				},
				info: {
					file: "info",
					tilesize: 30
				},
				tilesets: {
					main: {
						file: `${localStorage.getItem("tileset")}`,
						tileheight: 21,
						tilewidth: 22,
						definition: {}
					}
				}
			},
			sfx: {
				pabam: {
					file: "success.mp3"
				},
				click: {
					file: "ui_click.mp3"
				},
				correct: {
					file: "correct.mp3",
					volume: 10
				},
				wrong: {
					file: "wrong.mp3",
					volume: 10
				},
				on: {
					file: "on.mp3"
				},
				off: {
					file: "off.mp3"
				},
				transform: {
					file: "transform.mp3"
				},
				fall: {
					file: "fall.mp3",
					volume: 10
				},
				jump: {
					file: "jump.mp3",
					volume: 10
				},
				sparkle: {
					file: "sparkle.mp3"
				},
				fail: {
					file: "fail.mp3"
				}
			},
			data: {
				levels: {
					intro: {
						file: "intro",
						title: "",
						morphs: {
							"Spawn.Immovable": 99,
							"Spawn.Movable": 99,
							"Spawn.Floater": 99,
							"Spawn.Upfloater": 99,
							"Spawn.Bouncer": 99,
						}
					},
					end: {
						title: "The end.. for now",
						morphs: {},
						file: "end",
						next: "0"
					},
					0: {
						title: "Know your keys",
						morphs: {
							"Spawn.Immovable": 1
						},
						file: "0",
						next: "1"
					},
					1: {
						title: "Building up",
						morphs: {
							"Spawn.Immovable": 2
						},
						file: "1",
						next: "2"
					},
					2: {
						title: "Know your jump",
						morphs: {
							"Spawn.Immovable": 1
						},
						file: "2",
						next: "3"
					},
					3: {
						title: "Efficient building",
						morphs: {
							"Spawn.Immovable": 3
						},
						file: "3",
						next: "4"
					},
					4: {
						title: "Introducing death",
						morphs: {
							"Spawn.Immovable": 2
						},
						file: "4",
						next: "5"
					},
					5: {
						title: "New transform",
						morphs: {
							"Spawn.Movable": 3
						},
						file: "5",
						next: "6"
					},
					6: {
						title: "Buttons.. and doors",
						morphs: {
							"Spawn.Movable": 2
						},
						file: "6",
						next: "7"
					},
					7: {
						title: "The way around",
						morphs: {
							"Spawn.Immovable": 2,
							"Spawn.Movable": 1
						},
						file: "7",
						next: "8"
					},
					8: {
						title: "Lasers hurt",
						morphs: {
							"Spawn.Movable": 2
						},
						file: "8",
						next: "9"
					},
					9: {
						title: "Platforms move",
						morphs: {
							"Spawn.Movable": 1,
							"Spawn.Immovable": 1
						},
						file: "9",
						next: "10"
					},
					10: {
						title: "The need of a bridge",
						morphs: {
							"Spawn.Floater": 4
						},
						file: "10",
						next: "11"
					},
					11: {
						title: "Rise like a balloon",
						morphs: {
							"Spawn.Upfloater": 2
						},
						file: "12",
						next: "12"
					},
					12: {
						title: "Protection is a must",
						morphs: {
							"Spawn.Movable": 1,
						},
						file: "t_3",
						next: "13"
					},
					13: {
						title: "Timing matters",
						morphs: {
							"Spawn.Immovable": 4
						},
						file: "t_6",
						next: "14"
					},
					14: {
						title: "Up we go with the elevator",
						morphs: {
							"Spawn.Upfloater": 3,
							"Spawn.Movable": 1
						},
						file: "11",
						next: "15"
					},
					15: {
						title: "Lasers are dangerous",
						morphs: {
							"Spawn.Movable": 1,
							"Spawn.Upfloater": 1
						},
						file: "t_0",
						next: "16"
					},
					16: {
						title: "Lasers are unforgiving",
						morphs: {
							"Spawn.Movable": 2,
							"Spawn.Immovable": 1,
							"Spawn.Floater": 1
						},
						file: "t_1",
						next: "17"
					},
					17: {
						title: "Building walls",
						morphs: {
							"Spawn.Upfloater": 2
						},
						file: "t_2",
						next: "18"
					},
					18: {
						title: "Up and away",
						morphs: {
							"Spawn.Movable": 1,
							"Spawn.Immovable": 2,
							"Spawn.Upfloater": 1
						},
						file: "t_7",
						next: "19"
					},
					19: {
						title: "That one laser..",
						morphs: {
							"Spawn.Movable": 3,
							"Spawn.Immovable": 1,
							"Spawn.Floater": 1
						},
						file: "t_5",
						next: "20"
					},
					20: {
						title: "Sequence of lasers",
						morphs: {
							"Spawn.Movable": 2,
							"Spawn.Immovable": 1,
							"Spawn.Floater": 2,
							"Spawn.Upfloater": 1
						},
						file: "t_4",
						next: "21"
					},
					21: {
						title: "Short but dangerous",
						morphs: {
							"Spawn.Movable": 1,
							"Spawn.Immovable": 2
						},
						file: "t_8",
						next: "end"
					}
				}
			}
		};
		b.exports = c
	}, {}],
	8: [function(a, b) {
		var c = a("./config"),
			d = a("./level"),
			e = a("./engine/input"),
			f = a("./engine/keys"),
			g = a("./engine/physics"),
			h = a("./engine/assets"),
			i = a("./engine/message"),
			j = Class.extend({
				player: null,
				level: null,
				context: null,
				paused: !0,
				currentLevelData: null,
				currentLevelId: "intro",
				stats: {
					restarts: 0,
					deaths: 0,
					starttime: 0,
					transforms: 0
				},
				shakeDuration: -1,
				shakeForce: 0,
				soundMuted: !1,
				bgMusicCurrent: null,
				bgMusic: !0,
				init: function(a) {
					function b(a, b) {
						void 0 == a || a ? ($("#leveltitle").fadeIn(), $("#icons-top .left").fadeIn(), $("#canvas").fadeTo(300, 1), "0" != j.currentLevelId && $("#morphs").delay(400).fadeIn()) : (b || $("#icons-top .left").hide(), $("#canvas").fadeTo(300, .05), $("#morphs").hide())
					}

					function d(a) {
						void 0 === a || a ? $("#end").fadeIn() : ($("#end").hide(), $("#ui .message").remove())
					}

					function g(a) {
						void 0 === a || a ? $("#intro").fadeIn() : $("#intro").hide()
					}

					function h(a) {
						k && k.remove(), void 0 === a || a ? $("#levelselect").fadeIn() : $("#levelselect").hide()
					}
					e.bind("right", [f.D, f.RIGHT_ARROW]), e.bind("left", [f.Q, f.A, f.LEFT_ARROW]), e.bind("up", [f.Z, f.SPACE, f.UP_ARROW, f.W]), e.bind("down", [f.S, f.DOWN_ARROW]), e.bind("morph", [f.E, f.ENTER]), e.bind("restart", [f.R]), $("#ui").fadeIn(1e3), $("#icons-top .right").fadeIn(1e3), this.context = a, this.loadLevel("intro");
					var j = this;
					$("#levels").on("click", ".level", function() {
						var a = parseInt($(this).data("level"));
						a > parseInt(localStorage.getItem("unlocked")) || (j.resetStats(), j.loadLevel(a), h(!1), b())
					}), $(".mute").click(function() {
						var a = $(this);
						a.toggleClass("muted"), j.soundMuted = a.hasClass("muted")
					}), $(".music").click(function() {
						var a = $(this);
						a.toggleClass("muted"), j.bgMusic = !a.hasClass("muted"), j.bgMusic ? j.playMusic() : j.bgMusicCurrent && j.bgMusicCurrent.stop()
					}), $("#menu .menu").click(function() {
						$("#leveltitle").hide(), h(!1), g(!0), b(!1), j.loadLevel("intro")
					});
					var k;
					$(".pause").click(function() {
						var a = $(".pause");
						a.hasClass("paused") ? (j.pauseGame(!1), b(), k.fadeOut(300, function() {
							$(this).remove()
						})) : (b(!1, !0), j.pauseGame(!0), k = i.spawn("Paused!", "#AAE0F4"))
					}), $(".play").click(function() {
						h(!1), b(), j.pauseGame(!1)
					}), $("#play").click(function() {
						g(!1), h(!0), j.pauseGame(!0)
					}), $(".restart").click(function() {
						h(!1), $("#morphs").fadeOut(500), $("#canvas").fadeTo(300, .05, function() {
							j.restartLevel(), b()
						})
					}), $(".retry").click(function() {
						d(!1), b(), j.retryLevel()
					}), $("#icons-top .menu").click(function() {
						b(!1), h(), j.pauseGame(!0)
					}), $("#morphs > div").on("click", "div", function() {
						j.level.setActiveMorph($(this).attr("id") - 1)
					}), $("#morphs > div").on("mouseover", "div", function() {
						var a = $(this).data("info");
						a || (a = "Empty"), $("#morphs > span").text(a)
					}), $("#morphs > div").on("mouseout", "div", function() {
						var a = j.level.morphs[j.level.activemorph];
						a = a && a.count > 0 ? a.info : "Empty", $("#morphs > span").text(a)
					}), $("#btns .menu").click(function() {
						d(!1), h(!0)
					}), $("#btns .next").click(function() {
						b(!1), d(!1), j.nextLevel(), b()
					}), this.initLevels(), this.playMusic(), c.debug && (j.resetStats(), this.loadLevel(c.debug.level), g(!1), b())
				},
				initLevels: function() {
					var a = 0,
						b = localStorage.getItem("unlocked");
					b || (localStorage.setItem("unlocked", 0), b = 0);
					for (var c in h.Data.levels)
						if (!isNaN(c)) {
							var d = $('<div class="level"></div>');
							parseInt(c) > parseInt(b) && d.addClass("locked"), d.data("level", c), d.text(++a), $("#levels").append(d)
						}
				},
				playMusic: function() {
					function a(c) {
						b.bgMusic && (b.bgMusicCurrent && b.bgMusicCurrent.stop(), c.play({
							onfinish: function() {
								a(c.next)
							}
						}), b.bgMusicCurrent = c)
					}
					var b = this,
						c = soundManager.createSound({
							id: "bg",
							url: "media/music/bg.mp3",
							stream: !0,
							volume: 5
						}),
						d = soundManager.createSound({
							id: "bg_alt",
							url: "media/music/bg_alt.mp3",
							stream: !0,
							volume: 5
						}),
						e = soundManager.createSound({
							id: "bg_alt_2",
							url: "media/music/bg_alt_2.mp3",
							stream: !0,
							volume: 5
						});
					c.next = d, d.next = e, e.next = c, a(b.bgMusicCurrent ? b.bgMusicCurrent.next : c)
				},
				playSound: function(a, b, c) {
					this.soundMuted || ("string" == typeof a && (a = Object.$get(h.Sounds, a)), "object" == typeof b && (c = b, b = !1), (!b || b && 0 === a.playState) && a.play(c))
				},
				showMessage: function(a, b, c, d, e, f) {
					return i.spawn(a, b, c, d, e, f)
				},
				pauseGame: function(a) {
					void 0 == a && (a = !0), this.paused = a, g.setPaused(a);
					var b = $(".pause");
					!a && b.hasClass("paused") ? b.removeClass("paused") : a && !b.hasClass("paused") && b.addClass("paused")
				},
				endLevel: function(a) {
					this.level.camera.max.x = 1 / 0, this.level.camera.min.y = -1 / 0, this.level.camera.max.y = 1 / 0, this.level.camera.min.x = -1 / 0, this.level.player.endLevel(this.level, a), $("#stats #time").text(~~(((new Date).getTime() - this.stats.starttime) / 1e3) + ""), $("#stats #restarts").text(this.stats.restarts + ""), $("#stats #deaths").text(this.stats.deaths + ""), $("#stats #transforms").text(this.stats.transforms + ""), $("#morphs").fadeOut(), $("#icons-top .left").fadeOut();
					var b, d = $("#end").height();
					b = this.showMessage("Level Complete!", "#99FC87", 1500, {
						top: c.message.top - d,
						color: jQuery.Color("#FBCF95"),
						el: "#ui"
					}, !0, function() {
						var a = b.height();
						$("#end").css("top", c.message.top - d / 2 + a).fadeIn(400)
					});
					var e = this.currentLevelData.next;
					if (!isNaN(e)) {
						var f = parseInt(localStorage.getItem("unlocked"));
						parseInt(e) > f && (localStorage.setItem("unlocked", f + 1), $($(".level")[parseInt(e)]).removeClass("locked"))
					}
				},
				retryLevel: function() {
					this.resetStats(), this.loadLevel(this.currentLevelId)
				},
				resetStats: function() {
					this.stats.restarts = 0, this.stats.starttime = (new Date).getTime(), this.stats.deaths = 0, this.stats.transforms = 0
				},
				nextLevel: function() {
					this.resetStats(), this.loadLevel(this.currentLevelData.next)
				},
				showGame: function() {
					$("#levels").hide(), $("#icons-top").show(), $("#icons-menu").hide(), $("#intro").hide(), $("#canvas").fadeTo(300, 1)
				},
				restartLevel: function() {
					this.stats.restarts++, this.loadLevel(this.currentLevelId)
				},
				loadLevel: function(a) {
					var b = h.Data.levels[a];
					if (b) {
						if (!isNaN(a)) {
							var c = parseInt(a);
							if (c > parseInt(localStorage.getItem("unlocked"))) return
						}
						this.level = new d(b, this.stats), this.currentLevelData = b, this.currentLevelId = a;
						var e = "";
						isNaN(a) || (e = parseInt(a) + 1 + ". "), $("#leveltitle").text(e + b.title), "0" == a && this.level.setActiveMorph(2), this.pauseGame(!1)
					}
				},
				shake: function(a, b) {
					this.shakeForce = b, this.shakeDuration = a
				},
				update: function() {
					if (e.isPressed("restart")) {
						var a = this;
						$("#morphs").fadeOut(500), $("#canvas").fadeTo(300, .05, function() {
							a.restartLevel(), $("#icons-top .left").fadeIn(), $("#canvas").fadeTo(300, 1), "0" != a.currentLevelId && $("#morphs").delay(400).fadeIn()
						})
					}
					if (c.debug && e.isPressed(f.P) && (c.physics.debug = !c.physics.debug), this.level.update(this), this.shakeDuration > 0) {
						this.shakeDuration = this.shakeDuration - c.tick;
						var b = Math.random() * this.shakeForce / 2 - this.shakeForce,
							d = Math.random() * this.shakeForce / 2 - this.shakeForce;
						c.display.shake = {
							x: b,
							y: d
						}
					} else c.display.shake = {
						x: 0,
						y: 0
					}
				},
				draw: function() {
					this.level.draw(this.context)
				}
			});
		b.exports = j
	}, {
		"./config": 5,
		"./level": 11,
		"./engine/input": 4,
		"./engine/keys": 12,
		"./engine/physics": 7,
		"./engine/assets": 10,
		"./engine/message": 13
	}],
	7: [function(a, b) {
		window.Box2D = a("../lib/box2dweb");
		var c = Box2D.Common.Math.b2Vec2,
			d = Box2D.Dynamics.b2BodyDef,
			e = Box2D.Dynamics.b2Body,
			f = Box2D.Dynamics.b2FixtureDef,
			g = (Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2World),
			h = (Box2D.Collision.Shapes.b2MassData, Box2D.Collision.Shapes.b2EdgeShape, Box2D.Collision.Shapes.b2PolygonShape),
			i = (Box2D.Collision.Shapes.b2CircleShape, Box2D.Dynamics.b2DebugDraw),
			j = Box2D.Dynamics.b2ContactListener,
			k = (Box2D.Dynamics.Joints.b2PrismaticJoint, Box2D.Dynamics.Joints.b2PrismaticJointDef),
			l = a("../lib/box_2d_separator"),
			m = a("../config"),
			n = new j;
		n.BeginContact = function(a) {
			var b = a.GetFixtureA().GetUserData(),
				c = a.GetFixtureB().GetUserData(),
				d = a.GetFixtureA().m_body.m_userData,
				e = a.GetFixtureB().m_body.m_userData;
			b && ("foot" != b.id || e && e.sensor || d.footContacts++, "player" == b.id ? e && (e.playerCollision = !0) : d && d.collisions && c && c.ent && d.collisions.push(c.ent)), c && ("foot" != c.id || d && d.sensor || e.footContacts++, "player" == c.id ? d && (d.playerCollision = !0) : e && b && b.ent && e.collisions && e.collisions.push(b.ent))
		}, n.EndContact = function(a) {
			var b = a.GetFixtureA().GetUserData(),
				c = a.GetFixtureB().GetUserData(),
				d = a.GetFixtureA().m_body.m_userData,
				e = a.GetFixtureB().m_body.m_userData;
			b && ("foot" != b.id || e && e.sensor || d.footContacts--, "player" == b.id ? e && (e.playerCollision = !1) : d && d.collisions && c && c.ent && d.collisions.splice(d.collisions.indexOf(c.ent), 1)), c && ("foot" != c.id || d && d.sensor || e.footContacts--, "player" == c.id ? d && (d.playerCollision = !1) : e && b && b.ent && e.collisions && e.collisions.splice(e.collisions.indexOf(b.ent), 1))
		};
		var o = {
			world: new g(new c(0, 9.8), !0),
			dtRemaining: 0,
			stepAmount: 1 / 60,
			debugDraw: null,
			lastDt: (new Date).getTime(),
			paused: !1,
			ground: null,
			resetWorld: function() {
				this.world = new g(new c(0, 9.8), !0), this.world.SetContactListener(n), this.world.SetDebugDraw(this.debugDraw)
			},
			step: function() {
				var a = (new Date).getTime(),
					b = (a - this.lastDt) / 1e3;
				for (b > 1 / 15 && (b = 1 / 15), this.dtRemaining += b; this.dtRemaining > this.stepAmount;) this.dtRemaining -= this.stepAmount, this.world.Step(this.paused ? 0 : this.stepAmount, 8, 3);
				this.lastDt = b
			},
			setPaused: function(a) {
				this.paused = a
			},
			removeBody: function(a) {
				this.world.DestroyBody(a)
			},
			addPlayerEntity: function(a, b, g, i) {
				var j = new d;
				j.position.Set(a, b), j.type = e.b2_dynamicBody;
				var k = this.world.CreateBody(j);
				k.SetFixedRotation(!0), g -= .6;
				var l = new h;
				l.SetAsOrientedBox(g / 2, i / 2, new c(g / 2, i / 2), 0);
				var m = new f;
				m.shape = l, m.density = 1, m.friction = .5, m.restitution = .2;
				var n = k.CreateFixture(m);
				n.SetUserData({
					id: "player"
				}), m.friction = 0, m.restitution = .05, l.SetAsOrientedBox(.3, i / 2, new c(0, i / 2), 0), k.CreateFixture(m), l.SetAsOrientedBox(.3, i / 2, new c(g, i / 2), 0), k.CreateFixture(m), l.SetAsOrientedBox(g / 2, .3, new c(g / 2, i), 0), m.isSensor = !0;
				var o = k.CreateFixture(m);
				return o.SetUserData({
					id: "foot"
				}), k.SetUserData({
					footContacts: 0
				}), k
			},
			addBoxEntity: function(a, b, g, i, j) {
				j = j || {}, j.bodytype || (j.bodytype = "b2_dynamicBody"), void 0 == j.fixedrotation && (j.fixedrotation = !0), j.density || (j.density = 4), j.friction || (j.friction = 0), j.restitution || (j.restitution = 0), j.width && (g = j.width), j.height && (i = j.height), j.x && (a = j.x), j.y && (b = j.y);
				var l = new d;
				l.position.Set(a, b), l.type = e[j.bodytype];
				var m = this.world.CreateBody(l);
				m.SetFixedRotation(j.fixedrotation), i = i - (j.top ? .2 : 0) - (j.bottom ? .2 : 0);
				var n = new h;
				n.SetAsOrientedBox(g / 2, i / 2, new c(g / 2, i / 2), 0);
				var o = new f;
				o.shape = n, o.density = j.density, o.friction = j.friction, o.restitution = j.restitution, o.isSensor = j.isSensor || !1, o.isSensor && m.SetUserData({
					playerCollision: !1,
					collisions: [],
					sensor: !0
				});
				var p = m.CreateFixture(o);
				p.SetUserData({
					id: "spawn",
					ent: j.ent
				}), j.top && (n.SetAsOrientedBox(g / 2, .2, new c(g / 2, -.2), 0), o.restitution = j.top.restitution || 0, o.friction = j.top.friction || 0, m.CreateFixture(o)), j.bottom && (n.SetAsOrientedBox(g / 2, .2, new c(g / 2, i), 0), o.friction = j.bottom.friction || 0, o.restitution = j.bottom.restitution || 0, m.CreateFixture(o));
				var q;
				if (j.fixed) {
					m.SetFixedRotation(!1);
					var r = new k,
						s = "y" == j.fixed ? new c(0, 1) : new c(-1, 0);
					r.Initialize(m, this.world.GetGroundBody(), new c(0, 0), s), j.limit && (r.enableLimit = !0, r.lowerTranslation = j.limit.lower, r.upperTranslation = j.limit.upper), j.motor && (r.enableMotor = !0, r.motorSpeed = j.motor.speed, r.maxMotorForce = j.motor.maxForce), q = this.world.CreateJoint(r)
				}
				return q ? {
					body: m,
					joint: q
				} : m
			},
			createCollisionBody: function(a, b) {
				var c = new d;
				c.type = e.b2_staticBody, c.position.Set(a, b);
				var f = this.world.CreateBody(c);
				return f
			},
			createCollisionFixture: function(a) {
				a = a || {};
				var b = new f;
				return b.restitution = a.restitution || 0, b.friction = a.friction || .5, b.density = a.density || 0, b
			},
			accelerate: function(a, b) {
				{
					var d = a.GetLinearVelocity(),
						e = b - d.x;
					a.GetMass() * e
				}
				a.ApplyLinearImpulse(new c(impulse, 0), a.GetWorldCenter())
			},
			createCollisionBox: function(a, b, d, e, f) {
				var g = this.createCollisionBody(a, b),
					i = this.createCollisionFixture(f),
					j = new h;
				return j.SetAsOrientedBox(d / 2, e / 2, new c(d / 2, e / 2), 0), i.shape = j, g.CreateFixture(i), g
			},
			createCollisionPolyline: function(a, b, d, e) {
				for (var f = this.createCollisionBody(b, d), g = this.createCollisionFixture(e), i = 0; i < a.length - 1; i++) {
					var j = new c(a[i].x, a[i].y),
						k = new c(a[i + 1].x, a[i + 1].y),
						l = new h;
					l.SetAsEdge(j, k), g.shape = l, f.CreateFixture(g)
				}
				return f
			},
			createCollisionPolygon: function(a, b, c, d) {
				var e = l.validate(a);
				if (0 !== e) throw "Couldnt separate polygon, validation code " + e;
				var f = this.createCollisionBody(b, c),
					g = this.createCollisionFixture(d);
				return l.separate(f, g, a), f
			},
			getBodyPos: function() {
				return {
					x: 0,
					y: 0
				}
			},
			draw: function() {
				if (this.debugDraw) {
					var a = this.debugDraw.m_ctx;
					a.save(), a.translate(m.display.offset.x, m.display.offset.y), this.world.DrawDebugData(), a.restore()
				}
			},
			initDebug: function(a, b) {
				this.scale = b, this.debugDraw = new i, this.debugDraw.SetSprite(a), this.debugDraw.SetDrawScale(b), this.debugDraw.SetFillAlpha(.3), this.debugDraw.SetLineThickness(1), this.debugDraw.SetFlags(i.e_shapeBit | i.e_jointBit), this.world.SetDebugDraw(this.debugDraw)
			},
			resizeDebug: function(a) {
				this.scale = a, this.debugDraw.SetDrawScale(a)
			},
			dragNDrop: function(a) {
				function b(a) {
					return point = {
						x: ((a.offsetX || a.layerX) - m.display.offset.x) / d.scale,
						y: ((a.offsetY || a.layerY) - m.display.offset.y) / d.scale
					}
				}
				var d = this,
					e = null,
					f = null;
				a.addEventListener("mousedown", function(a) {
					a.preventDefault();
					var c = b(a);
					d.world.QueryPoint(function(a) {
						e = a.GetBody()
					}, c)
				}), a.addEventListener("mousemove", function(a) {
					if (e) {
						var g = b(a);
						if (!f) {
							var h = new Box2D.Dynamics.Joints.b2MouseJointDef;
							h.bodyA = d.world.GetGroundBody(), h.bodyB = e, h.target.Set(g.x, g.y), h.maxForce = 1e5, h.timeStep = d.stepAmount, f = d.world.CreateJoint(h)
						}
						f.SetTarget(new c(g.x, g.y))
					}
				}), a.addEventListener("mouseup", function() {
					e = null, f && (d.world.DestroyJoint(f), f = null)
				})
			}
		};
		b.exports = o
	}, {
		"../lib/box2dweb": 14,
		"../lib/box_2d_separator": 15,
		"../config": 5
	}],
	10: [function(a, b) {
		var c = a("../config"),
			d = a("./graphic"),
			e = a("./tilesheet"),
			f = {
				Graphics: {},
				Sounds: {},
				Data: {},
				_sounds: [],
				callback: null,
				callbackscope: null,
				_stack: {
					unloaded: 0,
					items: {},
					total: 0
				},
				get ready() {
					return this._stack.unloaded <= 0
				},
				get completion() {
					return 100 - ~~(this._stack.unloaded / this._stack.total * 100)
				},
				_doneLoading: function(a) {
					this._stack.unloaded--, this._stack.unloaded <= 0 && (this._stack.unloaded = 0, this._stack.items = {}, this._stack.total = 0), $("#leveltitle").text(100 != this.completion ? "Loading.. " + this.completion + "% done!" : ""), console.info(a + " loaded - Completion: %c" + this.completion + " %", "color: green; font-size: 14px;")
				},
				_errorLoading: function(a) {
					console.warn(a + "could not be loaded!")
				},
				_getPath: function(a, b) {
					return a = a.split("."), a.pop(), a = a.join("/"), a = c.assetsPath + a + "/" + b
				},
				_loadImage: function(a, b) {
					-1 == b.file.indexOf(".") && (b.file += "." + c.defaultExt.img);
					var g = a.replace("img.", "");
					a = this._getPath(a, b.file);
					var h;
					h = b.tilesize || b.tileheight && b.tilewidth ? new e(a, b, this._doneLoading.bind(this)) : new d(a, b, this._doneLoading.bind(this)), Object.$set(f.Graphics, g, h), window.Assets = f
				},
				loadSounds: function() {
					for (var a = this, b = 0; b < this._sounds.length; b++) {
						var c = this._sounds[b],
							d = soundManager.createSound({
								id: c.path,
								url: "media/sounds/" + c.res.file,
								autoLoad: !c.res.stream,
								volume: c.res.volume || 100,
								stream: !!c.res.stream,
								multiShot: !0,
								onload: function() {
									this.stream || a._doneLoading(this.url)
								}
							});
						c.res.stream && a._doneLoading(d.url), Object.$set(f.Sounds, c.path.replace("sfx.", ""), d)
					}
					this._sounds = null
				},
				_loadSound: function(a, b) {
					this._sounds.push({
						path: a,
						res: b
					})
				},
				_loadData: function(a, b) {
					var d = this; - 1 == b.file.indexOf(".") && (b.file += "." + c.defaultExt.data);
					var e = a.replace("data.", "");
					a = this._getPath(a, b.file);
					try {
						var g = new XMLHttpRequest;
						g.onreadystatechange = function() {
							if (4 == g.readyState) {
								var c = JSON.parse(g.responseText);
								Object.$merge(c, b), Object.$set(f.Data, e, c), d._doneLoading(a)
							}
						}, g.open("GET", a, !0), g.send(null)
					} catch (h) {
						throw h
					}
				},
				_load: function(a, b) {
					if (b && a) {
						var c = f,
							d = Object.$get(a, b);
						if (d) {
							var e = b.split(".")[0];
							switch (e) {
								case "sfx":
									c._loadSound(b, d);
									break;
								case "img":
									c._loadImage(b, d);
									break;
								case "data":
									c._loadData(b, d)
							}
						}
					}
				},
				loadAll: function(a, b) {
					var c = f,
						d = Object.$get(a, b);
					for (var e in d) {
						var g = b ? b + "." + e : e;
						d[e].file ? (this._stack.items[g] = d[e], this._stack.unloaded++, this._stack.total++) : "object" == typeof d[e] && c.loadAll(a, g)
					}
					if (!b)
						for (var h in this._stack.items) this._load(a, h)
				},
				resizeAll: function(a) {
					var b = f,
						c = Object.$get(f.Graphics, a);
					for (var e in c) {
						var g = a ? a + "." + e : e;
						c[e] instanceof d ? c[e].resizeAll() : b.resizeAll(g)
					}
				},
				onReady: function(a, b) {
					this.callback = a, this.callbackscope = b, this.tick()
				},
				tick: function() {
					return this.ready ? (this.callback.call(this.callbackscope), void 0) : (requestAnimFrame(this.tick.bind(this)), void 0)
				}
			};
		b.exports = f
	}, {
		"../config": 5,
		"./graphic": 16,
		"./tilesheet": 17
	}],
	12: [function(a, b) {
		var c = {
			MOUSE: 0,
			BACKSPACE: 8,
			TAB: 9,
			ENTER: 13,
			SHIFT: 16,
			CTRL: 17,
			ALT: 18,
			PAUSE: 19,
			CAPS: 20,
			ESC: 27,
			SPACE: 32,
			PAGE_UP: 33,
			PAGE_DOWN: 34,
			END: 35,
			HOME: 36,
			LEFT_ARROW: 37,
			UP_ARROW: 38,
			RIGHT_ARROW: 39,
			DOWN_ARROW: 40,
			INSERT: 45,
			DELETE: 46,
			_0: 48,
			_1: 49,
			_2: 50,
			_3: 51,
			_4: 52,
			_5: 53,
			_6: 54,
			_7: 55,
			_8: 56,
			_9: 57,
			A: 65,
			B: 66,
			C: 67,
			D: 68,
			E: 69,
			F: 70,
			G: 71,
			H: 72,
			I: 73,
			J: 74,
			K: 75,
			L: 76,
			M: 77,
			N: 78,
			O: 79,
			P: 80,
			Q: 81,
			R: 82,
			S: 83,
			T: 84,
			U: 85,
			V: 86,
			W: 87,
			X: 88,
			Y: 89,
			Z: 90,
			NUMPAD_0: 96,
			NUMPAD_1: 97,
			NUMPAD_2: 98,
			NUMPAD_3: 99,
			NUMPAD_4: 100,
			NUMPAD_5: 101,
			NUMPAD_6: 102,
			NUMPAD_7: 103,
			NUMPAD_8: 104,
			NUMPAD_9: 105,
			MULTIPLY: 106,
			F1: 112,
			F2: 113,
			F3: 114,
			F4: 115,
			F5: 116,
			F6: 117,
			F7: 118,
			F8: 119,
			F9: 120,
			F10: 121,
			F11: 122,
			F12: 123
		};
		b.exports = c
	}, {}],
	14: [function(a, b) {
		! function() {
			var a = {};
			! function(a, b) {
				function c() {}!(Object.prototype.defineProperty instanceof Function) && Object.prototype.__defineGetter__ instanceof Function && Object.prototype.__defineSetter__ instanceof Function && (Object.defineProperty = function(a, b, c) {
					c.get instanceof Function && a.__defineGetter__(b, c.get), c.set instanceof Function && a.__defineSetter__(b, c.set)
				}), a.inherit = function(a, b) {
					var d = a;
					c.prototype = b.prototype, a.prototype = new c, a.prototype.constructor = d
				}, a.generateCallback = function(a, b) {
					return function() {
						b.apply(a, arguments)
					}
				}, a.NVector = function(a) {
					a === b && (a = 0);
					for (var c = new Array(a || 0), d = 0; a > d; ++d) c[d] = 0;
					return c
				}, a.is = function(a, c) {
					return null === a ? !1 : c instanceof Function && a instanceof c ? !0 : a.constructor.__implements != b && a.constructor.__implements[c] ? !0 : !1
				}, a.parseUInt = function(a) {
					return Math.abs(parseInt(a))
				}
			}(a);
			var c = Array,
				d = a.NVector;
			"undefined" == typeof a && (a = {}), "undefined" == typeof a.Collision && (a.Collision = {}), "undefined" == typeof a.Collision.Shapes && (a.Collision.Shapes = {}), "undefined" == typeof a.Common && (a.Common = {}), "undefined" == typeof a.Common.Math && (a.Common.Math = {}), "undefined" == typeof a.Dynamics && (a.Dynamics = {}), "undefined" == typeof a.Dynamics.Contacts && (a.Dynamics.Contacts = {}), "undefined" == typeof a.Dynamics.Controllers && (a.Dynamics.Controllers = {}), "undefined" == typeof a.Dynamics.Joints && (a.Dynamics.Joints = {}),
				function() {
					function b() {
						b.b2AABB.apply(this, arguments)
					}

					function c() {
						c.b2Bound.apply(this, arguments)
					}

					function d() {
						d.b2BoundValues.apply(this, arguments), this.constructor === d && this.b2BoundValues.apply(this, arguments)
					}

					function e() {
						e.b2Collision.apply(this, arguments)
					}

					function f() {
						f.b2ContactID.apply(this, arguments), this.constructor === f && this.b2ContactID.apply(this, arguments)
					}

					function g() {
						g.b2ContactPoint.apply(this, arguments)
					}

					function h() {
						h.b2Distance.apply(this, arguments)
					}

					function i() {
						i.b2DistanceInput.apply(this, arguments)
					}

					function j() {
						j.b2DistanceOutput.apply(this, arguments)
					}

					function k() {
						k.b2DistanceProxy.apply(this, arguments)
					}

					function l() {
						l.b2DynamicTree.apply(this, arguments), this.constructor === l && this.b2DynamicTree.apply(this, arguments)
					}

					function m() {
						m.b2DynamicTreeBroadPhase.apply(this, arguments)
					}

					function n() {
						n.b2DynamicTreeNode.apply(this, arguments)
					}

					function o() {
						o.b2DynamicTreePair.apply(this, arguments)
					}

					function p() {
						p.b2Manifold.apply(this, arguments), this.constructor === p && this.b2Manifold.apply(this, arguments)
					}

					function q() {
						q.b2ManifoldPoint.apply(this, arguments), this.constructor === q && this.b2ManifoldPoint.apply(this, arguments)
					}

					function r() {
						r.b2Point.apply(this, arguments)
					}

					function s() {
						s.b2RayCastInput.apply(this, arguments), this.constructor === s && this.b2RayCastInput.apply(this, arguments)
					}

					function t() {
						t.b2RayCastOutput.apply(this, arguments)
					}

					function u() {
						u.b2Segment.apply(this, arguments)
					}

					function v() {
						v.b2SeparationFunction.apply(this, arguments)
					}

					function w() {
						w.b2Simplex.apply(this, arguments), this.constructor === w && this.b2Simplex.apply(this, arguments)
					}

					function x() {
						x.b2SimplexCache.apply(this, arguments)
					}

					function y() {
						y.b2SimplexVertex.apply(this, arguments)
					}

					function z() {
						z.b2TimeOfImpact.apply(this, arguments)
					}

					function A() {
						A.b2TOIInput.apply(this, arguments)
					}

					function B() {
						B.b2WorldManifold.apply(this, arguments), this.constructor === B && this.b2WorldManifold.apply(this, arguments)
					}

					function C() {
						C.ClipVertex.apply(this, arguments)
					}

					function D() {
						D.Features.apply(this, arguments)
					}

					function E() {
						E.b2CircleShape.apply(this, arguments), this.constructor === E && this.b2CircleShape.apply(this, arguments)
					}

					function F() {
						F.b2EdgeChainDef.apply(this, arguments), this.constructor === F && this.b2EdgeChainDef.apply(this, arguments)
					}

					function G() {
						G.b2EdgeShape.apply(this, arguments), this.constructor === G && this.b2EdgeShape.apply(this, arguments)
					}

					function H() {
						H.b2MassData.apply(this, arguments)
					}

					function I() {
						I.b2PolygonShape.apply(this, arguments), this.constructor === I && this.b2PolygonShape.apply(this, arguments)
					}

					function J() {
						J.b2Shape.apply(this, arguments), this.constructor === J && this.b2Shape.apply(this, arguments)
					}

					function K() {
						K.b2Color.apply(this, arguments), this.constructor === K && this.b2Color.apply(this, arguments)
					}

					function L() {
						L.b2Settings.apply(this, arguments)
					}

					function M() {
						M.b2Mat22.apply(this, arguments), this.constructor === M && this.b2Mat22.apply(this, arguments)
					}

					function N() {
						N.b2Mat33.apply(this, arguments), this.constructor === N && this.b2Mat33.apply(this, arguments)
					}

					function O() {
						O.b2Math.apply(this, arguments)
					}

					function P() {
						P.b2Sweep.apply(this, arguments)
					}

					function Q() {
						Q.b2Transform.apply(this, arguments), this.constructor === Q && this.b2Transform.apply(this, arguments)
					}

					function R() {
						R.b2Vec2.apply(this, arguments), this.constructor === R && this.b2Vec2.apply(this, arguments)
					}

					function S() {
						S.b2Vec3.apply(this, arguments), this.constructor === S && this.b2Vec3.apply(this, arguments)
					}

					function T() {
						T.b2Body.apply(this, arguments), this.constructor === T && this.b2Body.apply(this, arguments)
					}

					function U() {
						U.b2BodyDef.apply(this, arguments), this.constructor === U && this.b2BodyDef.apply(this, arguments)
					}

					function V() {
						V.b2ContactFilter.apply(this, arguments)
					}

					function W() {
						W.b2ContactImpulse.apply(this, arguments)
					}

					function X() {
						X.b2ContactListener.apply(this, arguments)
					}

					function Y() {
						Y.b2ContactManager.apply(this, arguments), this.constructor === Y && this.b2ContactManager.apply(this, arguments)
					}

					function Z() {
						Z.b2DebugDraw.apply(this, arguments), this.constructor === Z && this.b2DebugDraw.apply(this, arguments)
					}

					function $() {
						$.b2DestructionListener.apply(this, arguments)
					}

					function _() {
						_.b2FilterData.apply(this, arguments)
					}

					function ab() {
						ab.b2Fixture.apply(this, arguments), this.constructor === ab && this.b2Fixture.apply(this, arguments)
					}

					function bb() {
						bb.b2FixtureDef.apply(this, arguments), this.constructor === bb && this.b2FixtureDef.apply(this, arguments)
					}

					function cb() {
						cb.b2Island.apply(this, arguments), this.constructor === cb && this.b2Island.apply(this, arguments)
					}

					function db() {
						db.b2TimeStep.apply(this, arguments)
					}

					function eb() {
						eb.b2World.apply(this, arguments), this.constructor === eb && this.b2World.apply(this, arguments)
					}

					function fb() {
						fb.b2CircleContact.apply(this, arguments)
					}

					function gb() {
						gb.b2Contact.apply(this, arguments), this.constructor === gb && this.b2Contact.apply(this, arguments)
					}

					function hb() {
						hb.b2ContactConstraint.apply(this, arguments), this.constructor === hb && this.b2ContactConstraint.apply(this, arguments)
					}

					function ib() {
						ib.b2ContactConstraintPoint.apply(this, arguments)
					}

					function jb() {
						jb.b2ContactEdge.apply(this, arguments)
					}

					function kb() {
						kb.b2ContactFactory.apply(this, arguments), this.constructor === kb && this.b2ContactFactory.apply(this, arguments)
					}

					function lb() {
						lb.b2ContactRegister.apply(this, arguments)
					}

					function mb() {
						mb.b2ContactResult.apply(this, arguments)
					}

					function nb() {
						nb.b2ContactSolver.apply(this, arguments), this.constructor === nb && this.b2ContactSolver.apply(this, arguments)
					}

					function ob() {
						ob.b2EdgeAndCircleContact.apply(this, arguments)
					}

					function pb() {
						pb.b2NullContact.apply(this, arguments), this.constructor === pb && this.b2NullContact.apply(this, arguments)
					}

					function qb() {
						qb.b2PolyAndCircleContact.apply(this, arguments)
					}

					function rb() {
						rb.b2PolyAndEdgeContact.apply(this, arguments)
					}

					function sb() {
						sb.b2PolygonContact.apply(this, arguments)
					}

					function tb() {
						tb.b2PositionSolverManifold.apply(this, arguments), this.constructor === tb && this.b2PositionSolverManifold.apply(this, arguments)
					}

					function ub() {
						ub.b2BuoyancyController.apply(this, arguments)
					}

					function vb() {
						vb.b2ConstantAccelController.apply(this, arguments)
					}

					function wb() {
						wb.b2ConstantForceController.apply(this, arguments)
					}

					function xb() {
						xb.b2Controller.apply(this, arguments)
					}

					function yb() {
						yb.b2ControllerEdge.apply(this, arguments)
					}

					function zb() {
						zb.b2GravityController.apply(this, arguments)
					}

					function Ab() {
						Ab.b2TensorDampingController.apply(this, arguments)
					}

					function Bb() {
						Bb.b2DistanceJoint.apply(this, arguments), this.constructor === Bb && this.b2DistanceJoint.apply(this, arguments)
					}

					function Cb() {
						Cb.b2DistanceJointDef.apply(this, arguments), this.constructor === Cb && this.b2DistanceJointDef.apply(this, arguments)
					}

					function Db() {
						Db.b2FrictionJoint.apply(this, arguments), this.constructor === Db && this.b2FrictionJoint.apply(this, arguments)
					}

					function Eb() {
						Eb.b2FrictionJointDef.apply(this, arguments), this.constructor === Eb && this.b2FrictionJointDef.apply(this, arguments)
					}

					function Fb() {
						Fb.b2GearJoint.apply(this, arguments), this.constructor === Fb && this.b2GearJoint.apply(this, arguments)
					}

					function Gb() {
						Gb.b2GearJointDef.apply(this, arguments), this.constructor === Gb && this.b2GearJointDef.apply(this, arguments)
					}

					function Hb() {
						Hb.b2Jacobian.apply(this, arguments)
					}

					function Ib() {
						Ib.b2Joint.apply(this, arguments), this.constructor === Ib && this.b2Joint.apply(this, arguments)
					}

					function Jb() {
						Jb.b2JointDef.apply(this, arguments), this.constructor === Jb && this.b2JointDef.apply(this, arguments)
					}

					function Kb() {
						Kb.b2JointEdge.apply(this, arguments)
					}

					function Lb() {
						Lb.b2LineJoint.apply(this, arguments), this.constructor === Lb && this.b2LineJoint.apply(this, arguments)
					}

					function Mb() {
						Mb.b2LineJointDef.apply(this, arguments), this.constructor === Mb && this.b2LineJointDef.apply(this, arguments)
					}

					function Nb() {
						Nb.b2MouseJoint.apply(this, arguments), this.constructor === Nb && this.b2MouseJoint.apply(this, arguments)
					}

					function Ob() {
						Ob.b2MouseJointDef.apply(this, arguments), this.constructor === Ob && this.b2MouseJointDef.apply(this, arguments)
					}

					function Pb() {
						Pb.b2PrismaticJoint.apply(this, arguments), this.constructor === Pb && this.b2PrismaticJoint.apply(this, arguments)
					}

					function Qb() {
						Qb.b2PrismaticJointDef.apply(this, arguments), this.constructor === Qb && this.b2PrismaticJointDef.apply(this, arguments)
					}

					function Rb() {
						Rb.b2PulleyJoint.apply(this, arguments), this.constructor === Rb && this.b2PulleyJoint.apply(this, arguments)
					}

					function Sb() {
						Sb.b2PulleyJointDef.apply(this, arguments), this.constructor === Sb && this.b2PulleyJointDef.apply(this, arguments)
					}

					function Tb() {
						Tb.b2RevoluteJoint.apply(this, arguments), this.constructor === Tb && this.b2RevoluteJoint.apply(this, arguments)
					}

					function Ub() {
						Ub.b2RevoluteJointDef.apply(this, arguments), this.constructor === Ub && this.b2RevoluteJointDef.apply(this, arguments)
					}

					function Vb() {
						Vb.b2WeldJoint.apply(this, arguments), this.constructor === Vb && this.b2WeldJoint.apply(this, arguments)
					}

					function Wb() {
						Wb.b2WeldJointDef.apply(this, arguments), this.constructor === Wb && this.b2WeldJointDef.apply(this, arguments)
					}
					a.Collision.IBroadPhase = "Box2D.Collision.IBroadPhase", a.Collision.b2AABB = b, a.Collision.b2Bound = c, a.Collision.b2BoundValues = d, a.Collision.b2Collision = e, a.Collision.b2ContactID = f, a.Collision.b2ContactPoint = g, a.Collision.b2Distance = h, a.Collision.b2DistanceInput = i, a.Collision.b2DistanceOutput = j, a.Collision.b2DistanceProxy = k, a.Collision.b2DynamicTree = l, a.Collision.b2DynamicTreeBroadPhase = m, a.Collision.b2DynamicTreeNode = n, a.Collision.b2DynamicTreePair = o, a.Collision.b2Manifold = p, a.Collision.b2ManifoldPoint = q, a.Collision.b2Point = r, a.Collision.b2RayCastInput = s, a.Collision.b2RayCastOutput = t, a.Collision.b2Segment = u, a.Collision.b2SeparationFunction = v, a.Collision.b2Simplex = w, a.Collision.b2SimplexCache = x, a.Collision.b2SimplexVertex = y, a.Collision.b2TimeOfImpact = z, a.Collision.b2TOIInput = A, a.Collision.b2WorldManifold = B, a.Collision.ClipVertex = C, a.Collision.Features = D, a.Collision.Shapes.b2CircleShape = E, a.Collision.Shapes.b2EdgeChainDef = F, a.Collision.Shapes.b2EdgeShape = G, a.Collision.Shapes.b2MassData = H, a.Collision.Shapes.b2PolygonShape = I, a.Collision.Shapes.b2Shape = J, a.Common.b2internal = "Box2D.Common.b2internal", a.Common.b2Color = K, a.Common.b2Settings = L, a.Common.Math.b2Mat22 = M, a.Common.Math.b2Mat33 = N, a.Common.Math.b2Math = O, a.Common.Math.b2Sweep = P, a.Common.Math.b2Transform = Q, a.Common.Math.b2Vec2 = R, a.Common.Math.b2Vec3 = S, a.Dynamics.b2Body = T, a.Dynamics.b2BodyDef = U, a.Dynamics.b2ContactFilter = V, a.Dynamics.b2ContactImpulse = W, a.Dynamics.b2ContactListener = X, a.Dynamics.b2ContactManager = Y, a.Dynamics.b2DebugDraw = Z, a.Dynamics.b2DestructionListener = $, a.Dynamics.b2FilterData = _, a.Dynamics.b2Fixture = ab, a.Dynamics.b2FixtureDef = bb, a.Dynamics.b2Island = cb, a.Dynamics.b2TimeStep = db, a.Dynamics.b2World = eb, a.Dynamics.Contacts.b2CircleContact = fb, a.Dynamics.Contacts.b2Contact = gb, a.Dynamics.Contacts.b2ContactConstraint = hb, a.Dynamics.Contacts.b2ContactConstraintPoint = ib, a.Dynamics.Contacts.b2ContactEdge = jb, a.Dynamics.Contacts.b2ContactFactory = kb, a.Dynamics.Contacts.b2ContactRegister = lb, a.Dynamics.Contacts.b2ContactResult = mb, a.Dynamics.Contacts.b2ContactSolver = nb, a.Dynamics.Contacts.b2EdgeAndCircleContact = ob, a.Dynamics.Contacts.b2NullContact = pb, a.Dynamics.Contacts.b2PolyAndCircleContact = qb, a.Dynamics.Contacts.b2PolyAndEdgeContact = rb, a.Dynamics.Contacts.b2PolygonContact = sb, a.Dynamics.Contacts.b2PositionSolverManifold = tb, a.Dynamics.Controllers.b2BuoyancyController = ub, a.Dynamics.Controllers.b2ConstantAccelController = vb, a.Dynamics.Controllers.b2ConstantForceController = wb, a.Dynamics.Controllers.b2Controller = xb, a.Dynamics.Controllers.b2ControllerEdge = yb, a.Dynamics.Controllers.b2GravityController = zb, a.Dynamics.Controllers.b2TensorDampingController = Ab, a.Dynamics.Joints.b2DistanceJoint = Bb, a.Dynamics.Joints.b2DistanceJointDef = Cb, a.Dynamics.Joints.b2FrictionJoint = Db, a.Dynamics.Joints.b2FrictionJointDef = Eb, a.Dynamics.Joints.b2GearJoint = Fb, a.Dynamics.Joints.b2GearJointDef = Gb, a.Dynamics.Joints.b2Jacobian = Hb, a.Dynamics.Joints.b2Joint = Ib, a.Dynamics.Joints.b2JointDef = Jb, a.Dynamics.Joints.b2JointEdge = Kb, a.Dynamics.Joints.b2LineJoint = Lb, a.Dynamics.Joints.b2LineJointDef = Mb, a.Dynamics.Joints.b2MouseJoint = Nb, a.Dynamics.Joints.b2MouseJointDef = Ob, a.Dynamics.Joints.b2PrismaticJoint = Pb, a.Dynamics.Joints.b2PrismaticJointDef = Qb, a.Dynamics.Joints.b2PulleyJoint = Rb, a.Dynamics.Joints.b2PulleyJointDef = Sb, a.Dynamics.Joints.b2RevoluteJoint = Tb, a.Dynamics.Joints.b2RevoluteJointDef = Ub, a.Dynamics.Joints.b2WeldJoint = Vb, a.Dynamics.Joints.b2WeldJointDef = Wb
				}(), a.postDefs = [],
				function() {
					var b = a.Collision.Shapes.b2CircleShape,
						e = (a.Collision.Shapes.b2EdgeChainDef, a.Collision.Shapes.b2EdgeShape, a.Collision.Shapes.b2MassData, a.Collision.Shapes.b2PolygonShape),
						f = a.Collision.Shapes.b2Shape,
						g = (a.Common.b2Color, a.Common.b2internal, a.Common.b2Settings),
						h = (a.Common.Math.b2Mat22, a.Common.Math.b2Mat33, a.Common.Math.b2Math),
						i = a.Common.Math.b2Sweep,
						j = a.Common.Math.b2Transform,
						k = a.Common.Math.b2Vec2,
						l = (a.Common.Math.b2Vec3, a.Collision.b2AABB),
						m = a.Collision.b2Bound,
						n = a.Collision.b2BoundValues,
						o = a.Collision.b2Collision,
						p = a.Collision.b2ContactID,
						q = a.Collision.b2ContactPoint,
						r = a.Collision.b2Distance,
						s = a.Collision.b2DistanceInput,
						t = a.Collision.b2DistanceOutput,
						u = a.Collision.b2DistanceProxy,
						v = a.Collision.b2DynamicTree,
						w = a.Collision.b2DynamicTreeBroadPhase,
						x = a.Collision.b2DynamicTreeNode,
						y = a.Collision.b2DynamicTreePair,
						z = a.Collision.b2Manifold,
						A = a.Collision.b2ManifoldPoint,
						B = a.Collision.b2Point,
						C = a.Collision.b2RayCastInput,
						D = a.Collision.b2RayCastOutput,
						E = a.Collision.b2Segment,
						F = a.Collision.b2SeparationFunction,
						G = a.Collision.b2Simplex,
						H = a.Collision.b2SimplexCache,
						I = a.Collision.b2SimplexVertex,
						J = a.Collision.b2TimeOfImpact,
						K = a.Collision.b2TOIInput,
						L = a.Collision.b2WorldManifold,
						M = a.Collision.ClipVertex,
						N = a.Collision.Features,
						O = a.Collision.IBroadPhase;
					l.b2AABB = function() {
						this.lowerBound = new k, this.upperBound = new k
					}, l.prototype.IsValid = function() {
						var a = this.upperBound.x - this.lowerBound.x,
							b = this.upperBound.y - this.lowerBound.y,
							c = a >= 0 && b >= 0;
						return c = c && this.lowerBound.IsValid() && this.upperBound.IsValid()
					}, l.prototype.GetCenter = function() {
						return new k((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
					}, l.prototype.GetExtents = function() {
						return new k((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
					}, l.prototype.Contains = function(a) {
						var b = !0;
						return b = b && this.lowerBound.x <= a.lowerBound.x, b = b && this.lowerBound.y <= a.lowerBound.y, b = b && a.upperBound.x <= this.upperBound.x, b = b && a.upperBound.y <= this.upperBound.y
					}, l.prototype.RayCast = function(a, b) {
						var c = -Number.MAX_VALUE,
							d = Number.MAX_VALUE,
							e = b.p1.x,
							f = b.p1.y,
							g = b.p2.x - b.p1.x,
							h = b.p2.y - b.p1.y,
							i = Math.abs(g),
							j = Math.abs(h),
							k = a.normal,
							l = 0,
							m = 0,
							n = 0,
							o = 0,
							p = 0;
						if (i < Number.MIN_VALUE) {
							if (e < this.lowerBound.x || this.upperBound.x < e) return !1
						} else if (l = 1 / g, m = (this.lowerBound.x - e) * l, n = (this.upperBound.x - e) * l, p = -1, m > n && (o = m, m = n, n = o, p = 1), m > c && (k.x = p, k.y = 0, c = m), d = Math.min(d, n), c > d) return !1;
						if (j < Number.MIN_VALUE) {
							if (f < this.lowerBound.y || this.upperBound.y < f) return !1
						} else if (l = 1 / h, m = (this.lowerBound.y - f) * l, n = (this.upperBound.y - f) * l, p = -1, m > n && (o = m, m = n, n = o, p = 1), m > c && (k.y = p, k.x = 0, c = m), d = Math.min(d, n), c > d) return !1;
						return a.fraction = c, !0
					}, l.prototype.TestOverlap = function(a) {
						var b = a.lowerBound.x - this.upperBound.x,
							c = a.lowerBound.y - this.upperBound.y,
							d = this.lowerBound.x - a.upperBound.x,
							e = this.lowerBound.y - a.upperBound.y;
						return b > 0 || c > 0 ? !1 : d > 0 || e > 0 ? !1 : !0
					}, l.Combine = function(a, b) {
						var c = new l;
						return c.Combine(a, b), c
					}, l.prototype.Combine = function(a, b) {
						this.lowerBound.x = Math.min(a.lowerBound.x, b.lowerBound.x), this.lowerBound.y = Math.min(a.lowerBound.y, b.lowerBound.y), this.upperBound.x = Math.max(a.upperBound.x, b.upperBound.x), this.upperBound.y = Math.max(a.upperBound.y, b.upperBound.y)
					}, m.b2Bound = function() {}, m.prototype.IsLower = function() {
						return 0 == (1 & this.value)
					}, m.prototype.IsUpper = function() {
						return 1 == (1 & this.value)
					}, m.prototype.Swap = function(a) {
						var b = this.value,
							c = this.proxy,
							d = this.stabbingCount;
						this.value = a.value, this.proxy = a.proxy, this.stabbingCount = a.stabbingCount, a.value = b, a.proxy = c, a.stabbingCount = d
					}, n.b2BoundValues = function() {}, n.prototype.b2BoundValues = function() {
						this.lowerValues = new d, this.lowerValues[0] = 0, this.lowerValues[1] = 0, this.upperValues = new d, this.upperValues[0] = 0, this.upperValues[1] = 0
					}, o.b2Collision = function() {}, o.ClipSegmentToLine = function(a, b, c, d) {
						void 0 === d && (d = 0);
						var e, f = 0;
						e = b[0];
						var g = e.v;
						e = b[1];
						var h = e.v,
							i = c.x * g.x + c.y * g.y - d,
							j = c.x * h.x + c.y * h.y - d;
						if (0 >= i && a[f++].Set(b[0]), 0 >= j && a[f++].Set(b[1]), 0 > i * j) {
							var k = i / (i - j);
							e = a[f];
							var l = e.v;
							l.x = g.x + k * (h.x - g.x), l.y = g.y + k * (h.y - g.y), e = a[f];
							var m;
							i > 0 ? (m = b[0], e.id = m.id) : (m = b[1], e.id = m.id), ++f
						}
						return f
					}, o.EdgeSeparation = function(a, b, c, d, e) {
						void 0 === c && (c = 0);
						var f, g, h = (parseInt(a.m_vertexCount), a.m_vertices),
							i = a.m_normals,
							j = parseInt(d.m_vertexCount),
							k = d.m_vertices;
						f = b.R, g = i[c];
						var l = f.col1.x * g.x + f.col2.x * g.y,
							m = f.col1.y * g.x + f.col2.y * g.y;
						f = e.R;
						for (var n = f.col1.x * l + f.col1.y * m, o = f.col2.x * l + f.col2.y * m, p = 0, q = Number.MAX_VALUE, r = 0; j > r; ++r) {
							g = k[r];
							var s = g.x * n + g.y * o;
							q > s && (q = s, p = r)
						}
						g = h[c], f = b.R;
						var t = b.position.x + (f.col1.x * g.x + f.col2.x * g.y),
							u = b.position.y + (f.col1.y * g.x + f.col2.y * g.y);
						g = k[p], f = e.R;
						var v = e.position.x + (f.col1.x * g.x + f.col2.x * g.y),
							w = e.position.y + (f.col1.y * g.x + f.col2.y * g.y);
						v -= t, w -= u;
						var x = v * l + w * m;
						return x
					}, o.FindMaxSeparation = function(a, b, c, d, e) {
						var f, g, h = parseInt(b.m_vertexCount),
							i = b.m_normals;
						g = e.R, f = d.m_centroid;
						var j = e.position.x + (g.col1.x * f.x + g.col2.x * f.y),
							k = e.position.y + (g.col1.y * f.x + g.col2.y * f.y);
						g = c.R, f = b.m_centroid, j -= c.position.x + (g.col1.x * f.x + g.col2.x * f.y), k -= c.position.y + (g.col1.y * f.x + g.col2.y * f.y);
						for (var l = j * c.R.col1.x + k * c.R.col1.y, m = j * c.R.col2.x + k * c.R.col2.y, n = 0, p = -Number.MAX_VALUE, q = 0; h > q; ++q) {
							f = i[q];
							var r = f.x * l + f.y * m;
							r > p && (p = r, n = q)
						}
						var s = o.EdgeSeparation(b, c, n, d, e),
							t = parseInt(n - 1 >= 0 ? n - 1 : h - 1),
							u = o.EdgeSeparation(b, c, t, d, e),
							v = parseInt(h > n + 1 ? n + 1 : 0),
							w = o.EdgeSeparation(b, c, v, d, e),
							x = 0,
							y = 0,
							z = 0;
						if (u > s && u > w) z = -1, x = t, y = u;
						else {
							if (!(w > s)) return a[0] = n, s;
							z = 1, x = v, y = w
						}
						for (;;) {
							if (n = -1 == z ? x - 1 >= 0 ? x - 1 : h - 1 : h > x + 1 ? x + 1 : 0, s = o.EdgeSeparation(b, c, n, d, e), !(s > y)) break;
							x = n, y = s
						}
						return a[0] = x, y
					}, o.FindIncidentEdge = function(a, b, c, d, e, f) {
						void 0 === d && (d = 0);
						var g, h, i = (parseInt(b.m_vertexCount), b.m_normals),
							j = parseInt(e.m_vertexCount),
							k = e.m_vertices,
							l = e.m_normals;
						g = c.R, h = i[d];
						var m = g.col1.x * h.x + g.col2.x * h.y,
							n = g.col1.y * h.x + g.col2.y * h.y;
						g = f.R;
						var o = g.col1.x * m + g.col1.y * n;
						n = g.col2.x * m + g.col2.y * n, m = o;
						for (var p = 0, q = Number.MAX_VALUE, r = 0; j > r; ++r) {
							h = l[r];
							var s = m * h.x + n * h.y;
							q > s && (q = s, p = r)
						}
						var t, u = parseInt(p),
							v = parseInt(j > u + 1 ? u + 1 : 0);
						t = a[0], h = k[u], g = f.R, t.v.x = f.position.x + (g.col1.x * h.x + g.col2.x * h.y), t.v.y = f.position.y + (g.col1.y * h.x + g.col2.y * h.y), t.id.features.referenceEdge = d, t.id.features.incidentEdge = u, t.id.features.incidentVertex = 0, t = a[1], h = k[v], g = f.R, t.v.x = f.position.x + (g.col1.x * h.x + g.col2.x * h.y), t.v.y = f.position.y + (g.col1.y * h.x + g.col2.y * h.y), t.id.features.referenceEdge = d, t.id.features.incidentEdge = v, t.id.features.incidentVertex = 1
					}, o.MakeClipPointVector = function() {
						var a = new c(2);
						return a[0] = new M, a[1] = new M, a
					}, o.CollidePolygons = function(a, b, c, d, e) {
						var f;
						a.m_pointCount = 0;
						var h = b.m_radius + d.m_radius,
							i = 0;
						o.s_edgeAO[0] = i;
						var j = o.FindMaxSeparation(o.s_edgeAO, b, c, d, e);
						if (i = o.s_edgeAO[0], !(j > h)) {
							var k = 0;
							o.s_edgeBO[0] = k;
							var l = o.FindMaxSeparation(o.s_edgeBO, d, e, b, c);
							if (k = o.s_edgeBO[0], !(l > h)) {
								var m, n, p, q, r, s = 0,
									t = 0,
									u = .98,
									v = .001;
								l > u * j + v ? (m = d, n = b, p = e, q = c, s = k, a.m_type = z.e_faceB, t = 1) : (m = b, n = d, p = c, q = e, s = i, a.m_type = z.e_faceA, t = 0);
								var w = o.s_incidentEdge;
								o.FindIncidentEdge(w, m, p, s, n, q);
								var x, y = parseInt(m.m_vertexCount),
									A = m.m_vertices,
									B = A[s];
								x = y > s + 1 ? A[parseInt(s + 1)] : A[0];
								var C = o.s_localTangent;
								C.Set(x.x - B.x, x.y - B.y), C.Normalize();
								var D = o.s_localNormal;
								D.x = C.y, D.y = -C.x;
								var E = o.s_planePoint;
								E.Set(.5 * (B.x + x.x), .5 * (B.y + x.y));
								var F = o.s_tangent;
								r = p.R, F.x = r.col1.x * C.x + r.col2.x * C.y, F.y = r.col1.y * C.x + r.col2.y * C.y;
								var G = o.s_tangent2;
								G.x = -F.x, G.y = -F.y;
								var H = o.s_normal;
								H.x = F.y, H.y = -F.x;
								var I = o.s_v11,
									J = o.s_v12;
								I.x = p.position.x + (r.col1.x * B.x + r.col2.x * B.y), I.y = p.position.y + (r.col1.y * B.x + r.col2.y * B.y), J.x = p.position.x + (r.col1.x * x.x + r.col2.x * x.y), J.y = p.position.y + (r.col1.y * x.x + r.col2.y * x.y);
								var K = H.x * I.x + H.y * I.y,
									L = -F.x * I.x - F.y * I.y + h,
									M = F.x * J.x + F.y * J.y + h,
									N = o.s_clipPoints1,
									O = o.s_clipPoints2,
									P = 0;
								if (P = o.ClipSegmentToLine(N, w, G, L), !(2 > P || (P = o.ClipSegmentToLine(O, N, F, M), 2 > P))) {
									a.m_localPlaneNormal.SetV(D), a.m_localPoint.SetV(E);
									for (var Q = 0, R = 0; R < g.b2_maxManifoldPoints; ++R) {
										f = O[R];
										var S = H.x * f.v.x + H.y * f.v.y - K;
										if (h >= S) {
											var T = a.m_points[Q];
											r = q.R;
											var U = f.v.x - q.position.x,
												V = f.v.y - q.position.y;
											T.m_localPoint.x = U * r.col1.x + V * r.col1.y, T.m_localPoint.y = U * r.col2.x + V * r.col2.y, T.m_id.Set(f.id), T.m_id.features.flip = t, ++Q
										}
									}
									a.m_pointCount = Q
								}
							}
						}
					}, o.CollideCircles = function(a, b, c, d, e) {
						a.m_pointCount = 0;
						var f, g;
						f = c.R, g = b.m_p;
						var h = c.position.x + (f.col1.x * g.x + f.col2.x * g.y),
							i = c.position.y + (f.col1.y * g.x + f.col2.y * g.y);
						f = e.R, g = d.m_p;
						var j = e.position.x + (f.col1.x * g.x + f.col2.x * g.y),
							k = e.position.y + (f.col1.y * g.x + f.col2.y * g.y),
							l = j - h,
							m = k - i,
							n = l * l + m * m,
							o = b.m_radius + d.m_radius;
						n > o * o || (a.m_type = z.e_circles, a.m_localPoint.SetV(b.m_p), a.m_localPlaneNormal.SetZero(), a.m_pointCount = 1, a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.key = 0)
					}, o.CollidePolygonAndCircle = function(a, b, c, d, e) {
						a.m_pointCount = 0;
						var f, g, h = 0,
							i = 0;
						g = e.R, f = d.m_p;
						var j = e.position.x + (g.col1.x * f.x + g.col2.x * f.y),
							k = e.position.y + (g.col1.y * f.x + g.col2.y * f.y);
						h = j - c.position.x, i = k - c.position.y, g = c.R;
						for (var l = h * g.col1.x + i * g.col1.y, m = h * g.col2.x + i * g.col2.y, n = 0, o = -Number.MAX_VALUE, p = b.m_radius + d.m_radius, q = parseInt(b.m_vertexCount), r = b.m_vertices, s = b.m_normals, t = 0; q > t; ++t) {
							f = r[t], h = l - f.x, i = m - f.y, f = s[t];
							var u = f.x * h + f.y * i;
							if (u > p) return;
							u > o && (o = u, n = t)
						}
						var v = parseInt(n),
							w = parseInt(q > v + 1 ? v + 1 : 0),
							x = r[v],
							y = r[w];
						if (o < Number.MIN_VALUE) return a.m_pointCount = 1, a.m_type = z.e_faceA, a.m_localPlaneNormal.SetV(s[n]), a.m_localPoint.x = .5 * (x.x + y.x), a.m_localPoint.y = .5 * (x.y + y.y), a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.key = 0, void 0;
						var A = (l - x.x) * (y.x - x.x) + (m - x.y) * (y.y - x.y),
							B = (l - y.x) * (x.x - y.x) + (m - y.y) * (x.y - y.y);
						if (0 >= A) {
							if ((l - x.x) * (l - x.x) + (m - x.y) * (m - x.y) > p * p) return;
							a.m_pointCount = 1, a.m_type = z.e_faceA, a.m_localPlaneNormal.x = l - x.x, a.m_localPlaneNormal.y = m - x.y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.SetV(x), a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.key = 0
						} else if (0 >= B) {
							if ((l - y.x) * (l - y.x) + (m - y.y) * (m - y.y) > p * p) return;
							a.m_pointCount = 1, a.m_type = z.e_faceA, a.m_localPlaneNormal.x = l - y.x, a.m_localPlaneNormal.y = m - y.y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.SetV(y), a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.key = 0
						} else {
							var C = .5 * (x.x + y.x),
								D = .5 * (x.y + y.y);
							if (o = (l - C) * s[v].x + (m - D) * s[v].y, o > p) return;
							a.m_pointCount = 1, a.m_type = z.e_faceA, a.m_localPlaneNormal.x = s[v].x, a.m_localPlaneNormal.y = s[v].y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.Set(C, D), a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.key = 0
						}
					}, o.TestOverlap = function(a, b) {
						var c = b.lowerBound,
							d = a.upperBound,
							e = c.x - d.x,
							f = c.y - d.y;
						c = a.lowerBound, d = b.upperBound;
						var g = c.x - d.x,
							h = c.y - d.y;
						return e > 0 || f > 0 ? !1 : g > 0 || h > 0 ? !1 : !0
					}, a.postDefs.push(function() {
						a.Collision.b2Collision.s_incidentEdge = o.MakeClipPointVector(), a.Collision.b2Collision.s_clipPoints1 = o.MakeClipPointVector(), a.Collision.b2Collision.s_clipPoints2 = o.MakeClipPointVector(), a.Collision.b2Collision.s_edgeAO = new d(1), a.Collision.b2Collision.s_edgeBO = new d(1), a.Collision.b2Collision.s_localTangent = new k, a.Collision.b2Collision.s_localNormal = new k, a.Collision.b2Collision.s_planePoint = new k, a.Collision.b2Collision.s_normal = new k, a.Collision.b2Collision.s_tangent = new k, a.Collision.b2Collision.s_tangent2 = new k, a.Collision.b2Collision.s_v11 = new k, a.Collision.b2Collision.s_v12 = new k, a.Collision.b2Collision.b2CollidePolyTempVec = new k, a.Collision.b2Collision.b2_nullFeature = 255
					}), p.b2ContactID = function() {
						this.features = new N
					}, p.prototype.b2ContactID = function() {
						this.features._m_id = this
					}, p.prototype.Set = function(a) {
						this.key = a._key
					}, p.prototype.Copy = function() {
						var a = new p;
						return a.key = this.key, a
					}, Object.defineProperty(p.prototype, "key", {
						enumerable: !1,
						configurable: !0,
						get: function() {
							return this._key
						}
					}), Object.defineProperty(p.prototype, "key", {
						enumerable: !1,
						configurable: !0,
						set: function(a) {
							void 0 === a && (a = 0), this._key = a, this.features._referenceEdge = 255 & this._key, this.features._incidentEdge = (65280 & this._key) >> 8 & 255, this.features._incidentVertex = (16711680 & this._key) >> 16 & 255, this.features._flip = (4278190080 & this._key) >> 24 & 255
						}
					}), q.b2ContactPoint = function() {
						this.position = new k, this.velocity = new k, this.normal = new k, this.id = new p
					}, r.b2Distance = function() {}, r.Distance = function(a, b, c) {
						++r.b2_gjkCalls;
						var d = c.proxyA,
							e = c.proxyB,
							f = c.transformA,
							i = c.transformB,
							j = r.s_simplex;
						j.ReadCache(b, d, f, e, i);
						for (var l, m = j.m_vertices, n = 20, o = r.s_saveA, p = r.s_saveB, q = 0, s = j.GetClosestPoint(), t = s.LengthSquared(), u = t, v = 0, w = 0; n > w;) {
							for (q = j.m_count, v = 0; q > v; v++) o[v] = m[v].indexA, p[v] = m[v].indexB;
							switch (j.m_count) {
								case 1:
									break;
								case 2:
									j.Solve2();
									break;
								case 3:
									j.Solve3();
									break;
								default:
									g.b2Assert(!1)
							}
							if (3 == j.m_count) break;
							l = j.GetClosestPoint(), u = l.LengthSquared(), t = u;
							var x = j.GetSearchDirection();
							if (x.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) break;
							var y = m[j.m_count];
							y.indexA = d.GetSupport(h.MulTMV(f.R, x.GetNegative())), y.wA = h.MulX(f, d.GetVertex(y.indexA)), y.indexB = e.GetSupport(h.MulTMV(i.R, x)), y.wB = h.MulX(i, e.GetVertex(y.indexB)), y.w = h.SubtractVV(y.wB, y.wA), ++w, ++r.b2_gjkIters;
							var z = !1;
							for (v = 0; q > v; v++)
								if (y.indexA == o[v] && y.indexB == p[v]) {
									z = !0;
									break
								} if (z) break;
							++j.m_count
						}
						if (r.b2_gjkMaxIters = h.Max(r.b2_gjkMaxIters, w), j.GetWitnessPoints(a.pointA, a.pointB), a.distance = h.SubtractVV(a.pointA, a.pointB).Length(), a.iterations = w, j.WriteCache(b), c.useRadii) {
							var A = d.m_radius,
								B = e.m_radius;
							if (a.distance > A + B && a.distance > Number.MIN_VALUE) {
								a.distance -= A + B;
								var C = h.SubtractVV(a.pointB, a.pointA);
								C.Normalize(), a.pointA.x += A * C.x, a.pointA.y += A * C.y, a.pointB.x -= B * C.x, a.pointB.y -= B * C.y
							} else l = new k, l.x = .5 * (a.pointA.x + a.pointB.x), l.y = .5 * (a.pointA.y + a.pointB.y), a.pointA.x = a.pointB.x = l.x, a.pointA.y = a.pointB.y = l.y, a.distance = 0
						}
					}, a.postDefs.push(function() {
						a.Collision.b2Distance.s_simplex = new G, a.Collision.b2Distance.s_saveA = new d(3), a.Collision.b2Distance.s_saveB = new d(3)
					}), s.b2DistanceInput = function() {}, t.b2DistanceOutput = function() {
						this.pointA = new k, this.pointB = new k
					}, u.b2DistanceProxy = function() {}, u.prototype.Set = function(a) {
						switch (a.GetType()) {
							case f.e_circleShape:
								var d = a instanceof b ? a : null;
								this.m_vertices = new c(1, !0), this.m_vertices[0] = d.m_p, this.m_count = 1, this.m_radius = d.m_radius;
								break;
							case f.e_polygonShape:
								var h = a instanceof e ? a : null;
								this.m_vertices = h.m_vertices, this.m_count = h.m_vertexCount, this.m_radius = h.m_radius;
								break;
							default:
								g.b2Assert(!1)
						}
					}, u.prototype.GetSupport = function(a) {
						for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_count; ++d) {
							var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
							e > c && (b = d, c = e)
						}
						return b
					}, u.prototype.GetSupportVertex = function(a) {
						for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_count; ++d) {
							var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
							e > c && (b = d, c = e)
						}
						return this.m_vertices[b]
					}, u.prototype.GetVertexCount = function() {
						return this.m_count
					}, u.prototype.GetVertex = function(a) {
						return void 0 === a && (a = 0), g.b2Assert(a >= 0 && a < this.m_count), this.m_vertices[a]
					}, v.b2DynamicTree = function() {}, v.prototype.b2DynamicTree = function() {
						this.m_root = null, this.m_freeList = null, this.m_path = 0, this.m_insertionCount = 0
					}, v.prototype.CreateProxy = function(a, b) {
						var c = this.AllocateNode(),
							d = g.b2_aabbExtension,
							e = g.b2_aabbExtension;
						return c.aabb.lowerBound.x = a.lowerBound.x - d, c.aabb.lowerBound.y = a.lowerBound.y - e, c.aabb.upperBound.x = a.upperBound.x + d, c.aabb.upperBound.y = a.upperBound.y + e, c.userData = b, this.InsertLeaf(c), c
					}, v.prototype.DestroyProxy = function(a) {
						this.RemoveLeaf(a), this.FreeNode(a)
					}, v.prototype.MoveProxy = function(a, b, c) {
						if (g.b2Assert(a.IsLeaf()), a.aabb.Contains(b)) return !1;
						this.RemoveLeaf(a);
						var d = g.b2_aabbExtension + g.b2_aabbMultiplier * (c.x > 0 ? c.x : -c.x),
							e = g.b2_aabbExtension + g.b2_aabbMultiplier * (c.y > 0 ? c.y : -c.y);
						return a.aabb.lowerBound.x = b.lowerBound.x - d, a.aabb.lowerBound.y = b.lowerBound.y - e, a.aabb.upperBound.x = b.upperBound.x + d, a.aabb.upperBound.y = b.upperBound.y + e, this.InsertLeaf(a), !0
					}, v.prototype.Rebalance = function(a) {
						if (void 0 === a && (a = 0), null != this.m_root)
							for (var b = 0; a > b; b++) {
								for (var c = this.m_root, d = 0; 0 == c.IsLeaf();) c = this.m_path >> d & 1 ? c.child2 : c.child1, d = d + 1 & 31;
								++this.m_path, this.RemoveLeaf(c), this.InsertLeaf(c)
							}
					}, v.prototype.GetFatAABB = function(a) {
						return a.aabb
					}, v.prototype.GetUserData = function(a) {
						return a.userData
					}, v.prototype.Query = function(a, b) {
						if (null != this.m_root) {
							var d = new c,
								e = 0;
							for (d[e++] = this.m_root; e > 0;) {
								var f = d[--e];
								if (f.aabb.TestOverlap(b))
									if (f.IsLeaf()) {
										var g = a(f);
										if (!g) return
									} else d[e++] = f.child1, d[e++] = f.child2
							}
						}
					}, v.prototype.RayCast = function(a, b) {
						if (null != this.m_root) {
							var d = b.p1,
								e = b.p2,
								f = h.SubtractVV(d, e);
							f.Normalize();
							var g = h.CrossFV(1, f),
								i = h.AbsV(g),
								j = b.maxFraction,
								k = new l,
								m = 0,
								n = 0;
							m = d.x + j * (e.x - d.x), n = d.y + j * (e.y - d.y), k.lowerBound.x = Math.min(d.x, m), k.lowerBound.y = Math.min(d.y, n), k.upperBound.x = Math.max(d.x, m), k.upperBound.y = Math.max(d.y, n);
							var o = new c,
								p = 0;
							for (o[p++] = this.m_root; p > 0;) {
								var q = o[--p];
								if (0 != q.aabb.TestOverlap(k)) {
									var r = q.aabb.GetCenter(),
										s = q.aabb.GetExtents(),
										t = Math.abs(g.x * (d.x - r.x) + g.y * (d.y - r.y)) - i.x * s.x - i.y * s.y;
									if (!(t > 0))
										if (q.IsLeaf()) {
											var u = new C;
											if (u.p1 = b.p1, u.p2 = b.p2, u.maxFraction = b.maxFraction, j = a(u, q), 0 == j) return;
											j > 0 && (m = d.x + j * (e.x - d.x), n = d.y + j * (e.y - d.y), k.lowerBound.x = Math.min(d.x, m), k.lowerBound.y = Math.min(d.y, n), k.upperBound.x = Math.max(d.x, m), k.upperBound.y = Math.max(d.y, n))
										} else o[p++] = q.child1, o[p++] = q.child2
								}
							}
						}
					}, v.prototype.AllocateNode = function() {
						if (this.m_freeList) {
							var a = this.m_freeList;
							return this.m_freeList = a.parent, a.parent = null, a.child1 = null, a.child2 = null, a
						}
						return new x
					}, v.prototype.FreeNode = function(a) {
						a.parent = this.m_freeList, this.m_freeList = a
					}, v.prototype.InsertLeaf = function(a) {
						if (++this.m_insertionCount, null == this.m_root) return this.m_root = a, this.m_root.parent = null, void 0;
						var b = a.aabb.GetCenter(),
							c = this.m_root;
						if (0 == c.IsLeaf())
							do {
								var d = c.child1,
									e = c.child2,
									f = Math.abs((d.aabb.lowerBound.x + d.aabb.upperBound.x) / 2 - b.x) + Math.abs((d.aabb.lowerBound.y + d.aabb.upperBound.y) / 2 - b.y),
									g = Math.abs((e.aabb.lowerBound.x + e.aabb.upperBound.x) / 2 - b.x) + Math.abs((e.aabb.lowerBound.y + e.aabb.upperBound.y) / 2 - b.y);
								c = g > f ? d : e
							} while (0 == c.IsLeaf());
						var h = c.parent,
							i = this.AllocateNode();
						if (i.parent = h, i.userData = null, i.aabb.Combine(a.aabb, c.aabb), h) {
							c.parent.child1 == c ? h.child1 = i : h.child2 = i, i.child1 = c, i.child2 = a, c.parent = i, a.parent = i;
							do {
								if (h.aabb.Contains(i.aabb)) break;
								h.aabb.Combine(h.child1.aabb, h.child2.aabb), i = h, h = h.parent
							} while (h)
						} else i.child1 = c, i.child2 = a, c.parent = i, a.parent = i, this.m_root = i
					}, v.prototype.RemoveLeaf = function(a) {
						if (a == this.m_root) return this.m_root = null, void 0;
						var b, c = a.parent,
							d = c.parent;
						if (b = c.child1 == a ? c.child2 : c.child1, d)
							for (d.child1 == c ? d.child1 = b : d.child2 = b, b.parent = d, this.FreeNode(c); d;) {
								var e = d.aabb;
								if (d.aabb = l.Combine(d.child1.aabb, d.child2.aabb), e.Contains(d.aabb)) break;
								d = d.parent
							} else this.m_root = b, b.parent = null, this.FreeNode(c)
					}, w.b2DynamicTreeBroadPhase = function() {
						this.m_tree = new v, this.m_moveBuffer = new c, this.m_pairBuffer = new c, this.m_pairCount = 0
					}, w.prototype.CreateProxy = function(a, b) {
						var c = this.m_tree.CreateProxy(a, b);
						return ++this.m_proxyCount, this.BufferMove(c), c
					}, w.prototype.DestroyProxy = function(a) {
						this.UnBufferMove(a), --this.m_proxyCount, this.m_tree.DestroyProxy(a)
					}, w.prototype.MoveProxy = function(a, b, c) {
						var d = this.m_tree.MoveProxy(a, b, c);
						d && this.BufferMove(a)
					}, w.prototype.TestOverlap = function(a, b) {
						var c = this.m_tree.GetFatAABB(a),
							d = this.m_tree.GetFatAABB(b);
						return c.TestOverlap(d)
					}, w.prototype.GetUserData = function(a) {
						return this.m_tree.GetUserData(a)
					}, w.prototype.GetFatAABB = function(a) {
						return this.m_tree.GetFatAABB(a)
					}, w.prototype.GetProxyCount = function() {
						return this.m_proxyCount
					}, w.prototype.UpdatePairs = function(a) {
						function b(a) {
							if (a == d) return !0;
							c.m_pairCount == c.m_pairBuffer.length && (c.m_pairBuffer[c.m_pairCount] = new y);
							var b = c.m_pairBuffer[c.m_pairCount];
							return b.proxyA = d > a ? a : d, b.proxyB = a >= d ? a : d, ++c.m_pairCount, !0
						}
						var c = this;
						c.m_pairCount = 0;
						var d, e = 0;
						for (e = 0; e < c.m_moveBuffer.length; ++e) {
							d = c.m_moveBuffer[e];
							var f = c.m_tree.GetFatAABB(d);
							c.m_tree.Query(b, f)
						}
						c.m_moveBuffer.length = 0;
						for (var e = 0; e < c.m_pairCount;) {
							var g = c.m_pairBuffer[e],
								h = c.m_tree.GetUserData(g.proxyA),
								i = c.m_tree.GetUserData(g.proxyB);
							for (a(h, i), ++e; e < c.m_pairCount;) {
								var j = c.m_pairBuffer[e];
								if (j.proxyA != g.proxyA || j.proxyB != g.proxyB) break;
								++e
							}
						}
					}, w.prototype.Query = function(a, b) {
						this.m_tree.Query(a, b)
					}, w.prototype.RayCast = function(a, b) {
						this.m_tree.RayCast(a, b)
					}, w.prototype.Validate = function() {}, w.prototype.Rebalance = function(a) {
						void 0 === a && (a = 0), this.m_tree.Rebalance(a)
					}, w.prototype.BufferMove = function(a) {
						this.m_moveBuffer[this.m_moveBuffer.length] = a
					}, w.prototype.UnBufferMove = function(a) {
						var b = parseInt(this.m_moveBuffer.indexOf(a));
						this.m_moveBuffer.splice(b, 1)
					}, w.prototype.ComparePairs = function() {
						return 0
					}, w.__implements = {}, w.__implements[O] = !0, x.b2DynamicTreeNode = function() {
						this.aabb = new l
					}, x.prototype.IsLeaf = function() {
						return null == this.child1
					}, y.b2DynamicTreePair = function() {}, z.b2Manifold = function() {
						this.m_pointCount = 0
					}, z.prototype.b2Manifold = function() {
						this.m_points = new c(g.b2_maxManifoldPoints);
						for (var a = 0; a < g.b2_maxManifoldPoints; a++) this.m_points[a] = new A;
						this.m_localPlaneNormal = new k, this.m_localPoint = new k
					}, z.prototype.Reset = function() {
						for (var a = 0; a < g.b2_maxManifoldPoints; a++)(this.m_points[a] instanceof A ? this.m_points[a] : null).Reset();
						this.m_localPlaneNormal.SetZero(), this.m_localPoint.SetZero(), this.m_type = 0, this.m_pointCount = 0
					}, z.prototype.Set = function(a) {
						this.m_pointCount = a.m_pointCount;
						for (var b = 0; b < g.b2_maxManifoldPoints; b++)(this.m_points[b] instanceof A ? this.m_points[b] : null).Set(a.m_points[b]);
						this.m_localPlaneNormal.SetV(a.m_localPlaneNormal), this.m_localPoint.SetV(a.m_localPoint), this.m_type = a.m_type
					}, z.prototype.Copy = function() {
						var a = new z;
						return a.Set(this), a
					}, a.postDefs.push(function() {
						a.Collision.b2Manifold.e_circles = 1, a.Collision.b2Manifold.e_faceA = 2, a.Collision.b2Manifold.e_faceB = 4
					}), A.b2ManifoldPoint = function() {
						this.m_localPoint = new k, this.m_id = new p
					}, A.prototype.b2ManifoldPoint = function() {
						this.Reset()
					}, A.prototype.Reset = function() {
						this.m_localPoint.SetZero(), this.m_normalImpulse = 0, this.m_tangentImpulse = 0, this.m_id.key = 0
					}, A.prototype.Set = function(a) {
						this.m_localPoint.SetV(a.m_localPoint), this.m_normalImpulse = a.m_normalImpulse, this.m_tangentImpulse = a.m_tangentImpulse, this.m_id.Set(a.m_id)
					}, B.b2Point = function() {
						this.p = new k
					}, B.prototype.Support = function(a, b, c) {
						return void 0 === b && (b = 0), void 0 === c && (c = 0), this.p
					}, B.prototype.GetFirstVertex = function() {
						return this.p
					}, C.b2RayCastInput = function() {
						this.p1 = new k, this.p2 = new k
					}, C.prototype.b2RayCastInput = function(a, b, c) {
						void 0 === a && (a = null), void 0 === b && (b = null), void 0 === c && (c = 1), a && this.p1.SetV(a), b && this.p2.SetV(b), this.maxFraction = c
					}, D.b2RayCastOutput = function() {
						this.normal = new k
					}, E.b2Segment = function() {
						this.p1 = new k, this.p2 = new k
					}, E.prototype.TestSegment = function(a, b, c, d) {
						void 0 === d && (d = 0);
						var e = c.p1,
							f = c.p2.x - e.x,
							g = c.p2.y - e.y,
							h = this.p2.x - this.p1.x,
							i = this.p2.y - this.p1.y,
							j = i,
							k = -h,
							l = 100 * Number.MIN_VALUE,
							m = -(f * j + g * k);
						if (m > l) {
							var n = e.x - this.p1.x,
								o = e.y - this.p1.y,
								p = n * j + o * k;
							if (p >= 0 && d * m >= p) {
								var q = -f * o + g * n;
								if (q >= -l * m && m * (1 + l) >= q) {
									p /= m;
									var r = Math.sqrt(j * j + k * k);
									return j /= r, k /= r, a[0] = p, b.Set(j, k), !0
								}
							}
						}
						return !1
					}, E.prototype.Extend = function(a) {
						this.ExtendForward(a), this.ExtendBackward(a)
					}, E.prototype.ExtendForward = function(a) {
						var b = this.p2.x - this.p1.x,
							c = this.p2.y - this.p1.y,
							d = Math.min(b > 0 ? (a.upperBound.x - this.p1.x) / b : 0 > b ? (a.lowerBound.x - this.p1.x) / b : Number.POSITIVE_INFINITY, c > 0 ? (a.upperBound.y - this.p1.y) / c : 0 > c ? (a.lowerBound.y - this.p1.y) / c : Number.POSITIVE_INFINITY);
						this.p2.x = this.p1.x + b * d, this.p2.y = this.p1.y + c * d
					}, E.prototype.ExtendBackward = function(a) {
						var b = -this.p2.x + this.p1.x,
							c = -this.p2.y + this.p1.y,
							d = Math.min(b > 0 ? (a.upperBound.x - this.p2.x) / b : 0 > b ? (a.lowerBound.x - this.p2.x) / b : Number.POSITIVE_INFINITY, c > 0 ? (a.upperBound.y - this.p2.y) / c : 0 > c ? (a.lowerBound.y - this.p2.y) / c : Number.POSITIVE_INFINITY);
						this.p1.x = this.p2.x + b * d, this.p1.y = this.p2.y + c * d
					}, F.b2SeparationFunction = function() {
						this.m_localPoint = new k, this.m_axis = new k
					}, F.prototype.Initialize = function(a, b, c, d, e) {
						this.m_proxyA = b, this.m_proxyB = d;
						var f = parseInt(a.count);
						g.b2Assert(f > 0 && 3 > f);
						var i, j, l, m, n, o, p, q, r = 0,
							s = 0,
							t = 0,
							u = 0,
							v = 0,
							w = 0,
							x = 0,
							y = 0;
						if (1 == f) this.m_type = F.e_points, i = this.m_proxyA.GetVertex(a.indexA[0]), m = this.m_proxyB.GetVertex(a.indexB[0]), q = i, p = c.R, r = c.position.x + (p.col1.x * q.x + p.col2.x * q.y), s = c.position.y + (p.col1.y * q.x + p.col2.y * q.y), q = m, p = e.R, t = e.position.x + (p.col1.x * q.x + p.col2.x * q.y), u = e.position.y + (p.col1.y * q.x + p.col2.y * q.y), this.m_axis.x = t - r, this.m_axis.y = u - s, this.m_axis.Normalize();
						else if (a.indexB[0] == a.indexB[1]) this.m_type = F.e_faceA, j = this.m_proxyA.GetVertex(a.indexA[0]), l = this.m_proxyA.GetVertex(a.indexA[1]), m = this.m_proxyB.GetVertex(a.indexB[0]), this.m_localPoint.x = .5 * (j.x + l.x), this.m_localPoint.y = .5 * (j.y + l.y), this.m_axis = h.CrossVF(h.SubtractVV(l, j), 1), this.m_axis.Normalize(), q = this.m_axis, p = c.R, v = p.col1.x * q.x + p.col2.x * q.y, w = p.col1.y * q.x + p.col2.y * q.y, q = this.m_localPoint, p = c.R, r = c.position.x + (p.col1.x * q.x + p.col2.x * q.y), s = c.position.y + (p.col1.y * q.x + p.col2.y * q.y), q = m, p = e.R, t = e.position.x + (p.col1.x * q.x + p.col2.x * q.y), u = e.position.y + (p.col1.y * q.x + p.col2.y * q.y), x = (t - r) * v + (u - s) * w, 0 > x && this.m_axis.NegativeSelf();
						else if (a.indexA[0] == a.indexA[0]) this.m_type = F.e_faceB, n = this.m_proxyB.GetVertex(a.indexB[0]), o = this.m_proxyB.GetVertex(a.indexB[1]), i = this.m_proxyA.GetVertex(a.indexA[0]), this.m_localPoint.x = .5 * (n.x + o.x), this.m_localPoint.y = .5 * (n.y + o.y), this.m_axis = h.CrossVF(h.SubtractVV(o, n), 1), this.m_axis.Normalize(), q = this.m_axis, p = e.R, v = p.col1.x * q.x + p.col2.x * q.y, w = p.col1.y * q.x + p.col2.y * q.y, q = this.m_localPoint, p = e.R, t = e.position.x + (p.col1.x * q.x + p.col2.x * q.y), u = e.position.y + (p.col1.y * q.x + p.col2.y * q.y), q = i, p = c.R, r = c.position.x + (p.col1.x * q.x + p.col2.x * q.y), s = c.position.y + (p.col1.y * q.x + p.col2.y * q.y), x = (r - t) * v + (s - u) * w, 0 > x && this.m_axis.NegativeSelf();
						else {
							j = this.m_proxyA.GetVertex(a.indexA[0]), l = this.m_proxyA.GetVertex(a.indexA[1]), n = this.m_proxyB.GetVertex(a.indexB[0]), o = this.m_proxyB.GetVertex(a.indexB[1]);
							var z = (h.MulX(c, i), h.MulMV(c.R, h.SubtractVV(l, j))),
								A = (h.MulX(e, m), h.MulMV(e.R, h.SubtractVV(o, n))),
								B = z.x * z.x + z.y * z.y,
								C = A.x * A.x + A.y * A.y,
								D = h.SubtractVV(A, z),
								E = z.x * D.x + z.y * D.y,
								G = A.x * D.x + A.y * D.y,
								H = z.x * A.x + z.y * A.y,
								I = B * C - H * H;
							x = 0, 0 != I && (x = h.Clamp((H * G - E * C) / I, 0, 1));
							var J = (H * x + G) / C;
							0 > J && (J = 0, x = h.Clamp((H - E) / B, 0, 1)), i = new k, i.x = j.x + x * (l.x - j.x), i.y = j.y + x * (l.y - j.y), m = new k, m.x = n.x + x * (o.x - n.x), m.y = n.y + x * (o.y - n.y), 0 == x || 1 == x ? (this.m_type = F.e_faceB, this.m_axis = h.CrossVF(h.SubtractVV(o, n), 1), this.m_axis.Normalize(), this.m_localPoint = m, q = this.m_axis, p = e.R, v = p.col1.x * q.x + p.col2.x * q.y, w = p.col1.y * q.x + p.col2.y * q.y, q = this.m_localPoint, p = e.R, t = e.position.x + (p.col1.x * q.x + p.col2.x * q.y), u = e.position.y + (p.col1.y * q.x + p.col2.y * q.y), q = i, p = c.R, r = c.position.x + (p.col1.x * q.x + p.col2.x * q.y), s = c.position.y + (p.col1.y * q.x + p.col2.y * q.y), y = (r - t) * v + (s - u) * w, 0 > x && this.m_axis.NegativeSelf()) : (this.m_type = F.e_faceA, this.m_axis = h.CrossVF(h.SubtractVV(l, j), 1), this.m_localPoint = i, q = this.m_axis, p = c.R, v = p.col1.x * q.x + p.col2.x * q.y, w = p.col1.y * q.x + p.col2.y * q.y, q = this.m_localPoint, p = c.R, r = c.position.x + (p.col1.x * q.x + p.col2.x * q.y), s = c.position.y + (p.col1.y * q.x + p.col2.y * q.y), q = m, p = e.R, t = e.position.x + (p.col1.x * q.x + p.col2.x * q.y), u = e.position.y + (p.col1.y * q.x + p.col2.y * q.y), y = (t - r) * v + (u - s) * w, 0 > x && this.m_axis.NegativeSelf())
						}
					}, F.prototype.Evaluate = function(a, b) {
						var c, d, e, f, i, j, k, l = 0;
						switch (this.m_type) {
							case F.e_points:
								return c = h.MulTMV(a.R, this.m_axis), d = h.MulTMV(b.R, this.m_axis.GetNegative()), e = this.m_proxyA.GetSupportVertex(c), f = this.m_proxyB.GetSupportVertex(d), i = h.MulX(a, e), j = h.MulX(b, f), l = (j.x - i.x) * this.m_axis.x + (j.y - i.y) * this.m_axis.y;
							case F.e_faceA:
								return k = h.MulMV(a.R, this.m_axis), i = h.MulX(a, this.m_localPoint), d = h.MulTMV(b.R, k.GetNegative()), f = this.m_proxyB.GetSupportVertex(d), j = h.MulX(b, f), l = (j.x - i.x) * k.x + (j.y - i.y) * k.y;
							case F.e_faceB:
								return k = h.MulMV(b.R, this.m_axis), j = h.MulX(b, this.m_localPoint), c = h.MulTMV(a.R, k.GetNegative()), e = this.m_proxyA.GetSupportVertex(c), i = h.MulX(a, e), l = (i.x - j.x) * k.x + (i.y - j.y) * k.y;
							default:
								return g.b2Assert(!1), 0
						}
					}, a.postDefs.push(function() {
						a.Collision.b2SeparationFunction.e_points = 1, a.Collision.b2SeparationFunction.e_faceA = 2, a.Collision.b2SeparationFunction.e_faceB = 4
					}), G.b2Simplex = function() {
						this.m_v1 = new I, this.m_v2 = new I, this.m_v3 = new I, this.m_vertices = new c(3)
					}, G.prototype.b2Simplex = function() {
						this.m_vertices[0] = this.m_v1, this.m_vertices[1] = this.m_v2, this.m_vertices[2] = this.m_v3
					}, G.prototype.ReadCache = function(a, b, c, d, e) {
						g.b2Assert(0 <= a.count && a.count <= 3);
						var f, i;
						this.m_count = a.count;
						for (var j = this.m_vertices, k = 0; k < this.m_count; k++) {
							var l = j[k];
							l.indexA = a.indexA[k], l.indexB = a.indexB[k], f = b.GetVertex(l.indexA), i = d.GetVertex(l.indexB), l.wA = h.MulX(c, f), l.wB = h.MulX(e, i), l.w = h.SubtractVV(l.wB, l.wA), l.a = 0
						}
						if (this.m_count > 1) {
							var m = a.metric,
								n = this.GetMetric();
							(.5 * m > n || n > 2 * m || n < Number.MIN_VALUE) && (this.m_count = 0)
						}
						0 == this.m_count && (l = j[0], l.indexA = 0, l.indexB = 0, f = b.GetVertex(0), i = d.GetVertex(0), l.wA = h.MulX(c, f), l.wB = h.MulX(e, i), l.w = h.SubtractVV(l.wB, l.wA), this.m_count = 1)
					}, G.prototype.WriteCache = function(b) {
						b.metric = this.GetMetric(), b.count = a.parseUInt(this.m_count);
						for (var c = this.m_vertices, d = 0; d < this.m_count; d++) b.indexA[d] = a.parseUInt(c[d].indexA), b.indexB[d] = a.parseUInt(c[d].indexB)
					}, G.prototype.GetSearchDirection = function() {
						switch (this.m_count) {
							case 1:
								return this.m_v1.w.GetNegative();
							case 2:
								var a = h.SubtractVV(this.m_v2.w, this.m_v1.w),
									b = h.CrossVV(a, this.m_v1.w.GetNegative());
								return b > 0 ? h.CrossFV(1, a) : h.CrossVF(a, 1);
							default:
								return g.b2Assert(!1), new k
						}
					}, G.prototype.GetClosestPoint = function() {
						switch (this.m_count) {
							case 0:
								return g.b2Assert(!1), new k;
							case 1:
								return this.m_v1.w;
							case 2:
								return new k(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
							default:
								return g.b2Assert(!1), new k
						}
					}, G.prototype.GetWitnessPoints = function(a, b) {
						switch (this.m_count) {
							case 0:
								g.b2Assert(!1);
								break;
							case 1:
								a.SetV(this.m_v1.wA), b.SetV(this.m_v1.wB);
								break;
							case 2:
								a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, b.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, b.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
								break;
							case 3:
								b.x = a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, b.y = a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
								break;
							default:
								g.b2Assert(!1)
						}
					}, G.prototype.GetMetric = function() {
						switch (this.m_count) {
							case 0:
								return g.b2Assert(!1), 0;
							case 1:
								return 0;
							case 2:
								return h.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
							case 3:
								return h.CrossVV(h.SubtractVV(this.m_v2.w, this.m_v1.w), h.SubtractVV(this.m_v3.w, this.m_v1.w));
							default:
								return g.b2Assert(!1), 0
						}
					}, G.prototype.Solve2 = function() {
						var a = this.m_v1.w,
							b = this.m_v2.w,
							c = h.SubtractVV(b, a),
							d = -(a.x * c.x + a.y * c.y);
						if (0 >= d) return this.m_v1.a = 1, this.m_count = 1, void 0;
						var e = b.x * c.x + b.y * c.y;
						if (0 >= e) return this.m_v2.a = 1, this.m_count = 1, this.m_v1.Set(this.m_v2), void 0;
						var f = 1 / (e + d);
						this.m_v1.a = e * f, this.m_v2.a = d * f, this.m_count = 2
					}, G.prototype.Solve3 = function() {
						var a = this.m_v1.w,
							b = this.m_v2.w,
							c = this.m_v3.w,
							d = h.SubtractVV(b, a),
							e = h.Dot(a, d),
							f = h.Dot(b, d),
							g = f,
							i = -e,
							j = h.SubtractVV(c, a),
							k = h.Dot(a, j),
							l = h.Dot(c, j),
							m = l,
							n = -k,
							o = h.SubtractVV(c, b),
							p = h.Dot(b, o),
							q = h.Dot(c, o),
							r = q,
							s = -p,
							t = h.CrossVV(d, j),
							u = t * h.CrossVV(b, c),
							v = t * h.CrossVV(c, a),
							w = t * h.CrossVV(a, b);
						if (0 >= i && 0 >= n) return this.m_v1.a = 1, this.m_count = 1, void 0;
						if (g > 0 && i > 0 && 0 >= w) {
							var x = 1 / (g + i);
							return this.m_v1.a = g * x, this.m_v2.a = i * x, this.m_count = 2, void 0
						}
						if (m > 0 && n > 0 && 0 >= v) {
							var y = 1 / (m + n);
							return this.m_v1.a = m * y, this.m_v3.a = n * y, this.m_count = 2, this.m_v2.Set(this.m_v3), void 0
						}
						if (0 >= g && 0 >= s) return this.m_v2.a = 1, this.m_count = 1, this.m_v1.Set(this.m_v2), void 0;
						if (0 >= m && 0 >= r) return this.m_v3.a = 1, this.m_count = 1, this.m_v1.Set(this.m_v3), void 0;
						if (r > 0 && s > 0 && 0 >= u) {
							var z = 1 / (r + s);
							return this.m_v2.a = r * z, this.m_v3.a = s * z, this.m_count = 2, this.m_v1.Set(this.m_v3), void 0
						}
						var A = 1 / (u + v + w);
						this.m_v1.a = u * A, this.m_v2.a = v * A, this.m_v3.a = w * A, this.m_count = 3
					}, H.b2SimplexCache = function() {
						this.indexA = new d(3), this.indexB = new d(3)
					}, I.b2SimplexVertex = function() {}, I.prototype.Set = function(a) {
						this.wA.SetV(a.wA), this.wB.SetV(a.wB), this.w.SetV(a.w), this.a = a.a, this.indexA = a.indexA, this.indexB = a.indexB
					}, J.b2TimeOfImpact = function() {}, J.TimeOfImpact = function(a) {
						++J.b2_toiCalls;
						var b = a.proxyA,
							c = a.proxyB,
							d = a.sweepA,
							e = a.sweepB;
						g.b2Assert(d.t0 == e.t0), g.b2Assert(1 - d.t0 > Number.MIN_VALUE);
						var f = b.m_radius + c.m_radius,
							i = a.tolerance,
							j = 0,
							k = 1e3,
							l = 0,
							m = 0;
						for (J.s_cache.count = 0, J.s_distanceInput.useRadii = !1;;) {
							if (d.GetTransform(J.s_xfA, j), e.GetTransform(J.s_xfB, j), J.s_distanceInput.proxyA = b, J.s_distanceInput.proxyB = c, J.s_distanceInput.transformA = J.s_xfA, J.s_distanceInput.transformB = J.s_xfB, r.Distance(J.s_distanceOutput, J.s_cache, J.s_distanceInput), J.s_distanceOutput.distance <= 0) {
								j = 1;
								break
							}
							J.s_fcn.Initialize(J.s_cache, b, J.s_xfA, c, J.s_xfB);
							var n = J.s_fcn.Evaluate(J.s_xfA, J.s_xfB);
							if (0 >= n) {
								j = 1;
								break
							}
							if (0 == l && (m = n > f ? h.Max(f - i, .75 * f) : h.Max(n - i, .02 * f)), .5 * i > n - m) {
								if (0 == l) {
									j = 1;
									break
								}
								break
							}
							var o = j,
								p = j,
								q = 1,
								s = n;
							d.GetTransform(J.s_xfA, q), e.GetTransform(J.s_xfB, q);
							var t = J.s_fcn.Evaluate(J.s_xfA, J.s_xfB);
							if (t >= m) {
								j = 1;
								break
							}
							for (var u = 0;;) {
								var v = 0;
								v = 1 & u ? p + (m - s) * (q - p) / (t - s) : .5 * (p + q), d.GetTransform(J.s_xfA, v), e.GetTransform(J.s_xfB, v);
								var w = J.s_fcn.Evaluate(J.s_xfA, J.s_xfB);
								if (h.Abs(w - m) < .025 * i) {
									o = v;
									break
								}
								if (w > m ? (p = v, s = w) : (q = v, t = w), ++u, ++J.b2_toiRootIters, 50 == u) break
							}
							if (J.b2_toiMaxRootIters = h.Max(J.b2_toiMaxRootIters, u), o < (1 + 100 * Number.MIN_VALUE) * j) break;
							if (j = o, l++, ++J.b2_toiIters, l == k) break
						}
						return J.b2_toiMaxIters = h.Max(J.b2_toiMaxIters, l), j
					}, a.postDefs.push(function() {
						a.Collision.b2TimeOfImpact.b2_toiCalls = 0, a.Collision.b2TimeOfImpact.b2_toiIters = 0, a.Collision.b2TimeOfImpact.b2_toiMaxIters = 0, a.Collision.b2TimeOfImpact.b2_toiRootIters = 0, a.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0, a.Collision.b2TimeOfImpact.s_cache = new H, a.Collision.b2TimeOfImpact.s_distanceInput = new s, a.Collision.b2TimeOfImpact.s_xfA = new j, a.Collision.b2TimeOfImpact.s_xfB = new j, a.Collision.b2TimeOfImpact.s_fcn = new F, a.Collision.b2TimeOfImpact.s_distanceOutput = new t
					}), K.b2TOIInput = function() {
						this.proxyA = new u, this.proxyB = new u, this.sweepA = new i, this.sweepB = new i
					}, L.b2WorldManifold = function() {
						this.m_normal = new k
					}, L.prototype.b2WorldManifold = function() {
						this.m_points = new c(g.b2_maxManifoldPoints);
						for (var a = 0; a < g.b2_maxManifoldPoints; a++) this.m_points[a] = new k
					}, L.prototype.Initialize = function(a, b, c, d, e) {
						if (void 0 === c && (c = 0), void 0 === e && (e = 0), 0 != a.m_pointCount) {
							var f, g, h = 0,
								i = 0,
								j = 0,
								k = 0,
								l = 0,
								m = 0,
								n = 0;
							switch (a.m_type) {
								case z.e_circles:
									g = b.R, f = a.m_localPoint;
									var o = b.position.x + g.col1.x * f.x + g.col2.x * f.y,
										p = b.position.y + g.col1.y * f.x + g.col2.y * f.y;
									g = d.R, f = a.m_points[0].m_localPoint;
									var q = d.position.x + g.col1.x * f.x + g.col2.x * f.y,
										r = d.position.y + g.col1.y * f.x + g.col2.y * f.y,
										s = q - o,
										t = r - p,
										u = s * s + t * t;
									if (u > Number.MIN_VALUE * Number.MIN_VALUE) {
										var v = Math.sqrt(u);
										this.m_normal.x = s / v, this.m_normal.y = t / v
									} else this.m_normal.x = 1, this.m_normal.y = 0;
									var w = o + c * this.m_normal.x,
										x = p + c * this.m_normal.y,
										y = q - e * this.m_normal.x,
										A = r - e * this.m_normal.y;
									this.m_points[0].x = .5 * (w + y), this.m_points[0].y = .5 * (x + A);
									break;
								case z.e_faceA:
									for (g = b.R, f = a.m_localPlaneNormal, i = g.col1.x * f.x + g.col2.x * f.y, j = g.col1.y * f.x + g.col2.y * f.y, g = b.R, f = a.m_localPoint, k = b.position.x + g.col1.x * f.x + g.col2.x * f.y, l = b.position.y + g.col1.y * f.x + g.col2.y * f.y, this.m_normal.x = i, this.m_normal.y = j, h = 0; h < a.m_pointCount; h++) g = d.R, f = a.m_points[h].m_localPoint, m = d.position.x + g.col1.x * f.x + g.col2.x * f.y, n = d.position.y + g.col1.y * f.x + g.col2.y * f.y, this.m_points[h].x = m + .5 * (c - (m - k) * i - (n - l) * j - e) * i, this.m_points[h].y = n + .5 * (c - (m - k) * i - (n - l) * j - e) * j;
									break;
								case z.e_faceB:
									for (g = d.R, f = a.m_localPlaneNormal, i = g.col1.x * f.x + g.col2.x * f.y, j = g.col1.y * f.x + g.col2.y * f.y, g = d.R, f = a.m_localPoint, k = d.position.x + g.col1.x * f.x + g.col2.x * f.y, l = d.position.y + g.col1.y * f.x + g.col2.y * f.y, this.m_normal.x = -i, this.m_normal.y = -j, h = 0; h < a.m_pointCount; h++) g = b.R, f = a.m_points[h].m_localPoint, m = b.position.x + g.col1.x * f.x + g.col2.x * f.y, n = b.position.y + g.col1.y * f.x + g.col2.y * f.y, this.m_points[h].x = m + .5 * (e - (m - k) * i - (n - l) * j - c) * i, this.m_points[h].y = n + .5 * (e - (m - k) * i - (n - l) * j - c) * j
							}
						}
					}, M.ClipVertex = function() {
						this.v = new k, this.id = new p
					}, M.prototype.Set = function(a) {
						this.v.SetV(a.v), this.id.Set(a.id)
					}, N.Features = function() {}, Object.defineProperty(N.prototype, "referenceEdge", {
						enumerable: !1,
						configurable: !0,
						get: function() {
							return this._referenceEdge
						}
					}), Object.defineProperty(N.prototype, "referenceEdge", {
						enumerable: !1,
						configurable: !0,
						set: function(a) {
							void 0 === a && (a = 0), this._referenceEdge = a, this._m_id._key = 4294967040 & this._m_id._key | 255 & this._referenceEdge
						}
					}), Object.defineProperty(N.prototype, "incidentEdge", {
						enumerable: !1,
						configurable: !0,
						get: function() {
							return this._incidentEdge
						}
					}), Object.defineProperty(N.prototype, "incidentEdge", {
						enumerable: !1,
						configurable: !0,
						set: function(a) {
							void 0 === a && (a = 0), this._incidentEdge = a, this._m_id._key = 4294902015 & this._m_id._key | this._incidentEdge << 8 & 65280
						}
					}), Object.defineProperty(N.prototype, "incidentVertex", {
						enumerable: !1,
						configurable: !0,
						get: function() {
							return this._incidentVertex
						}
					}), Object.defineProperty(N.prototype, "incidentVertex", {
						enumerable: !1,
						configurable: !0,
						set: function(a) {
							void 0 === a && (a = 0), this._incidentVertex = a, this._m_id._key = 4278255615 & this._m_id._key | this._incidentVertex << 16 & 16711680
						}
					}), Object.defineProperty(N.prototype, "flip", {
						enumerable: !1,
						configurable: !0,
						get: function() {
							return this._flip
						}
					}), Object.defineProperty(N.prototype, "flip", {
						enumerable: !1,
						configurable: !0,
						set: function(a) {
							void 0 === a && (a = 0), this._flip = a, this._m_id._key = 16777215 & this._m_id._key | this._flip << 24 & 4278190080
						}
					})
				}(),
				function() {
					{
						var b = (a.Common.b2Color, a.Common.b2internal, a.Common.b2Settings),
							e = a.Collision.Shapes.b2CircleShape,
							f = a.Collision.Shapes.b2EdgeChainDef,
							g = a.Collision.Shapes.b2EdgeShape,
							h = a.Collision.Shapes.b2MassData,
							i = a.Collision.Shapes.b2PolygonShape,
							j = a.Collision.Shapes.b2Shape,
							k = a.Common.Math.b2Mat22,
							l = (a.Common.Math.b2Mat33, a.Common.Math.b2Math),
							m = (a.Common.Math.b2Sweep, a.Common.Math.b2Transform),
							n = a.Common.Math.b2Vec2,
							o = (a.Common.Math.b2Vec3, a.Dynamics.b2Body, a.Dynamics.b2BodyDef, a.Dynamics.b2ContactFilter, a.Dynamics.b2ContactImpulse, a.Dynamics.b2ContactListener, a.Dynamics.b2ContactManager, a.Dynamics.b2DebugDraw, a.Dynamics.b2DestructionListener, a.Dynamics.b2FilterData, a.Dynamics.b2Fixture, a.Dynamics.b2FixtureDef, a.Dynamics.b2Island, a.Dynamics.b2TimeStep, a.Dynamics.b2World, a.Collision.b2AABB, a.Collision.b2Bound, a.Collision.b2BoundValues, a.Collision.b2Collision, a.Collision.b2ContactID, a.Collision.b2ContactPoint, a.Collision.b2Distance),
							p = a.Collision.b2DistanceInput,
							q = a.Collision.b2DistanceOutput,
							r = a.Collision.b2DistanceProxy,
							s = (a.Collision.b2DynamicTree, a.Collision.b2DynamicTreeBroadPhase, a.Collision.b2DynamicTreeNode, a.Collision.b2DynamicTreePair, a.Collision.b2Manifold, a.Collision.b2ManifoldPoint, a.Collision.b2Point, a.Collision.b2RayCastInput, a.Collision.b2RayCastOutput, a.Collision.b2Segment, a.Collision.b2SeparationFunction, a.Collision.b2Simplex, a.Collision.b2SimplexCache);
						a.Collision.b2SimplexVertex, a.Collision.b2TimeOfImpact, a.Collision.b2TOIInput, a.Collision.b2WorldManifold, a.Collision.ClipVertex, a.Collision.Features, a.Collision.IBroadPhase
					}
					a.inherit(e, a.Collision.Shapes.b2Shape), e.prototype.__super = a.Collision.Shapes.b2Shape.prototype, e.b2CircleShape = function() {
						a.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.m_p = new n
					}, e.prototype.Copy = function() {
						var a = new e;
						return a.Set(this), a
					}, e.prototype.Set = function(b) {
						if (this.__super.Set.call(this, b), a.is(b, e)) {
							var c = b instanceof e ? b : null;
							this.m_p.SetV(c.m_p)
						}
					}, e.prototype.TestPoint = function(a, b) {
						var c = a.R,
							d = a.position.x + (c.col1.x * this.m_p.x + c.col2.x * this.m_p.y),
							e = a.position.y + (c.col1.y * this.m_p.x + c.col2.y * this.m_p.y);
						return d = b.x - d, e = b.y - e, d * d + e * e <= this.m_radius * this.m_radius
					}, e.prototype.RayCast = function(a, b, c) {
						var d = c.R,
							e = c.position.x + (d.col1.x * this.m_p.x + d.col2.x * this.m_p.y),
							f = c.position.y + (d.col1.y * this.m_p.x + d.col2.y * this.m_p.y),
							g = b.p1.x - e,
							h = b.p1.y - f,
							i = g * g + h * h - this.m_radius * this.m_radius,
							j = b.p2.x - b.p1.x,
							k = b.p2.y - b.p1.y,
							l = g * j + h * k,
							m = j * j + k * k,
							n = l * l - m * i;
						if (0 > n || m < Number.MIN_VALUE) return !1;
						var o = -(l + Math.sqrt(n));
						return o >= 0 && o <= b.maxFraction * m ? (o /= m, a.fraction = o, a.normal.x = g + o * j, a.normal.y = h + o * k, a.normal.Normalize(), !0) : !1
					}, e.prototype.ComputeAABB = function(a, b) {
						var c = b.R,
							d = b.position.x + (c.col1.x * this.m_p.x + c.col2.x * this.m_p.y),
							e = b.position.y + (c.col1.y * this.m_p.x + c.col2.y * this.m_p.y);
						a.lowerBound.Set(d - this.m_radius, e - this.m_radius), a.upperBound.Set(d + this.m_radius, e + this.m_radius)
					}, e.prototype.ComputeMass = function(a, c) {
						void 0 === c && (c = 0), a.mass = c * b.b2_pi * this.m_radius * this.m_radius, a.center.SetV(this.m_p), a.I = a.mass * (.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
					}, e.prototype.ComputeSubmergedArea = function(a, b, c, d) {
						void 0 === b && (b = 0);
						var e = l.MulX(c, this.m_p),
							f = -(l.Dot(a, e) - b);
						if (f < -this.m_radius + Number.MIN_VALUE) return 0;
						if (f > this.m_radius) return d.SetV(e), Math.PI * this.m_radius * this.m_radius;
						var g = this.m_radius * this.m_radius,
							h = f * f,
							i = g * (Math.asin(f / this.m_radius) + Math.PI / 2) + f * Math.sqrt(g - h),
							j = -2 / 3 * Math.pow(g - h, 1.5) / i;
						return d.x = e.x + a.x * j, d.y = e.y + a.y * j, i
					}, e.prototype.GetLocalPosition = function() {
						return this.m_p
					}, e.prototype.SetLocalPosition = function(a) {
						this.m_p.SetV(a)
					}, e.prototype.GetRadius = function() {
						return this.m_radius
					}, e.prototype.SetRadius = function(a) {
						void 0 === a && (a = 0), this.m_radius = a
					}, e.prototype.b2CircleShape = function(a) {
						void 0 === a && (a = 0), this.__super.b2Shape.call(this), this.m_type = j.e_circleShape, this.m_radius = a
					}, f.b2EdgeChainDef = function() {}, f.prototype.b2EdgeChainDef = function() {
						this.vertexCount = 0, this.isALoop = !0, this.vertices = []
					}, a.inherit(g, a.Collision.Shapes.b2Shape), g.prototype.__super = a.Collision.Shapes.b2Shape.prototype, g.b2EdgeShape = function() {
						a.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.s_supportVec = new n, this.m_v1 = new n, this.m_v2 = new n, this.m_coreV1 = new n, this.m_coreV2 = new n, this.m_normal = new n, this.m_direction = new n, this.m_cornerDir1 = new n, this.m_cornerDir2 = new n
					}, g.prototype.TestPoint = function() {
						return !1
					}, g.prototype.RayCast = function(a, b, c) {
						var d, e = b.p2.x - b.p1.x,
							f = b.p2.y - b.p1.y;
						d = c.R;
						var g = c.position.x + (d.col1.x * this.m_v1.x + d.col2.x * this.m_v1.y),
							h = c.position.y + (d.col1.y * this.m_v1.x + d.col2.y * this.m_v1.y),
							i = c.position.y + (d.col1.y * this.m_v2.x + d.col2.y * this.m_v2.y) - h,
							j = -(c.position.x + (d.col1.x * this.m_v2.x + d.col2.x * this.m_v2.y) - g),
							k = 100 * Number.MIN_VALUE,
							l = -(e * i + f * j);
						if (l > k) {
							var m = b.p1.x - g,
								n = b.p1.y - h,
								o = m * i + n * j;
							if (o >= 0 && o <= b.maxFraction * l) {
								var p = -e * n + f * m;
								if (p >= -k * l && l * (1 + k) >= p) {
									o /= l, a.fraction = o;
									var q = Math.sqrt(i * i + j * j);
									return a.normal.x = i / q, a.normal.y = j / q, !0
								}
							}
						}
						return !1
					}, g.prototype.ComputeAABB = function(a, b) {
						var c = b.R,
							d = b.position.x + (c.col1.x * this.m_v1.x + c.col2.x * this.m_v1.y),
							e = b.position.y + (c.col1.y * this.m_v1.x + c.col2.y * this.m_v1.y),
							f = b.position.x + (c.col1.x * this.m_v2.x + c.col2.x * this.m_v2.y),
							g = b.position.y + (c.col1.y * this.m_v2.x + c.col2.y * this.m_v2.y);
						f > d ? (a.lowerBound.x = d, a.upperBound.x = f) : (a.lowerBound.x = f, a.upperBound.x = d), g > e ? (a.lowerBound.y = e, a.upperBound.y = g) : (a.lowerBound.y = g, a.upperBound.y = e)
					}, g.prototype.ComputeMass = function(a, b) {
						void 0 === b && (b = 0), a.mass = 0, a.center.SetV(this.m_v1), a.I = 0
					}, g.prototype.ComputeSubmergedArea = function(a, b, c, d) {
						void 0 === b && (b = 0);
						var e = new n(a.x * b, a.y * b),
							f = l.MulX(c, this.m_v1),
							g = l.MulX(c, this.m_v2),
							h = l.Dot(a, f) - b,
							i = l.Dot(a, g) - b;
						if (h > 0) {
							if (i > 0) return 0;
							f.x = -i / (h - i) * f.x + h / (h - i) * g.x, f.y = -i / (h - i) * f.y + h / (h - i) * g.y
						} else i > 0 && (g.x = -i / (h - i) * f.x + h / (h - i) * g.x, g.y = -i / (h - i) * f.y + h / (h - i) * g.y);
						return d.x = (e.x + f.x + g.x) / 3, d.y = (e.y + f.y + g.y) / 3, .5 * ((f.x - e.x) * (g.y - e.y) - (f.y - e.y) * (g.x - e.x))
					}, g.prototype.GetLength = function() {
						return this.m_length
					}, g.prototype.GetVertex1 = function() {
						return this.m_v1
					}, g.prototype.GetVertex2 = function() {
						return this.m_v2
					}, g.prototype.GetCoreVertex1 = function() {
						return this.m_coreV1
					}, g.prototype.GetCoreVertex2 = function() {
						return this.m_coreV2
					}, g.prototype.GetNormalVector = function() {
						return this.m_normal
					}, g.prototype.GetDirectionVector = function() {
						return this.m_direction
					}, g.prototype.GetCorner1Vector = function() {
						return this.m_cornerDir1
					}, g.prototype.GetCorner2Vector = function() {
						return this.m_cornerDir2
					}, g.prototype.Corner1IsConvex = function() {
						return this.m_cornerConvex1
					}, g.prototype.Corner2IsConvex = function() {
						return this.m_cornerConvex2
					}, g.prototype.GetFirstVertex = function(a) {
						var b = a.R;
						return new n(a.position.x + (b.col1.x * this.m_coreV1.x + b.col2.x * this.m_coreV1.y), a.position.y + (b.col1.y * this.m_coreV1.x + b.col2.y * this.m_coreV1.y))
					}, g.prototype.GetNextEdge = function() {
						return this.m_nextEdge
					}, g.prototype.GetPrevEdge = function() {
						return this.m_prevEdge
					}, g.prototype.Support = function(a, b, c) {
						void 0 === b && (b = 0), void 0 === c && (c = 0);
						var d = a.R,
							e = a.position.x + (d.col1.x * this.m_coreV1.x + d.col2.x * this.m_coreV1.y),
							f = a.position.y + (d.col1.y * this.m_coreV1.x + d.col2.y * this.m_coreV1.y),
							g = a.position.x + (d.col1.x * this.m_coreV2.x + d.col2.x * this.m_coreV2.y),
							h = a.position.y + (d.col1.y * this.m_coreV2.x + d.col2.y * this.m_coreV2.y);
						return e * b + f * c > g * b + h * c ? (this.s_supportVec.x = e, this.s_supportVec.y = f) : (this.s_supportVec.x = g, this.s_supportVec.y = h), this.s_supportVec
					}, g.prototype.b2EdgeShape = function(a, c) {
						this.__super.b2Shape.call(this), this.m_type = j.e_edgeShape, this.m_prevEdge = null, this.m_nextEdge = null, this.m_v1 = a, this.m_v2 = c, this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y), this.m_length = this.m_direction.Normalize(), this.m_normal.Set(this.m_direction.y, -this.m_direction.x), this.m_coreV1.Set(-b.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -b.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y), this.m_coreV2.Set(-b.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -b.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y), this.m_cornerDir1 = this.m_normal, this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
					}, g.prototype.SetPrevEdge = function(a, b, c, d) {
						this.m_prevEdge = a, this.m_coreV1 = b, this.m_cornerDir1 = c, this.m_cornerConvex1 = d
					}, g.prototype.SetNextEdge = function(a, b, c, d) {
						this.m_nextEdge = a, this.m_coreV2 = b, this.m_cornerDir2 = c, this.m_cornerConvex2 = d
					}, h.b2MassData = function() {
						this.mass = 0, this.center = new n(0, 0), this.I = 0
					}, a.inherit(i, a.Collision.Shapes.b2Shape), i.prototype.__super = a.Collision.Shapes.b2Shape.prototype, i.b2PolygonShape = function() {
						a.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments)
					}, i.prototype.Copy = function() {
						var a = new i;
						return a.Set(this), a
					}, i.prototype.Set = function(b) {
						if (this.__super.Set.call(this, b), a.is(b, i)) {
							var c = b instanceof i ? b : null;
							this.m_centroid.SetV(c.m_centroid), this.m_vertexCount = c.m_vertexCount, this.Reserve(this.m_vertexCount);
							for (var d = 0; d < this.m_vertexCount; d++) this.m_vertices[d].SetV(c.m_vertices[d]), this.m_normals[d].SetV(c.m_normals[d])
						}
					}, i.prototype.SetAsArray = function(a, b) {
						void 0 === b && (b = 0);
						var d, e = new c,
							f = 0;
						for (f = 0; f < a.length; ++f) d = a[f], e.push(d);
						this.SetAsVector(e, b)
					}, i.AsArray = function(a, b) {
						void 0 === b && (b = 0);
						var c = new i;
						return c.SetAsArray(a, b), c
					}, i.prototype.SetAsVector = function(a, c) {
						void 0 === c && (c = 0), 0 == c && (c = a.length), b.b2Assert(c >= 2), this.m_vertexCount = c, this.Reserve(c);
						var d = 0;
						for (d = 0; d < this.m_vertexCount; d++) this.m_vertices[d].SetV(a[d]);
						for (d = 0; d < this.m_vertexCount; ++d) {
							var e = parseInt(d),
								f = parseInt(d + 1 < this.m_vertexCount ? d + 1 : 0),
								g = l.SubtractVV(this.m_vertices[f], this.m_vertices[e]);
							b.b2Assert(g.LengthSquared() > Number.MIN_VALUE), this.m_normals[d].SetV(l.CrossVF(g, 1)), this.m_normals[d].Normalize()
						}
						this.m_centroid = i.ComputeCentroid(this.m_vertices, this.m_vertexCount)
					}, i.AsVector = function(a, b) {
						void 0 === b && (b = 0);
						var c = new i;
						return c.SetAsVector(a, b), c
					}, i.prototype.SetAsBox = function(a, b) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-a, -b), this.m_vertices[1].Set(a, -b), this.m_vertices[2].Set(a, b), this.m_vertices[3].Set(-a, b), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid.SetZero()
					}, i.AsBox = function(a, b) {
						void 0 === a && (a = 0), void 0 === b && (b = 0);
						var c = new i;
						return c.SetAsBox(a, b), c
					}, i.prototype.SetAsOrientedBox = function(a, b, c, d) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = null), void 0 === d && (d = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-a, -b), this.m_vertices[1].Set(a, -b), this.m_vertices[2].Set(a, b), this.m_vertices[3].Set(-a, b), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid = c;
						var e = new m;
						e.position = c, e.R.Set(d);
						for (var f = 0; f < this.m_vertexCount; ++f) this.m_vertices[f] = l.MulX(e, this.m_vertices[f]), this.m_normals[f] = l.MulMV(e.R, this.m_normals[f])
					}, i.AsOrientedBox = function(a, b, c, d) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = null), void 0 === d && (d = 0);
						var e = new i;
						return e.SetAsOrientedBox(a, b, c, d), e
					}, i.prototype.SetAsEdge = function(a, b) {
						this.m_vertexCount = 2, this.Reserve(2), this.m_vertices[0].SetV(a), this.m_vertices[1].SetV(b), this.m_centroid.x = .5 * (a.x + b.x), this.m_centroid.y = .5 * (a.y + b.y), this.m_normals[0] = l.CrossVF(l.SubtractVV(b, a), 1), this.m_normals[0].Normalize(), this.m_normals[1].x = -this.m_normals[0].x, this.m_normals[1].y = -this.m_normals[0].y
					}, i.AsEdge = function(a, b) {
						var c = new i;
						return c.SetAsEdge(a, b), c
					}, i.prototype.TestPoint = function(a, b) {
						for (var c, d = a.R, e = b.x - a.position.x, f = b.y - a.position.y, g = e * d.col1.x + f * d.col1.y, h = e * d.col2.x + f * d.col2.y, i = 0; i < this.m_vertexCount; ++i) {
							c = this.m_vertices[i], e = g - c.x, f = h - c.y, c = this.m_normals[i];
							var j = c.x * e + c.y * f;
							if (j > 0) return !1
						}
						return !0
					}, i.prototype.RayCast = function(a, b, c) {
						var d, e, f = 0,
							g = b.maxFraction,
							h = 0,
							i = 0;
						h = b.p1.x - c.position.x, i = b.p1.y - c.position.y, d = c.R;
						var j = h * d.col1.x + i * d.col1.y,
							k = h * d.col2.x + i * d.col2.y;
						h = b.p2.x - c.position.x, i = b.p2.y - c.position.y, d = c.R;
						for (var l = h * d.col1.x + i * d.col1.y, m = h * d.col2.x + i * d.col2.y, n = l - j, o = m - k, p = parseInt(-1), q = 0; q < this.m_vertexCount; ++q) {
							e = this.m_vertices[q], h = e.x - j, i = e.y - k, e = this.m_normals[q];
							var r = e.x * h + e.y * i,
								s = e.x * n + e.y * o;
							if (0 == s) {
								if (0 > r) return !1
							} else 0 > s && f * s > r ? (f = r / s, p = q) : s > 0 && g * s > r && (g = r / s);
							if (g < f - Number.MIN_VALUE) return !1
						}
						return p >= 0 ? (a.fraction = f, d = c.R, e = this.m_normals[p], a.normal.x = d.col1.x * e.x + d.col2.x * e.y, a.normal.y = d.col1.y * e.x + d.col2.y * e.y, !0) : !1
					}, i.prototype.ComputeAABB = function(a, b) {
						for (var c = b.R, d = this.m_vertices[0], e = b.position.x + (c.col1.x * d.x + c.col2.x * d.y), f = b.position.y + (c.col1.y * d.x + c.col2.y * d.y), g = e, h = f, i = 1; i < this.m_vertexCount; ++i) {
							d = this.m_vertices[i];
							var j = b.position.x + (c.col1.x * d.x + c.col2.x * d.y),
								k = b.position.y + (c.col1.y * d.x + c.col2.y * d.y);
							e = j > e ? e : j, f = k > f ? f : k, g = g > j ? g : j, h = h > k ? h : k
						}
						a.lowerBound.x = e - this.m_radius, a.lowerBound.y = f - this.m_radius, a.upperBound.x = g + this.m_radius, a.upperBound.y = h + this.m_radius
					}, i.prototype.ComputeMass = function(a, b) {
						if (void 0 === b && (b = 0), 2 == this.m_vertexCount) return a.center.x = .5 * (this.m_vertices[0].x + this.m_vertices[1].x), a.center.y = .5 * (this.m_vertices[0].y + this.m_vertices[1].y), a.mass = 0, a.I = 0, void 0;
						for (var c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 1 / 3, j = 0; j < this.m_vertexCount; ++j) {
							var k = this.m_vertices[j],
								l = j + 1 < this.m_vertexCount ? this.m_vertices[parseInt(j + 1)] : this.m_vertices[0],
								m = k.x - g,
								n = k.y - h,
								o = l.x - g,
								p = l.y - h,
								q = m * p - n * o,
								r = .5 * q;
							e += r, c += r * i * (g + k.x + l.x), d += r * i * (h + k.y + l.y);
							var s = g,
								t = h,
								u = m,
								v = n,
								w = o,
								x = p,
								y = i * (.25 * (u * u + w * u + w * w) + (s * u + s * w)) + .5 * s * s,
								z = i * (.25 * (v * v + x * v + x * x) + (t * v + t * x)) + .5 * t * t;
							f += q * (y + z)
						}
						a.mass = b * e, c *= 1 / e, d *= 1 / e, a.center.Set(c, d), a.I = b * f
					}, i.prototype.ComputeSubmergedArea = function(a, b, c, e) {
						void 0 === b && (b = 0);
						var f = l.MulTMV(c.R, a),
							g = b - l.Dot(a, c.position),
							i = new d,
							j = 0,
							k = parseInt(-1),
							m = parseInt(-1),
							o = !1,
							p = 0;
						for (p = 0; p < this.m_vertexCount; ++p) {
							i[p] = l.Dot(f, this.m_vertices[p]) - g;
							var q = i[p] < -Number.MIN_VALUE;
							p > 0 && (q ? o || (k = p - 1, j++) : o && (m = p - 1, j++)), o = q
						}
						switch (j) {
							case 0:
								if (o) {
									var r = new h;
									return this.ComputeMass(r, 1), e.SetV(l.MulX(c, r.center)), r.mass
								}
								return 0;
							case 1:
								-1 == k ? k = this.m_vertexCount - 1 : m = this.m_vertexCount - 1
						}
						var s, t = parseInt((k + 1) % this.m_vertexCount),
							u = parseInt((m + 1) % this.m_vertexCount),
							v = (0 - i[k]) / (i[t] - i[k]),
							w = (0 - i[m]) / (i[u] - i[m]),
							x = new n(this.m_vertices[k].x * (1 - v) + this.m_vertices[t].x * v, this.m_vertices[k].y * (1 - v) + this.m_vertices[t].y * v),
							y = new n(this.m_vertices[m].x * (1 - w) + this.m_vertices[u].x * w, this.m_vertices[m].y * (1 - w) + this.m_vertices[u].y * w),
							z = 0,
							A = new n,
							B = this.m_vertices[t];
						for (p = t; p != u;) {
							p = (p + 1) % this.m_vertexCount, s = p == u ? y : this.m_vertices[p];
							var C = .5 * ((B.x - x.x) * (s.y - x.y) - (B.y - x.y) * (s.x - x.x));
							z += C, A.x += C * (x.x + B.x + s.x) / 3, A.y += C * (x.y + B.y + s.y) / 3, B = s
						}
						return A.Multiply(1 / z), e.SetV(l.MulX(c, A)), z
					}, i.prototype.GetVertexCount = function() {
						return this.m_vertexCount
					}, i.prototype.GetVertices = function() {
						return this.m_vertices
					}, i.prototype.GetNormals = function() {
						return this.m_normals
					}, i.prototype.GetSupport = function(a) {
						for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_vertexCount; ++d) {
							var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
							e > c && (b = d, c = e)
						}
						return b
					}, i.prototype.GetSupportVertex = function(a) {
						for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_vertexCount; ++d) {
							var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
							e > c && (b = d, c = e)
						}
						return this.m_vertices[b]
					}, i.prototype.Validate = function() {
						return !1
					}, i.prototype.b2PolygonShape = function() {
						this.__super.b2Shape.call(this), this.m_type = j.e_polygonShape, this.m_centroid = new n, this.m_vertices = new c, this.m_normals = new c
					}, i.prototype.Reserve = function(a) {
						void 0 === a && (a = 0);
						for (var b = parseInt(this.m_vertices.length); a > b; b++) this.m_vertices[b] = new n, this.m_normals[b] = new n
					}, i.ComputeCentroid = function(a, b) {
						void 0 === b && (b = 0);
						for (var c = new n, d = 0, e = 0, f = 0, g = 1 / 3, h = 0; b > h; ++h) {
							var i = a[h],
								j = b > h + 1 ? a[parseInt(h + 1)] : a[0],
								k = i.x - e,
								l = i.y - f,
								m = j.x - e,
								o = j.y - f,
								p = k * o - l * m,
								q = .5 * p;
							d += q, c.x += q * g * (e + i.x + j.x), c.y += q * g * (f + i.y + j.y)
						}
						return c.x *= 1 / d, c.y *= 1 / d, c
					}, i.ComputeOBB = function(a, b, d) {
						void 0 === d && (d = 0);
						var e = 0,
							f = new c(d + 1);
						for (e = 0; d > e; ++e) f[e] = b[e];
						f[d] = f[0];
						var g = Number.MAX_VALUE;
						for (e = 1; d >= e; ++e) {
							var h = f[parseInt(e - 1)],
								i = f[e].x - h.x,
								j = f[e].y - h.y,
								k = Math.sqrt(i * i + j * j);
							i /= k, j /= k;
							for (var l = -j, m = i, n = Number.MAX_VALUE, o = Number.MAX_VALUE, p = -Number.MAX_VALUE, q = -Number.MAX_VALUE, r = 0; d > r; ++r) {
								var s = f[r].x - h.x,
									t = f[r].y - h.y,
									u = i * s + j * t,
									v = l * s + m * t;
								n > u && (n = u), o > v && (o = v), u > p && (p = u), v > q && (q = v)
							}
							var w = (p - n) * (q - o);
							if (.95 * g > w) {
								g = w, a.R.col1.x = i, a.R.col1.y = j, a.R.col2.x = l, a.R.col2.y = m;
								var x = .5 * (n + p),
									y = .5 * (o + q),
									z = a.R;
								a.center.x = h.x + (z.col1.x * x + z.col2.x * y), a.center.y = h.y + (z.col1.y * x + z.col2.y * y), a.extents.x = .5 * (p - n), a.extents.y = .5 * (q - o)
							}
						}
					}, a.postDefs.push(function() {
						a.Collision.Shapes.b2PolygonShape.s_mat = new k
					}), j.b2Shape = function() {}, j.prototype.Copy = function() {
						return null
					}, j.prototype.Set = function(a) {
						this.m_radius = a.m_radius
					}, j.prototype.GetType = function() {
						return this.m_type
					}, j.prototype.TestPoint = function() {
						return !1
					}, j.prototype.RayCast = function() {
						return !1
					}, j.prototype.ComputeAABB = function() {}, j.prototype.ComputeMass = function(a, b) {
						void 0 === b && (b = 0)
					}, j.prototype.ComputeSubmergedArea = function(a, b) {
						return void 0 === b && (b = 0), 0
					}, j.TestOverlap = function(a, b, c, d) {
						var e = new p;
						e.proxyA = new r, e.proxyA.Set(a), e.proxyB = new r, e.proxyB.Set(c), e.transformA = b, e.transformB = d, e.useRadii = !0;
						var f = new s;
						f.count = 0;
						var g = new q;
						return o.Distance(g, f, e), g.distance < 10 * Number.MIN_VALUE
					}, j.prototype.b2Shape = function() {
						this.m_type = j.e_unknownShape, this.m_radius = b.b2_linearSlop
					}, a.postDefs.push(function() {
						a.Collision.Shapes.b2Shape.e_unknownShape = parseInt(-1), a.Collision.Shapes.b2Shape.e_circleShape = 0, a.Collision.Shapes.b2Shape.e_polygonShape = 1, a.Collision.Shapes.b2Shape.e_edgeShape = 2, a.Collision.Shapes.b2Shape.e_shapeTypeCount = 3, a.Collision.Shapes.b2Shape.e_hitCollide = 1, a.Collision.Shapes.b2Shape.e_missCollide = 0, a.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt(-1)
					})
				}(),
				function() {
					{
						var b = a.Common.b2Color,
							c = (a.Common.b2internal, a.Common.b2Settings),
							d = (a.Common.Math.b2Mat22, a.Common.Math.b2Mat33, a.Common.Math.b2Math);
						a.Common.Math.b2Sweep, a.Common.Math.b2Transform, a.Common.Math.b2Vec2, a.Common.Math.b2Vec3
					}
					b.b2Color = function() {
						this._r = 0, this._g = 0, this._b = 0
					}, b.prototype.b2Color = function(b, c, e) {
						void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === e && (e = 0), this._r = a.parseUInt(255 * d.Clamp(b, 0, 1)), this._g = a.parseUInt(255 * d.Clamp(c, 0, 1)), this._b = a.parseUInt(255 * d.Clamp(e, 0, 1))
					}, b.prototype.Set = function(b, c, e) {
						void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === e && (e = 0), this._r = a.parseUInt(255 * d.Clamp(b, 0, 1)), this._g = a.parseUInt(255 * d.Clamp(c, 0, 1)), this._b = a.parseUInt(255 * d.Clamp(e, 0, 1))
					}, Object.defineProperty(b.prototype, "r", {
						enumerable: !1,
						configurable: !0,
						set: function(b) {
							void 0 === b && (b = 0), this._r = a.parseUInt(255 * d.Clamp(b, 0, 1))
						}
					}), Object.defineProperty(b.prototype, "g", {
						enumerable: !1,
						configurable: !0,
						set: function(b) {
							void 0 === b && (b = 0), this._g = a.parseUInt(255 * d.Clamp(b, 0, 1))
						}
					}), Object.defineProperty(b.prototype, "b", {
						enumerable: !1,
						configurable: !0,
						set: function(b) {
							void 0 === b && (b = 0), this._b = a.parseUInt(255 * d.Clamp(b, 0, 1))
						}
					}), Object.defineProperty(b.prototype, "color", {
						enumerable: !1,
						configurable: !0,
						get: function() {
							return this._r << 16 | this._g << 8 | this._b
						}
					}), c.b2Settings = function() {}, c.b2MixFriction = function(a, b) {
						return void 0 === a && (a = 0), void 0 === b && (b = 0), Math.sqrt(a * b)
					}, c.b2MixRestitution = function(a, b) {
						return void 0 === a && (a = 0), void 0 === b && (b = 0), a > b ? a : b
					}, c.b2Assert = function(a) {
						if (!a) throw "Assertion Failed"
					}, a.postDefs.push(function() {
						a.Common.b2Settings.VERSION = "2.1alpha", a.Common.b2Settings.USHRT_MAX = 65535, a.Common.b2Settings.b2_pi = Math.PI, a.Common.b2Settings.b2_maxManifoldPoints = 2, a.Common.b2Settings.b2_aabbExtension = .1, a.Common.b2Settings.b2_aabbMultiplier = 2, a.Common.b2Settings.b2_polygonRadius = 2 * c.b2_linearSlop, a.Common.b2Settings.b2_linearSlop = .005, a.Common.b2Settings.b2_angularSlop = 2 / 180 * c.b2_pi, a.Common.b2Settings.b2_toiSlop = 8 * c.b2_linearSlop, a.Common.b2Settings.b2_maxTOIContactsPerIsland = 32, a.Common.b2Settings.b2_maxTOIJointsPerIsland = 32, a.Common.b2Settings.b2_velocityThreshold = 1, a.Common.b2Settings.b2_maxLinearCorrection = .2, a.Common.b2Settings.b2_maxAngularCorrection = 8 / 180 * c.b2_pi, a.Common.b2Settings.b2_maxTranslation = 2, a.Common.b2Settings.b2_maxTranslationSquared = c.b2_maxTranslation * c.b2_maxTranslation, a.Common.b2Settings.b2_maxRotation = .5 * c.b2_pi, a.Common.b2Settings.b2_maxRotationSquared = c.b2_maxRotation * c.b2_maxRotation, a.Common.b2Settings.b2_contactBaumgarte = .2, a.Common.b2Settings.b2_timeToSleep = .5, a.Common.b2Settings.b2_linearSleepTolerance = .01, a.Common.b2Settings.b2_angularSleepTolerance = 2 / 180 * c.b2_pi
					})
				}(),
				function() {
					var b = (a.Collision.b2AABB, a.Common.b2Color, a.Common.b2internal, a.Common.b2Settings, a.Common.Math.b2Mat22),
						c = a.Common.Math.b2Mat33,
						d = a.Common.Math.b2Math,
						e = a.Common.Math.b2Sweep,
						f = a.Common.Math.b2Transform,
						g = a.Common.Math.b2Vec2,
						h = a.Common.Math.b2Vec3;
					b.b2Mat22 = function() {
						this.col1 = new g, this.col2 = new g
					}, b.prototype.b2Mat22 = function() {
						this.SetIdentity()
					}, b.FromAngle = function(a) {
						void 0 === a && (a = 0);
						var c = new b;
						return c.Set(a), c
					}, b.FromVV = function(a, c) {
						var d = new b;
						return d.SetVV(a, c), d
					}, b.prototype.Set = function(a) {
						void 0 === a && (a = 0);
						var b = Math.cos(a),
							c = Math.sin(a);
						this.col1.x = b, this.col2.x = -c, this.col1.y = c, this.col2.y = b
					}, b.prototype.SetVV = function(a, b) {
						this.col1.SetV(a), this.col2.SetV(b)
					}, b.prototype.Copy = function() {
						var a = new b;
						return a.SetM(this), a
					}, b.prototype.SetM = function(a) {
						this.col1.SetV(a.col1), this.col2.SetV(a.col2)
					}, b.prototype.AddM = function(a) {
						this.col1.x += a.col1.x, this.col1.y += a.col1.y, this.col2.x += a.col2.x, this.col2.y += a.col2.y
					}, b.prototype.SetIdentity = function() {
						this.col1.x = 1, this.col2.x = 0, this.col1.y = 0, this.col2.y = 1
					}, b.prototype.SetZero = function() {
						this.col1.x = 0, this.col2.x = 0, this.col1.y = 0, this.col2.y = 0
					}, b.prototype.GetAngle = function() {
						return Math.atan2(this.col1.y, this.col1.x)
					}, b.prototype.GetInverse = function(a) {
						var b = this.col1.x,
							c = this.col2.x,
							d = this.col1.y,
							e = this.col2.y,
							f = b * e - c * d;
						return 0 != f && (f = 1 / f), a.col1.x = f * e, a.col2.x = -f * c, a.col1.y = -f * d, a.col2.y = f * b, a
					}, b.prototype.Solve = function(a, b, c) {
						void 0 === b && (b = 0), void 0 === c && (c = 0);
						var d = this.col1.x,
							e = this.col2.x,
							f = this.col1.y,
							g = this.col2.y,
							h = d * g - e * f;
						return 0 != h && (h = 1 / h), a.x = h * (g * b - e * c), a.y = h * (d * c - f * b), a
					}, b.prototype.Abs = function() {
						this.col1.Abs(), this.col2.Abs()
					}, c.b2Mat33 = function() {
						this.col1 = new h, this.col2 = new h, this.col3 = new h
					}, c.prototype.b2Mat33 = function(a, b, c) {
						void 0 === a && (a = null), void 0 === b && (b = null), void 0 === c && (c = null), a || b || c ? (this.col1.SetV(a), this.col2.SetV(b), this.col3.SetV(c)) : (this.col1.SetZero(), this.col2.SetZero(), this.col3.SetZero())
					}, c.prototype.SetVVV = function(a, b, c) {
						this.col1.SetV(a), this.col2.SetV(b), this.col3.SetV(c)
					}, c.prototype.Copy = function() {
						return new c(this.col1, this.col2, this.col3)
					}, c.prototype.SetM = function(a) {
						this.col1.SetV(a.col1), this.col2.SetV(a.col2), this.col3.SetV(a.col3)
					}, c.prototype.AddM = function(a) {
						this.col1.x += a.col1.x, this.col1.y += a.col1.y, this.col1.z += a.col1.z, this.col2.x += a.col2.x, this.col2.y += a.col2.y, this.col2.z += a.col2.z, this.col3.x += a.col3.x, this.col3.y += a.col3.y, this.col3.z += a.col3.z
					}, c.prototype.SetIdentity = function() {
						this.col1.x = 1, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 1, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 1
					}, c.prototype.SetZero = function() {
						this.col1.x = 0, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 0, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 0
					}, c.prototype.Solve22 = function(a, b, c) {
						void 0 === b && (b = 0), void 0 === c && (c = 0);
						var d = this.col1.x,
							e = this.col2.x,
							f = this.col1.y,
							g = this.col2.y,
							h = d * g - e * f;
						return 0 != h && (h = 1 / h), a.x = h * (g * b - e * c), a.y = h * (d * c - f * b), a
					}, c.prototype.Solve33 = function(a, b, c, d) {
						void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 0);
						var e = this.col1.x,
							f = this.col1.y,
							g = this.col1.z,
							h = this.col2.x,
							i = this.col2.y,
							j = this.col2.z,
							k = this.col3.x,
							l = this.col3.y,
							m = this.col3.z,
							n = e * (i * m - j * l) + f * (j * k - h * m) + g * (h * l - i * k);
						return 0 != n && (n = 1 / n), a.x = n * (b * (i * m - j * l) + c * (j * k - h * m) + d * (h * l - i * k)), a.y = n * (e * (c * m - d * l) + f * (d * k - b * m) + g * (b * l - c * k)), a.z = n * (e * (i * d - j * c) + f * (j * b - h * d) + g * (h * c - i * b)), a
					}, d.b2Math = function() {}, d.IsValid = function(a) {
						return void 0 === a && (a = 0), isFinite(a)
					}, d.Dot = function(a, b) {
						return a.x * b.x + a.y * b.y
					}, d.CrossVV = function(a, b) {
						return a.x * b.y - a.y * b.x
					}, d.CrossVF = function(a, b) {
						void 0 === b && (b = 0);
						var c = new g(b * a.y, -b * a.x);
						return c
					}, d.CrossFV = function(a, b) {
						void 0 === a && (a = 0);
						var c = new g(-a * b.y, a * b.x);
						return c
					}, d.MulMV = function(a, b) {
						var c = new g(a.col1.x * b.x + a.col2.x * b.y, a.col1.y * b.x + a.col2.y * b.y);
						return c
					}, d.MulTMV = function(a, b) {
						var c = new g(d.Dot(b, a.col1), d.Dot(b, a.col2));
						return c
					}, d.MulX = function(a, b) {
						var c = d.MulMV(a.R, b);
						return c.x += a.position.x, c.y += a.position.y, c
					}, d.MulXT = function(a, b) {
						var c = d.SubtractVV(b, a.position),
							e = c.x * a.R.col1.x + c.y * a.R.col1.y;
						return c.y = c.x * a.R.col2.x + c.y * a.R.col2.y, c.x = e, c
					}, d.AddVV = function(a, b) {
						var c = new g(a.x + b.x, a.y + b.y);
						return c
					}, d.SubtractVV = function(a, b) {
						var c = new g(a.x - b.x, a.y - b.y);
						return c
					}, d.Distance = function(a, b) {
						var c = a.x - b.x,
							d = a.y - b.y;
						return Math.sqrt(c * c + d * d)
					}, d.DistanceSquared = function(a, b) {
						var c = a.x - b.x,
							d = a.y - b.y;
						return c * c + d * d
					}, d.MulFV = function(a, b) {
						void 0 === a && (a = 0);
						var c = new g(a * b.x, a * b.y);
						return c
					}, d.AddMM = function(a, c) {
						var e = b.FromVV(d.AddVV(a.col1, c.col1), d.AddVV(a.col2, c.col2));
						return e
					}, d.MulMM = function(a, c) {
						var e = b.FromVV(d.MulMV(a, c.col1), d.MulMV(a, c.col2));
						return e
					}, d.MulTMM = function(a, c) {
						var e = new g(d.Dot(a.col1, c.col1), d.Dot(a.col2, c.col1)),
							f = new g(d.Dot(a.col1, c.col2), d.Dot(a.col2, c.col2)),
							h = b.FromVV(e, f);
						return h
					}, d.Abs = function(a) {
						return void 0 === a && (a = 0), a > 0 ? a : -a
					}, d.AbsV = function(a) {
						var b = new g(d.Abs(a.x), d.Abs(a.y));
						return b
					}, d.AbsM = function(a) {
						var c = b.FromVV(d.AbsV(a.col1), d.AbsV(a.col2));
						return c
					}, d.Min = function(a, b) {
						return void 0 === a && (a = 0), void 0 === b && (b = 0), b > a ? a : b
					}, d.MinV = function(a, b) {
						var c = new g(d.Min(a.x, b.x), d.Min(a.y, b.y));
						return c
					}, d.Max = function(a, b) {
						return void 0 === a && (a = 0), void 0 === b && (b = 0), a > b ? a : b
					}, d.MaxV = function(a, b) {
						var c = new g(d.Max(a.x, b.x), d.Max(a.y, b.y));
						return c
					}, d.Clamp = function(a, b, c) {
						return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = 0), b > a ? b : a > c ? c : a
					}, d.ClampV = function(a, b, c) {
						return d.MaxV(b, d.MinV(a, c))
					}, d.Swap = function(a, b) {
						var c = a[0];
						a[0] = b[0], b[0] = c
					}, d.Random = function() {
						return 2 * Math.random() - 1
					}, d.RandomRange = function(a, b) {
						void 0 === a && (a = 0), void 0 === b && (b = 0);
						var c = Math.random();
						return c = (b - a) * c + a
					}, d.NextPowerOfTwo = function(a) {
						return void 0 === a && (a = 0), a |= a >> 1 & 2147483647, a |= a >> 2 & 1073741823, a |= a >> 4 & 268435455, a |= a >> 8 & 16777215, a |= a >> 16 & 65535, a + 1
					}, d.IsPowerOfTwo = function(a) {
						void 0 === a && (a = 0);
						var b = a > 0 && 0 == (a & a - 1);
						return b
					}, a.postDefs.push(function() {
						a.Common.Math.b2Math.b2Vec2_zero = new g(0, 0), a.Common.Math.b2Math.b2Mat22_identity = b.FromVV(new g(1, 0), new g(0, 1)), a.Common.Math.b2Math.b2Transform_identity = new f(d.b2Vec2_zero, d.b2Mat22_identity)
					}), e.b2Sweep = function() {
						this.localCenter = new g, this.c0 = new g, this.c = new g
					}, e.prototype.Set = function(a) {
						this.localCenter.SetV(a.localCenter), this.c0.SetV(a.c0), this.c.SetV(a.c), this.a0 = a.a0, this.a = a.a, this.t0 = a.t0
					}, e.prototype.Copy = function() {
						var a = new e;
						return a.localCenter.SetV(this.localCenter), a.c0.SetV(this.c0), a.c.SetV(this.c), a.a0 = this.a0, a.a = this.a, a.t0 = this.t0, a
					}, e.prototype.GetTransform = function(a, b) {
						void 0 === b && (b = 0), a.position.x = (1 - b) * this.c0.x + b * this.c.x, a.position.y = (1 - b) * this.c0.y + b * this.c.y;
						var c = (1 - b) * this.a0 + b * this.a;
						a.R.Set(c);
						var d = a.R;
						a.position.x -= d.col1.x * this.localCenter.x + d.col2.x * this.localCenter.y, a.position.y -= d.col1.y * this.localCenter.x + d.col2.y * this.localCenter.y
					}, e.prototype.Advance = function(a) {
						if (void 0 === a && (a = 0), this.t0 < a && 1 - this.t0 > Number.MIN_VALUE) {
							var b = (a - this.t0) / (1 - this.t0);
							this.c0.x = (1 - b) * this.c0.x + b * this.c.x, this.c0.y = (1 - b) * this.c0.y + b * this.c.y, this.a0 = (1 - b) * this.a0 + b * this.a, this.t0 = a
						}
					}, f.b2Transform = function() {
						this.position = new g, this.R = new b
					}, f.prototype.b2Transform = function(a, b) {
						void 0 === a && (a = null), void 0 === b && (b = null), a && (this.position.SetV(a), this.R.SetM(b))
					}, f.prototype.Initialize = function(a, b) {
						this.position.SetV(a), this.R.SetM(b)
					}, f.prototype.SetIdentity = function() {
						this.position.SetZero(), this.R.SetIdentity()
					}, f.prototype.Set = function(a) {
						this.position.SetV(a.position), this.R.SetM(a.R)
					}, f.prototype.GetAngle = function() {
						return Math.atan2(this.R.col1.y, this.R.col1.x)
					}, g.b2Vec2 = function() {}, g.prototype.b2Vec2 = function(a, b) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), this.x = a, this.y = b
					}, g.prototype.SetZero = function() {
						this.x = 0, this.y = 0
					}, g.prototype.Set = function(a, b) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), this.x = a, this.y = b
					}, g.prototype.SetV = function(a) {
						this.x = a.x, this.y = a.y
					}, g.prototype.GetNegative = function() {
						return new g(-this.x, -this.y)
					}, g.prototype.NegativeSelf = function() {
						this.x = -this.x, this.y = -this.y
					}, g.Make = function(a, b) {
						return void 0 === a && (a = 0), void 0 === b && (b = 0), new g(a, b)
					}, g.prototype.Copy = function() {
						return new g(this.x, this.y)
					}, g.prototype.Add = function(a) {
						this.x += a.x, this.y += a.y
					}, g.prototype.Subtract = function(a) {
						this.x -= a.x, this.y -= a.y
					}, g.prototype.Multiply = function(a) {
						void 0 === a && (a = 0), this.x *= a, this.y *= a
					}, g.prototype.MulM = function(a) {
						var b = this.x;
						this.x = a.col1.x * b + a.col2.x * this.y, this.y = a.col1.y * b + a.col2.y * this.y
					}, g.prototype.MulTM = function(a) {
						var b = d.Dot(this, a.col1);
						this.y = d.Dot(this, a.col2), this.x = b
					}, g.prototype.CrossVF = function(a) {
						void 0 === a && (a = 0);
						var b = this.x;
						this.x = a * this.y, this.y = -a * b
					}, g.prototype.CrossFV = function(a) {
						void 0 === a && (a = 0);
						var b = this.x;
						this.x = -a * this.y, this.y = a * b
					}, g.prototype.MinV = function(a) {
						this.x = this.x < a.x ? this.x : a.x, this.y = this.y < a.y ? this.y : a.y
					}, g.prototype.MaxV = function(a) {
						this.x = this.x > a.x ? this.x : a.x, this.y = this.y > a.y ? this.y : a.y
					}, g.prototype.Abs = function() {
						this.x < 0 && (this.x = -this.x), this.y < 0 && (this.y = -this.y)
					}, g.prototype.Length = function() {
						return Math.sqrt(this.x * this.x + this.y * this.y)
					}, g.prototype.LengthSquared = function() {
						return this.x * this.x + this.y * this.y
					}, g.prototype.Normalize = function() {
						var a = Math.sqrt(this.x * this.x + this.y * this.y);
						if (a < Number.MIN_VALUE) return 0;
						var b = 1 / a;
						return this.x *= b, this.y *= b, a
					}, g.prototype.IsValid = function() {
						return d.IsValid(this.x) && d.IsValid(this.y)
					}, h.b2Vec3 = function() {}, h.prototype.b2Vec3 = function(a, b, c) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = 0), this.x = a, this.y = b, this.z = c
					}, h.prototype.SetZero = function() {
						this.x = this.y = this.z = 0
					}, h.prototype.Set = function(a, b, c) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = 0), this.x = a, this.y = b, this.z = c
					}, h.prototype.SetV = function(a) {
						this.x = a.x, this.y = a.y, this.z = a.z
					}, h.prototype.GetNegative = function() {
						return new h(-this.x, -this.y, -this.z)
					}, h.prototype.NegativeSelf = function() {
						this.x = -this.x, this.y = -this.y, this.z = -this.z
					}, h.prototype.Copy = function() {
						return new h(this.x, this.y, this.z)
					}, h.prototype.Add = function(a) {
						this.x += a.x, this.y += a.y, this.z += a.z
					}, h.prototype.Subtract = function(a) {
						this.x -= a.x, this.y -= a.y, this.z -= a.z
					}, h.prototype.Multiply = function(a) {
						void 0 === a && (a = 0), this.x *= a, this.y *= a, this.z *= a
					}
				}(),
				function() {
					{
						var b = (a.Dynamics.Controllers.b2ControllerEdge, a.Common.Math.b2Mat22, a.Common.Math.b2Mat33, a.Common.Math.b2Math),
							e = a.Common.Math.b2Sweep,
							f = a.Common.Math.b2Transform,
							g = a.Common.Math.b2Vec2,
							h = (a.Common.Math.b2Vec3, a.Common.b2Color),
							i = (a.Common.b2internal, a.Common.b2Settings),
							j = a.Collision.b2AABB,
							k = (a.Collision.b2Bound, a.Collision.b2BoundValues, a.Collision.b2Collision, a.Collision.b2ContactID, a.Collision.b2ContactPoint),
							l = (a.Collision.b2Distance, a.Collision.b2DistanceInput, a.Collision.b2DistanceOutput, a.Collision.b2DistanceProxy, a.Collision.b2DynamicTree, a.Collision.b2DynamicTreeBroadPhase),
							m = (a.Collision.b2DynamicTreeNode, a.Collision.b2DynamicTreePair, a.Collision.b2Manifold, a.Collision.b2ManifoldPoint, a.Collision.b2Point, a.Collision.b2RayCastInput),
							n = a.Collision.b2RayCastOutput,
							o = (a.Collision.b2Segment, a.Collision.b2SeparationFunction, a.Collision.b2Simplex, a.Collision.b2SimplexCache, a.Collision.b2SimplexVertex, a.Collision.b2TimeOfImpact, a.Collision.b2TOIInput, a.Collision.b2WorldManifold, a.Collision.ClipVertex, a.Collision.Features, a.Collision.IBroadPhase, a.Collision.Shapes.b2CircleShape),
							p = (a.Collision.Shapes.b2EdgeChainDef, a.Collision.Shapes.b2EdgeShape),
							q = a.Collision.Shapes.b2MassData,
							r = a.Collision.Shapes.b2PolygonShape,
							s = a.Collision.Shapes.b2Shape,
							t = a.Dynamics.b2Body,
							u = a.Dynamics.b2BodyDef,
							v = a.Dynamics.b2ContactFilter,
							w = a.Dynamics.b2ContactImpulse,
							x = a.Dynamics.b2ContactListener,
							y = a.Dynamics.b2ContactManager,
							z = a.Dynamics.b2DebugDraw,
							A = a.Dynamics.b2DestructionListener,
							B = a.Dynamics.b2FilterData,
							C = a.Dynamics.b2Fixture,
							D = a.Dynamics.b2FixtureDef,
							E = a.Dynamics.b2Island,
							F = a.Dynamics.b2TimeStep,
							G = a.Dynamics.b2World,
							H = (a.Dynamics.Contacts.b2CircleContact, a.Dynamics.Contacts.b2Contact),
							I = (a.Dynamics.Contacts.b2ContactConstraint, a.Dynamics.Contacts.b2ContactConstraintPoint, a.Dynamics.Contacts.b2ContactEdge, a.Dynamics.Contacts.b2ContactFactory),
							J = (a.Dynamics.Contacts.b2ContactRegister, a.Dynamics.Contacts.b2ContactResult, a.Dynamics.Contacts.b2ContactSolver),
							K = (a.Dynamics.Contacts.b2EdgeAndCircleContact, a.Dynamics.Contacts.b2NullContact, a.Dynamics.Contacts.b2PolyAndCircleContact, a.Dynamics.Contacts.b2PolyAndEdgeContact, a.Dynamics.Contacts.b2PolygonContact, a.Dynamics.Contacts.b2PositionSolverManifold, a.Dynamics.Controllers.b2Controller, a.Dynamics.Joints.b2DistanceJoint, a.Dynamics.Joints.b2DistanceJointDef, a.Dynamics.Joints.b2FrictionJoint, a.Dynamics.Joints.b2FrictionJointDef, a.Dynamics.Joints.b2GearJoint, a.Dynamics.Joints.b2GearJointDef, a.Dynamics.Joints.b2Jacobian, a.Dynamics.Joints.b2Joint),
							L = (a.Dynamics.Joints.b2JointDef, a.Dynamics.Joints.b2JointEdge, a.Dynamics.Joints.b2LineJoint, a.Dynamics.Joints.b2LineJointDef, a.Dynamics.Joints.b2MouseJoint, a.Dynamics.Joints.b2MouseJointDef, a.Dynamics.Joints.b2PrismaticJoint, a.Dynamics.Joints.b2PrismaticJointDef, a.Dynamics.Joints.b2PulleyJoint);
						a.Dynamics.Joints.b2PulleyJointDef, a.Dynamics.Joints.b2RevoluteJoint, a.Dynamics.Joints.b2RevoluteJointDef, a.Dynamics.Joints.b2WeldJoint, a.Dynamics.Joints.b2WeldJointDef
					}
					t.b2Body = function() {
						this.m_xf = new f, this.m_sweep = new e, this.m_linearVelocity = new g, this.m_force = new g
					}, t.prototype.connectEdges = function(a, c, d) {
						void 0 === d && (d = 0);
						var e = Math.atan2(c.GetDirectionVector().y, c.GetDirectionVector().x),
							f = Math.tan(.5 * (e - d)),
							g = b.MulFV(f, c.GetDirectionVector());
						g = b.SubtractVV(g, c.GetNormalVector()), g = b.MulFV(i.b2_toiSlop, g), g = b.AddVV(g, c.GetVertex1());
						var h = b.AddVV(a.GetDirectionVector(), c.GetDirectionVector());
						h.Normalize();
						var j = b.Dot(a.GetDirectionVector(), c.GetNormalVector()) > 0;
						return a.SetNextEdge(c, g, h, j), c.SetPrevEdge(a, g, h, j), e
					}, t.prototype.CreateFixture = function(a) {
						if (1 == this.m_world.IsLocked()) return null;
						var b = new C;
						if (b.Create(this, this.m_xf, a), this.m_flags & t.e_activeFlag) {
							var c = this.m_world.m_contactManager.m_broadPhase;
							b.CreateProxy(c, this.m_xf)
						}
						return b.m_next = this.m_fixtureList, this.m_fixtureList = b, ++this.m_fixtureCount, b.m_body = this, b.m_density > 0 && this.ResetMassData(), this.m_world.m_flags |= G.e_newFixture, b
					}, t.prototype.CreateFixture2 = function(a, b) {
						void 0 === b && (b = 0);
						var c = new D;
						return c.shape = a, c.density = b, this.CreateFixture(c)
					}, t.prototype.DestroyFixture = function(a) {
						if (1 != this.m_world.IsLocked()) {
							for (var b = this.m_fixtureList, c = null, d = !1; null != b;) {
								if (b == a) {
									c ? c.m_next = a.m_next : this.m_fixtureList = a.m_next, d = !0;
									break
								}
								c = b, b = b.m_next
							}
							for (var e = this.m_contactList; e;) {
								var f = e.contact;
								e = e.next;
								var g = f.GetFixtureA(),
									h = f.GetFixtureB();
								(a == g || a == h) && this.m_world.m_contactManager.Destroy(f)
							}
							if (this.m_flags & t.e_activeFlag) {
								var i = this.m_world.m_contactManager.m_broadPhase;
								a.DestroyProxy(i)
							}
							a.Destroy(), a.m_body = null, a.m_next = null, --this.m_fixtureCount, this.ResetMassData()
						}
					}, t.prototype.SetPositionAndAngle = function(a, b) {
						void 0 === b && (b = 0);
						var c;
						if (1 != this.m_world.IsLocked()) {
							this.m_xf.R.Set(b), this.m_xf.position.SetV(a);
							var d = this.m_xf.R,
								e = this.m_sweep.localCenter;
							this.m_sweep.c.x = d.col1.x * e.x + d.col2.x * e.y, this.m_sweep.c.y = d.col1.y * e.x + d.col2.y * e.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_sweep.a0 = this.m_sweep.a = b;
							var f = this.m_world.m_contactManager.m_broadPhase;
							for (c = this.m_fixtureList; c; c = c.m_next) c.Synchronize(f, this.m_xf, this.m_xf);
							this.m_world.m_contactManager.FindNewContacts()
						}
					}, t.prototype.SetTransform = function(a) {
						this.SetPositionAndAngle(a.position, a.GetAngle())
					}, t.prototype.GetTransform = function() {
						return this.m_xf
					}, t.prototype.GetPosition = function() {
						return this.m_xf.position
					}, t.prototype.SetPosition = function(a) {
						this.SetPositionAndAngle(a, this.GetAngle())
					}, t.prototype.GetAngle = function() {
						return this.m_sweep.a
					}, t.prototype.SetAngle = function(a) {
						void 0 === a && (a = 0), this.SetPositionAndAngle(this.GetPosition(), a)
					}, t.prototype.GetWorldCenter = function() {
						return this.m_sweep.c
					}, t.prototype.GetLocalCenter = function() {
						return this.m_sweep.localCenter
					}, t.prototype.SetLinearVelocity = function(a) {
						this.m_type != t.b2_staticBody && this.m_linearVelocity.SetV(a)
					}, t.prototype.GetLinearVelocity = function() {
						return this.m_linearVelocity
					}, t.prototype.SetAngularVelocity = function(a) {
						void 0 === a && (a = 0), this.m_type != t.b2_staticBody && (this.m_angularVelocity = a)
					}, t.prototype.GetAngularVelocity = function() {
						return this.m_angularVelocity
					}, t.prototype.GetDefinition = function() {
						var a = new u;
						return a.type = this.GetType(), a.allowSleep = (this.m_flags & t.e_allowSleepFlag) == t.e_allowSleepFlag, a.angle = this.GetAngle(), a.angularDamping = this.m_angularDamping, a.angularVelocity = this.m_angularVelocity, a.fixedRotation = (this.m_flags & t.e_fixedRotationFlag) == t.e_fixedRotationFlag, a.bullet = (this.m_flags & t.e_bulletFlag) == t.e_bulletFlag, a.awake = (this.m_flags & t.e_awakeFlag) == t.e_awakeFlag, a.linearDamping = this.m_linearDamping, a.linearVelocity.SetV(this.GetLinearVelocity()), a.position = this.GetPosition(), a.userData = this.GetUserData(), a
					}, t.prototype.ApplyForce = function(a, b) {
						this.m_type == t.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_force.x += a.x, this.m_force.y += a.y, this.m_torque += (b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x)
					}, t.prototype.ApplyTorque = function(a) {
						void 0 === a && (a = 0), this.m_type == t.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_torque += a)
					}, t.prototype.ApplyImpulse = function(a, b) {
						this.m_type == t.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_linearVelocity.x += this.m_invMass * a.x, this.m_linearVelocity.y += this.m_invMass * a.y, this.m_angularVelocity += this.m_invI * ((b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x))
					}, t.prototype.Split = function(a) {
						for (var c, d = this.GetLinearVelocity().Copy(), e = this.GetAngularVelocity(), f = this.GetWorldCenter(), g = this, h = this.m_world.CreateBody(this.GetDefinition()), i = g.m_fixtureList; i;)
							if (a(i)) {
								var j = i.m_next;
								c ? c.m_next = j : g.m_fixtureList = j, g.m_fixtureCount--, i.m_next = h.m_fixtureList, h.m_fixtureList = i, h.m_fixtureCount++, i.m_body = h, i = j
							} else c = i, i = i.m_next;
						g.ResetMassData(), h.ResetMassData();
						var k = g.GetWorldCenter(),
							l = h.GetWorldCenter(),
							m = b.AddVV(d, b.CrossFV(e, b.SubtractVV(k, f))),
							n = b.AddVV(d, b.CrossFV(e, b.SubtractVV(l, f)));
						return g.SetLinearVelocity(m), h.SetLinearVelocity(n), g.SetAngularVelocity(e), h.SetAngularVelocity(e), g.SynchronizeFixtures(), h.SynchronizeFixtures(), h
					}, t.prototype.Merge = function(a) {
						var b;
						for (b = a.m_fixtureList; b;) {
							var c = b.m_next;
							a.m_fixtureCount--, b.m_next = this.m_fixtureList, this.m_fixtureList = b, this.m_fixtureCount++, b.m_body = e, b = c
						}
						d.m_fixtureCount = 0; {
							var d = this,
								e = a;
							d.GetWorldCenter(), e.GetWorldCenter(), d.GetLinearVelocity().Copy(), e.GetLinearVelocity().Copy(), d.GetAngularVelocity(), e.GetAngularVelocity()
						}
						d.ResetMassData(), this.SynchronizeFixtures()
					}, t.prototype.GetMass = function() {
						return this.m_mass
					}, t.prototype.GetInertia = function() {
						return this.m_I
					}, t.prototype.GetMassData = function(a) {
						a.mass = this.m_mass, a.I = this.m_I, a.center.SetV(this.m_sweep.localCenter)
					}, t.prototype.SetMassData = function(a) {
						if (i.b2Assert(0 == this.m_world.IsLocked()), 1 != this.m_world.IsLocked() && this.m_type == t.b2_dynamicBody) {
							this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_mass = a.mass, this.m_mass <= 0 && (this.m_mass = 1), this.m_invMass = 1 / this.m_mass, a.I > 0 && 0 == (this.m_flags & t.e_fixedRotationFlag) && (this.m_I = a.I - this.m_mass * (a.center.x * a.center.x + a.center.y * a.center.y), this.m_invI = 1 / this.m_I);
							var c = this.m_sweep.c.Copy();
							this.m_sweep.localCenter.SetV(a.center), this.m_sweep.c0.SetV(b.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - c.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - c.x)
						}
					}, t.prototype.ResetMassData = function() {
						if (this.m_mass = 0, this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_sweep.localCenter.SetZero(), this.m_type != t.b2_staticBody && this.m_type != t.b2_kinematicBody) {
							for (var a = g.Make(0, 0), c = this.m_fixtureList; c; c = c.m_next)
								if (0 != c.m_density) {
									var d = c.GetMassData();
									this.m_mass += d.mass, a.x += d.center.x * d.mass, a.y += d.center.y * d.mass, this.m_I += d.I
								} this.m_mass > 0 ? (this.m_invMass = 1 / this.m_mass, a.x *= this.m_invMass, a.y *= this.m_invMass) : (this.m_mass = 1, this.m_invMass = 1), this.m_I > 0 && 0 == (this.m_flags & t.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * (a.x * a.x + a.y * a.y), this.m_I *= this.m_inertiaScale, i.b2Assert(this.m_I > 0), this.m_invI = 1 / this.m_I) : (this.m_I = 0, this.m_invI = 0);
							var e = this.m_sweep.c.Copy();
							this.m_sweep.localCenter.SetV(a), this.m_sweep.c0.SetV(b.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - e.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - e.x)
						}
					}, t.prototype.GetWorldPoint = function(a) {
						var b = this.m_xf.R,
							c = new g(b.col1.x * a.x + b.col2.x * a.y, b.col1.y * a.x + b.col2.y * a.y);
						return c.x += this.m_xf.position.x, c.y += this.m_xf.position.y, c
					}, t.prototype.GetWorldVector = function(a) {
						return b.MulMV(this.m_xf.R, a)
					}, t.prototype.GetLocalPoint = function(a) {
						return b.MulXT(this.m_xf, a)
					}, t.prototype.GetLocalVector = function(a) {
						return b.MulTMV(this.m_xf.R, a)
					}, t.prototype.GetLinearVelocityFromWorldPoint = function(a) {
						return new g(this.m_linearVelocity.x - this.m_angularVelocity * (a.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (a.x - this.m_sweep.c.x))
					}, t.prototype.GetLinearVelocityFromLocalPoint = function(a) {
						var b = this.m_xf.R,
							c = new g(b.col1.x * a.x + b.col2.x * a.y, b.col1.y * a.x + b.col2.y * a.y);
						return c.x += this.m_xf.position.x, c.y += this.m_xf.position.y, new g(this.m_linearVelocity.x - this.m_angularVelocity * (c.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (c.x - this.m_sweep.c.x))
					}, t.prototype.GetLinearDamping = function() {
						return this.m_linearDamping
					}, t.prototype.SetLinearDamping = function(a) {
						void 0 === a && (a = 0), this.m_linearDamping = a
					}, t.prototype.GetAngularDamping = function() {
						return this.m_angularDamping
					}, t.prototype.SetAngularDamping = function(a) {
						void 0 === a && (a = 0), this.m_angularDamping = a
					}, t.prototype.SetType = function(a) {
						if (void 0 === a && (a = 0), this.m_type != a) {
							this.m_type = a, this.ResetMassData(), this.m_type == t.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0;
							for (var b = this.m_contactList; b; b = b.next) b.contact.FlagForFiltering()
						}
					}, t.prototype.GetType = function() {
						return this.m_type
					}, t.prototype.SetBullet = function(a) {
						a ? this.m_flags |= t.e_bulletFlag : this.m_flags &= ~t.e_bulletFlag
					}, t.prototype.IsBullet = function() {
						return (this.m_flags & t.e_bulletFlag) == t.e_bulletFlag
					}, t.prototype.SetSleepingAllowed = function(a) {
						a ? this.m_flags |= t.e_allowSleepFlag : (this.m_flags &= ~t.e_allowSleepFlag, this.SetAwake(!0))
					}, t.prototype.SetAwake = function(a) {
						a ? (this.m_flags |= t.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~t.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0)
					}, t.prototype.IsAwake = function() {
						return (this.m_flags & t.e_awakeFlag) == t.e_awakeFlag
					}, t.prototype.SetFixedRotation = function(a) {
						a ? this.m_flags |= t.e_fixedRotationFlag : this.m_flags &= ~t.e_fixedRotationFlag, this.ResetMassData()
					}, t.prototype.IsFixedRotation = function() {
						return (this.m_flags & t.e_fixedRotationFlag) == t.e_fixedRotationFlag
					}, t.prototype.SetActive = function(a) {
						if (a != this.IsActive()) {
							var b, c;
							if (a)
								for (this.m_flags |= t.e_activeFlag, b = this.m_world.m_contactManager.m_broadPhase, c = this.m_fixtureList; c; c = c.m_next) c.CreateProxy(b, this.m_xf);
							else {
								for (this.m_flags &= ~t.e_activeFlag, b = this.m_world.m_contactManager.m_broadPhase, c = this.m_fixtureList; c; c = c.m_next) c.DestroyProxy(b);
								for (var d = this.m_contactList; d;) {
									var e = d;
									d = d.next, this.m_world.m_contactManager.Destroy(e.contact)
								}
								this.m_contactList = null
							}
						}
					}, t.prototype.IsActive = function() {
						return (this.m_flags & t.e_activeFlag) == t.e_activeFlag
					}, t.prototype.IsSleepingAllowed = function() {
						return (this.m_flags & t.e_allowSleepFlag) == t.e_allowSleepFlag
					}, t.prototype.GetFixtureList = function() {
						return this.m_fixtureList
					}, t.prototype.GetJointList = function() {
						return this.m_jointList
					}, t.prototype.GetControllerList = function() {
						return this.m_controllerList
					}, t.prototype.GetContactList = function() {
						return this.m_contactList
					}, t.prototype.GetNext = function() {
						return this.m_next
					}, t.prototype.GetUserData = function() {
						return this.m_userData
					}, t.prototype.SetUserData = function(a) {
						this.m_userData = a
					}, t.prototype.GetWorld = function() {
						return this.m_world
					}, t.prototype.b2Body = function(a, b) {
						this.m_flags = 0, a.bullet && (this.m_flags |= t.e_bulletFlag), a.fixedRotation && (this.m_flags |= t.e_fixedRotationFlag), a.allowSleep && (this.m_flags |= t.e_allowSleepFlag), a.awake && (this.m_flags |= t.e_awakeFlag), a.active && (this.m_flags |= t.e_activeFlag), this.m_world = b, this.m_xf.position.SetV(a.position), this.m_xf.R.Set(a.angle), this.m_sweep.localCenter.SetZero(), this.m_sweep.t0 = 1, this.m_sweep.a0 = this.m_sweep.a = a.angle;
						var c = this.m_xf.R,
							d = this.m_sweep.localCenter;
						this.m_sweep.c.x = c.col1.x * d.x + c.col2.x * d.y, this.m_sweep.c.y = c.col1.y * d.x + c.col2.y * d.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_jointList = null, this.m_controllerList = null, this.m_contactList = null, this.m_controllerCount = 0, this.m_prev = null, this.m_next = null, this.m_linearVelocity.SetV(a.linearVelocity), this.m_angularVelocity = a.angularVelocity, this.m_linearDamping = a.linearDamping, this.m_angularDamping = a.angularDamping, this.m_force.Set(0, 0), this.m_torque = 0, this.m_sleepTime = 0, this.m_type = a.type, this.m_type == t.b2_dynamicBody ? (this.m_mass = 1, this.m_invMass = 1) : (this.m_mass = 0, this.m_invMass = 0), this.m_I = 0, this.m_invI = 0, this.m_inertiaScale = a.inertiaScale, this.m_userData = a.userData, this.m_fixtureList = null, this.m_fixtureCount = 0
					}, t.prototype.SynchronizeFixtures = function() {
						var a = t.s_xf1;
						a.R.Set(this.m_sweep.a0);
						var b = a.R,
							c = this.m_sweep.localCenter;
						a.position.x = this.m_sweep.c0.x - (b.col1.x * c.x + b.col2.x * c.y), a.position.y = this.m_sweep.c0.y - (b.col1.y * c.x + b.col2.y * c.y);
						var d, e = this.m_world.m_contactManager.m_broadPhase;
						for (d = this.m_fixtureList; d; d = d.m_next) d.Synchronize(e, a, this.m_xf)
					}, t.prototype.SynchronizeTransform = function() {
						this.m_xf.R.Set(this.m_sweep.a);
						var a = this.m_xf.R,
							b = this.m_sweep.localCenter;
						this.m_xf.position.x = this.m_sweep.c.x - (a.col1.x * b.x + a.col2.x * b.y), this.m_xf.position.y = this.m_sweep.c.y - (a.col1.y * b.x + a.col2.y * b.y)
					}, t.prototype.ShouldCollide = function(a) {
						if (this.m_type != t.b2_dynamicBody && a.m_type != t.b2_dynamicBody) return !1;
						for (var b = this.m_jointList; b; b = b.next)
							if (b.other == a && 0 == b.joint.m_collideConnected) return !1;
						return !0
					}, t.prototype.Advance = function(a) {
						void 0 === a && (a = 0), this.m_sweep.Advance(a), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_sweep.a = this.m_sweep.a0, this.SynchronizeTransform()
					}, a.postDefs.push(function() {
						a.Dynamics.b2Body.s_xf1 = new f, a.Dynamics.b2Body.e_islandFlag = 1, a.Dynamics.b2Body.e_awakeFlag = 2, a.Dynamics.b2Body.e_allowSleepFlag = 4, a.Dynamics.b2Body.e_bulletFlag = 8, a.Dynamics.b2Body.e_fixedRotationFlag = 16, a.Dynamics.b2Body.e_activeFlag = 32, a.Dynamics.b2Body.b2_staticBody = 0, a.Dynamics.b2Body.b2_kinematicBody = 1, a.Dynamics.b2Body.b2_dynamicBody = 2
					}), u.b2BodyDef = function() {
						this.position = new g, this.linearVelocity = new g
					}, u.prototype.b2BodyDef = function() {
						this.userData = null, this.position.Set(0, 0), this.angle = 0, this.linearVelocity.Set(0, 0), this.angularVelocity = 0, this.linearDamping = 0, this.angularDamping = 0, this.allowSleep = !0, this.awake = !0, this.fixedRotation = !1, this.bullet = !1, this.type = t.b2_staticBody, this.active = !0, this.inertiaScale = 1
					}, v.b2ContactFilter = function() {}, v.prototype.ShouldCollide = function(a, b) {
						var c = a.GetFilterData(),
							d = b.GetFilterData();
						if (c.groupIndex == d.groupIndex && 0 != c.groupIndex) return c.groupIndex > 0;
						var e = 0 != (c.maskBits & d.categoryBits) && 0 != (c.categoryBits & d.maskBits);
						return e
					}, v.prototype.RayCollide = function(a, b) {
						return a ? this.ShouldCollide(a instanceof C ? a : null, b) : !0
					}, a.postDefs.push(function() {
						a.Dynamics.b2ContactFilter.b2_defaultFilter = new v
					}), w.b2ContactImpulse = function() {
						this.normalImpulses = new d(i.b2_maxManifoldPoints), this.tangentImpulses = new d(i.b2_maxManifoldPoints)
					}, x.b2ContactListener = function() {}, x.prototype.BeginContact = function() {}, x.prototype.EndContact = function() {}, x.prototype.PreSolve = function() {}, x.prototype.PostSolve = function() {}, a.postDefs.push(function() {
						a.Dynamics.b2ContactListener.b2_defaultListener = new x
					}), y.b2ContactManager = function() {}, y.prototype.b2ContactManager = function() {
						this.m_world = null, this.m_contactCount = 0, this.m_contactFilter = v.b2_defaultFilter, this.m_contactListener = x.b2_defaultListener, this.m_contactFactory = new I(this.m_allocator), this.m_broadPhase = new l
					}, y.prototype.AddPair = function(a, b) {
						var c = a instanceof C ? a : null,
							d = b instanceof C ? b : null,
							e = c.GetBody(),
							f = d.GetBody();
						if (e != f) {
							for (var g = f.GetContactList(); g;) {
								if (g.other == e) {
									var h = g.contact.GetFixtureA(),
										i = g.contact.GetFixtureB();
									if (h == c && i == d) return;
									if (h == d && i == c) return
								}
								g = g.next
							}
							if (0 != f.ShouldCollide(e) && 0 != this.m_contactFilter.ShouldCollide(c, d)) {
								var j = this.m_contactFactory.Create(c, d);
								c = j.GetFixtureA(), d = j.GetFixtureB(), e = c.m_body, f = d.m_body, j.m_prev = null, j.m_next = this.m_world.m_contactList, null != this.m_world.m_contactList && (this.m_world.m_contactList.m_prev = j), this.m_world.m_contactList = j, j.m_nodeA.contact = j, j.m_nodeA.other = f, j.m_nodeA.prev = null, j.m_nodeA.next = e.m_contactList, null != e.m_contactList && (e.m_contactList.prev = j.m_nodeA), e.m_contactList = j.m_nodeA, j.m_nodeB.contact = j, j.m_nodeB.other = e, j.m_nodeB.prev = null, j.m_nodeB.next = f.m_contactList, null != f.m_contactList && (f.m_contactList.prev = j.m_nodeB), f.m_contactList = j.m_nodeB, ++this.m_world.m_contactCount
							}
						}
					}, y.prototype.FindNewContacts = function() {
						this.m_broadPhase.UpdatePairs(a.generateCallback(this, this.AddPair))
					}, y.prototype.Destroy = function(a) {
						var b = a.GetFixtureA(),
							c = a.GetFixtureB(),
							d = b.GetBody(),
							e = c.GetBody();
						a.IsTouching() && this.m_contactListener.EndContact(a), a.m_prev && (a.m_prev.m_next = a.m_next), a.m_next && (a.m_next.m_prev = a.m_prev), a == this.m_world.m_contactList && (this.m_world.m_contactList = a.m_next), a.m_nodeA.prev && (a.m_nodeA.prev.next = a.m_nodeA.next), a.m_nodeA.next && (a.m_nodeA.next.prev = a.m_nodeA.prev), a.m_nodeA == d.m_contactList && (d.m_contactList = a.m_nodeA.next), a.m_nodeB.prev && (a.m_nodeB.prev.next = a.m_nodeB.next), a.m_nodeB.next && (a.m_nodeB.next.prev = a.m_nodeB.prev), a.m_nodeB == e.m_contactList && (e.m_contactList = a.m_nodeB.next), this.m_contactFactory.Destroy(a), --this.m_contactCount
					}, y.prototype.Collide = function() {
						for (var a = this.m_world.m_contactList; a;) {
							var b = a.GetFixtureA(),
								c = a.GetFixtureB(),
								d = b.GetBody(),
								e = c.GetBody();
							if (0 != d.IsAwake() || 0 != e.IsAwake()) {
								if (a.m_flags & H.e_filterFlag) {
									if (0 == e.ShouldCollide(d)) {
										var f = a;
										a = f.GetNext(), this.Destroy(f);
										continue
									}
									if (0 == this.m_contactFilter.ShouldCollide(b, c)) {
										f = a, a = f.GetNext(), this.Destroy(f);
										continue
									}
									a.m_flags &= ~H.e_filterFlag
								}
								var g = b.m_proxy,
									h = c.m_proxy,
									i = this.m_broadPhase.TestOverlap(g, h);
								0 != i ? (a.Update(this.m_contactListener), a = a.GetNext()) : (f = a, a = f.GetNext(), this.Destroy(f))
							} else a = a.GetNext()
						}
					}, a.postDefs.push(function() {
						a.Dynamics.b2ContactManager.s_evalCP = new k
					}), z.b2DebugDraw = function() {}, z.prototype.b2DebugDraw = function() {}, z.prototype.SetFlags = function(a) {
						void 0 === a && (a = 0)
					}, z.prototype.GetFlags = function() {}, z.prototype.AppendFlags = function(a) {
						void 0 === a && (a = 0)
					}, z.prototype.ClearFlags = function(a) {
						void 0 === a && (a = 0)
					}, z.prototype.SetSprite = function() {}, z.prototype.GetSprite = function() {}, z.prototype.SetDrawScale = function(a) {
						void 0 === a && (a = 0)
					}, z.prototype.GetDrawScale = function() {}, z.prototype.SetLineThickness = function(a) {
						void 0 === a && (a = 0)
					}, z.prototype.GetLineThickness = function() {}, z.prototype.SetAlpha = function(a) {
						void 0 === a && (a = 0)
					}, z.prototype.GetAlpha = function() {}, z.prototype.SetFillAlpha = function(a) {
						void 0 === a && (a = 0)
					}, z.prototype.GetFillAlpha = function() {}, z.prototype.SetXFormScale = function(a) {
						void 0 === a && (a = 0)
					}, z.prototype.GetXFormScale = function() {}, z.prototype.DrawPolygon = function(a, b) {
						void 0 === b && (b = 0)
					}, z.prototype.DrawSolidPolygon = function(a, b) {
						void 0 === b && (b = 0)
					}, z.prototype.DrawCircle = function(a, b) {
						void 0 === b && (b = 0)
					}, z.prototype.DrawSolidCircle = function(a, b) {
						void 0 === b && (b = 0)
					}, z.prototype.DrawSegment = function() {}, z.prototype.DrawTransform = function() {}, a.postDefs.push(function() {
						a.Dynamics.b2DebugDraw.e_shapeBit = 1, a.Dynamics.b2DebugDraw.e_jointBit = 2, a.Dynamics.b2DebugDraw.e_aabbBit = 4, a.Dynamics.b2DebugDraw.e_pairBit = 8, a.Dynamics.b2DebugDraw.e_centerOfMassBit = 16, a.Dynamics.b2DebugDraw.e_controllerBit = 32
					}), A.b2DestructionListener = function() {}, A.prototype.SayGoodbyeJoint = function() {}, A.prototype.SayGoodbyeFixture = function() {}, B.b2FilterData = function() {
						this.categoryBits = 1, this.maskBits = 65535, this.groupIndex = 0
					}, B.prototype.Copy = function() {
						var a = new B;
						return a.categoryBits = this.categoryBits, a.maskBits = this.maskBits, a.groupIndex = this.groupIndex, a
					}, C.b2Fixture = function() {
						this.m_filter = new B
					}, C.prototype.GetType = function() {
						return this.m_shape.GetType()
					}, C.prototype.GetShape = function() {
						return this.m_shape
					}, C.prototype.SetSensor = function(a) {
						if (this.m_isSensor != a && (this.m_isSensor = a, null != this.m_body))
							for (var b = this.m_body.GetContactList(); b;) {
								var c = b.contact,
									d = c.GetFixtureA(),
									e = c.GetFixtureB();
								(d == this || e == this) && c.SetSensor(d.IsSensor() || e.IsSensor()), b = b.next
							}
					}, C.prototype.IsSensor = function() {
						return this.m_isSensor
					}, C.prototype.SetFilterData = function(a) {
						if (this.m_filter = a.Copy(), !this.m_body)
							for (var b = this.m_body.GetContactList(); b;) {
								var c = b.contact,
									d = c.GetFixtureA(),
									e = c.GetFixtureB();
								(d == this || e == this) && c.FlagForFiltering(), b = b.next
							}
					}, C.prototype.GetFilterData = function() {
						return this.m_filter.Copy()
					}, C.prototype.GetBody = function() {
						return this.m_body
					}, C.prototype.GetNext = function() {
						return this.m_next
					}, C.prototype.GetUserData = function() {
						return this.m_userData
					}, C.prototype.SetUserData = function(a) {
						this.m_userData = a
					}, C.prototype.TestPoint = function(a) {
						return this.m_shape.TestPoint(this.m_body.GetTransform(), a)
					}, C.prototype.RayCast = function(a, b) {
						return this.m_shape.RayCast(a, b, this.m_body.GetTransform())
					}, C.prototype.GetMassData = function(a) {
						return void 0 === a && (a = null), null == a && (a = new q), this.m_shape.ComputeMass(a, this.m_density), a
					}, C.prototype.SetDensity = function(a) {
						void 0 === a && (a = 0), this.m_density = a
					}, C.prototype.GetDensity = function() {
						return this.m_density
					}, C.prototype.GetFriction = function() {
						return this.m_friction
					}, C.prototype.SetFriction = function(a) {
						void 0 === a && (a = 0), this.m_friction = a
					}, C.prototype.GetRestitution = function() {
						return this.m_restitution
					}, C.prototype.SetRestitution = function(a) {
						void 0 === a && (a = 0), this.m_restitution = a
					}, C.prototype.GetAABB = function() {
						return this.m_aabb
					}, C.prototype.b2Fixture = function() {
						this.m_aabb = new j, this.m_userData = null, this.m_body = null, this.m_next = null, this.m_shape = null, this.m_density = 0, this.m_friction = 0, this.m_restitution = 0
					}, C.prototype.Create = function(a, b, c) {
						this.m_userData = c.userData, this.m_friction = c.friction, this.m_restitution = c.restitution, this.m_body = a, this.m_next = null, this.m_filter = c.filter.Copy(), this.m_isSensor = c.isSensor, this.m_shape = c.shape.Copy(), this.m_density = c.density
					}, C.prototype.Destroy = function() {
						this.m_shape = null
					}, C.prototype.CreateProxy = function(a, b) {
						this.m_shape.ComputeAABB(this.m_aabb, b), this.m_proxy = a.CreateProxy(this.m_aabb, this)
					}, C.prototype.DestroyProxy = function(a) {
						null != this.m_proxy && (a.DestroyProxy(this.m_proxy), this.m_proxy = null)
					}, C.prototype.Synchronize = function(a, c, d) {
						if (this.m_proxy) {
							var e = new j,
								f = new j;
							this.m_shape.ComputeAABB(e, c), this.m_shape.ComputeAABB(f, d), this.m_aabb.Combine(e, f);
							var g = b.SubtractVV(d.position, c.position);
							a.MoveProxy(this.m_proxy, this.m_aabb, g)
						}
					}, D.b2FixtureDef = function() {
						this.filter = new B
					}, D.prototype.b2FixtureDef = function() {
						this.shape = null, this.userData = null, this.friction = .2, this.restitution = 0, this.density = 0, this.filter.categoryBits = 1, this.filter.maskBits = 65535, this.filter.groupIndex = 0, this.isSensor = !1
					}, E.b2Island = function() {}, E.prototype.b2Island = function() {
						this.m_bodies = new c, this.m_contacts = new c, this.m_joints = new c
					}, E.prototype.Initialize = function(a, b, c, d, e, f) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = 0);
						var g = 0;
						for (this.m_bodyCapacity = a, this.m_contactCapacity = b, this.m_jointCapacity = c, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_allocator = d, this.m_listener = e, this.m_contactSolver = f, g = this.m_bodies.length; a > g; g++) this.m_bodies[g] = null;
						for (g = this.m_contacts.length; b > g; g++) this.m_contacts[g] = null;
						for (g = this.m_joints.length; c > g; g++) this.m_joints[g] = null
					}, E.prototype.Clear = function() {
						this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0
					}, E.prototype.Solve = function(a, c, d) {
						var e, f, g = 0,
							h = 0;
						for (g = 0; g < this.m_bodyCount; ++g) e = this.m_bodies[g], e.GetType() == t.b2_dynamicBody && (e.m_linearVelocity.x += a.dt * (c.x + e.m_invMass * e.m_force.x), e.m_linearVelocity.y += a.dt * (c.y + e.m_invMass * e.m_force.y), e.m_angularVelocity += a.dt * e.m_invI * e.m_torque, e.m_linearVelocity.Multiply(b.Clamp(1 - a.dt * e.m_linearDamping, 0, 1)), e.m_angularVelocity *= b.Clamp(1 - a.dt * e.m_angularDamping, 0, 1));
						this.m_contactSolver.Initialize(a, this.m_contacts, this.m_contactCount, this.m_allocator);
						var j = this.m_contactSolver;
						for (j.InitVelocityConstraints(a), g = 0; g < this.m_jointCount; ++g) f = this.m_joints[g], f.InitVelocityConstraints(a);
						for (g = 0; g < a.velocityIterations; ++g) {
							for (h = 0; h < this.m_jointCount; ++h) f = this.m_joints[h], f.SolveVelocityConstraints(a);
							j.SolveVelocityConstraints()
						}
						for (g = 0; g < this.m_jointCount; ++g) f = this.m_joints[g], f.FinalizeVelocityConstraints();
						for (j.FinalizeVelocityConstraints(), g = 0; g < this.m_bodyCount; ++g)
							if (e = this.m_bodies[g], e.GetType() != t.b2_staticBody) {
								var k = a.dt * e.m_linearVelocity.x,
									l = a.dt * e.m_linearVelocity.y;
								k * k + l * l > i.b2_maxTranslationSquared && (e.m_linearVelocity.Normalize(), e.m_linearVelocity.x *= i.b2_maxTranslation * a.inv_dt, e.m_linearVelocity.y *= i.b2_maxTranslation * a.inv_dt);
								var m = a.dt * e.m_angularVelocity;
								m * m > i.b2_maxRotationSquared && (e.m_angularVelocity = e.m_angularVelocity < 0 ? -i.b2_maxRotation * a.inv_dt : i.b2_maxRotation * a.inv_dt), e.m_sweep.c0.SetV(e.m_sweep.c), e.m_sweep.a0 = e.m_sweep.a, e.m_sweep.c.x += a.dt * e.m_linearVelocity.x, e.m_sweep.c.y += a.dt * e.m_linearVelocity.y, e.m_sweep.a += a.dt * e.m_angularVelocity, e.SynchronizeTransform()
							} for (g = 0; g < a.positionIterations; ++g) {
							var n = j.SolvePositionConstraints(i.b2_contactBaumgarte),
								o = !0;
							for (h = 0; h < this.m_jointCount; ++h) {
								f = this.m_joints[h];
								var p = f.SolvePositionConstraints(i.b2_contactBaumgarte);
								o = o && p
							}
							if (n && o) break
						}
						if (this.Report(j.m_constraints), d) {
							var q = Number.MAX_VALUE,
								r = i.b2_linearSleepTolerance * i.b2_linearSleepTolerance,
								s = i.b2_angularSleepTolerance * i.b2_angularSleepTolerance;
							for (g = 0; g < this.m_bodyCount; ++g) e = this.m_bodies[g], e.GetType() != t.b2_staticBody && (0 == (e.m_flags & t.e_allowSleepFlag) && (e.m_sleepTime = 0, q = 0), 0 == (e.m_flags & t.e_allowSleepFlag) || e.m_angularVelocity * e.m_angularVelocity > s || b.Dot(e.m_linearVelocity, e.m_linearVelocity) > r ? (e.m_sleepTime = 0, q = 0) : (e.m_sleepTime += a.dt, q = b.Min(q, e.m_sleepTime)));
							if (q >= i.b2_timeToSleep)
								for (g = 0; g < this.m_bodyCount; ++g) e = this.m_bodies[g], e.SetAwake(!1)
						}
					}, E.prototype.SolveTOI = function(a) {
						var b = 0,
							c = 0;
						this.m_contactSolver.Initialize(a, this.m_contacts, this.m_contactCount, this.m_allocator);
						var d = this.m_contactSolver;
						for (b = 0; b < this.m_jointCount; ++b) this.m_joints[b].InitVelocityConstraints(a);
						for (b = 0; b < a.velocityIterations; ++b)
							for (d.SolveVelocityConstraints(), c = 0; c < this.m_jointCount; ++c) this.m_joints[c].SolveVelocityConstraints(a);
						for (b = 0; b < this.m_bodyCount; ++b) {
							var e = this.m_bodies[b];
							if (e.GetType() != t.b2_staticBody) {
								var f = a.dt * e.m_linearVelocity.x,
									g = a.dt * e.m_linearVelocity.y;
								f * f + g * g > i.b2_maxTranslationSquared && (e.m_linearVelocity.Normalize(), e.m_linearVelocity.x *= i.b2_maxTranslation * a.inv_dt, e.m_linearVelocity.y *= i.b2_maxTranslation * a.inv_dt);
								var h = a.dt * e.m_angularVelocity;
								h * h > i.b2_maxRotationSquared && (e.m_angularVelocity = e.m_angularVelocity < 0 ? -i.b2_maxRotation * a.inv_dt : i.b2_maxRotation * a.inv_dt), e.m_sweep.c0.SetV(e.m_sweep.c), e.m_sweep.a0 = e.m_sweep.a, e.m_sweep.c.x += a.dt * e.m_linearVelocity.x, e.m_sweep.c.y += a.dt * e.m_linearVelocity.y, e.m_sweep.a += a.dt * e.m_angularVelocity, e.SynchronizeTransform()
							}
						}
						var j = .75;
						for (b = 0; b < a.positionIterations; ++b) {
							var k = d.SolvePositionConstraints(j),
								l = !0;
							for (c = 0; c < this.m_jointCount; ++c) {
								var m = this.m_joints[c].SolvePositionConstraints(i.b2_contactBaumgarte);
								l = l && m
							}
							if (k && l) break
						}
						this.Report(d.m_constraints)
					}, E.prototype.Report = function(a) {
						if (null != this.m_listener)
							for (var b = 0; b < this.m_contactCount; ++b) {
								for (var c = this.m_contacts[b], d = a[b], e = 0; e < d.pointCount; ++e) E.s_impulse.normalImpulses[e] = d.points[e].normalImpulse, E.s_impulse.tangentImpulses[e] = d.points[e].tangentImpulse;
								this.m_listener.PostSolve(c, E.s_impulse)
							}
					}, E.prototype.AddBody = function(a) {
						a.m_islandIndex = this.m_bodyCount, this.m_bodies[this.m_bodyCount++] = a
					}, E.prototype.AddContact = function(a) {
						this.m_contacts[this.m_contactCount++] = a
					}, E.prototype.AddJoint = function(a) {
						this.m_joints[this.m_jointCount++] = a
					}, a.postDefs.push(function() {
						a.Dynamics.b2Island.s_impulse = new w
					}), F.b2TimeStep = function() {}, F.prototype.Set = function(a) {
						this.dt = a.dt, this.inv_dt = a.inv_dt, this.positionIterations = a.positionIterations, this.velocityIterations = a.velocityIterations, this.warmStarting = a.warmStarting
					}, G.b2World = function() {
						this.s_stack = new c, this.m_contactManager = new y, this.m_contactSolver = new J, this.m_island = new E
					}, G.prototype.b2World = function(a, b) {
						this.m_destructionListener = null, this.m_debugDraw = null, this.m_bodyList = null, this.m_contactList = null, this.m_jointList = null, this.m_controllerList = null, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_controllerCount = 0, G.m_warmStarting = !0, G.m_continuousPhysics = !0, this.m_allowSleep = b, this.m_gravity = a, this.m_inv_dt0 = 0, this.m_contactManager.m_world = this;
						var c = new u;
						this.m_groundBody = this.CreateBody(c)
					}, G.prototype.SetDestructionListener = function(a) {
						this.m_destructionListener = a
					}, G.prototype.SetContactFilter = function(a) {
						this.m_contactManager.m_contactFilter = a
					}, G.prototype.SetContactListener = function(a) {
						this.m_contactManager.m_contactListener = a
					}, G.prototype.SetDebugDraw = function(a) {
						this.m_debugDraw = a
					}, G.prototype.SetBroadPhase = function(a) {
						var b = this.m_contactManager.m_broadPhase;
						this.m_contactManager.m_broadPhase = a;
						for (var c = this.m_bodyList; c; c = c.m_next)
							for (var d = c.m_fixtureList; d; d = d.m_next) d.m_proxy = a.CreateProxy(b.GetFatAABB(d.m_proxy), d)
					}, G.prototype.Validate = function() {
						this.m_contactManager.m_broadPhase.Validate()
					}, G.prototype.GetProxyCount = function() {
						return this.m_contactManager.m_broadPhase.GetProxyCount()
					}, G.prototype.CreateBody = function(a) {
						if (1 == this.IsLocked()) return null;
						var b = new t(a, this);
						return b.m_prev = null, b.m_next = this.m_bodyList, this.m_bodyList && (this.m_bodyList.m_prev = b), this.m_bodyList = b, ++this.m_bodyCount, b
					}, G.prototype.DestroyBody = function(a) {
						if (1 != this.IsLocked()) {
							for (var b = a.m_jointList; b;) {
								var c = b;
								b = b.next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(c.joint), this.DestroyJoint(c.joint)
							}
							for (var d = a.m_controllerList; d;) {
								var e = d;
								d = d.nextController, e.controller.RemoveBody(a)
							}
							for (var f = a.m_contactList; f;) {
								var g = f;
								f = f.next, this.m_contactManager.Destroy(g.contact)
							}
							a.m_contactList = null;
							for (var h = a.m_fixtureList; h;) {
								var i = h;
								h = h.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(i), i.DestroyProxy(this.m_contactManager.m_broadPhase), i.Destroy()
							}
							a.m_fixtureList = null, a.m_fixtureCount = 0, a.m_prev && (a.m_prev.m_next = a.m_next), a.m_next && (a.m_next.m_prev = a.m_prev), a == this.m_bodyList && (this.m_bodyList = a.m_next), --this.m_bodyCount
						}
					}, G.prototype.CreateJoint = function(a) {
						var b = K.Create(a, null);
						b.m_prev = null, b.m_next = this.m_jointList, this.m_jointList && (this.m_jointList.m_prev = b), this.m_jointList = b, ++this.m_jointCount, b.m_edgeA.joint = b, b.m_edgeA.other = b.m_bodyB, b.m_edgeA.prev = null, b.m_edgeA.next = b.m_bodyA.m_jointList, b.m_bodyA.m_jointList && (b.m_bodyA.m_jointList.prev = b.m_edgeA), b.m_bodyA.m_jointList = b.m_edgeA, b.m_edgeB.joint = b, b.m_edgeB.other = b.m_bodyA, b.m_edgeB.prev = null, b.m_edgeB.next = b.m_bodyB.m_jointList, b.m_bodyB.m_jointList && (b.m_bodyB.m_jointList.prev = b.m_edgeB), b.m_bodyB.m_jointList = b.m_edgeB;
						var c = a.bodyA,
							d = a.bodyB;
						if (0 == a.collideConnected)
							for (var e = d.GetContactList(); e;) e.other == c && e.contact.FlagForFiltering(), e = e.next;
						return b
					}, G.prototype.DestroyJoint = function(a) {
						var b = a.m_collideConnected;
						a.m_prev && (a.m_prev.m_next = a.m_next), a.m_next && (a.m_next.m_prev = a.m_prev), a == this.m_jointList && (this.m_jointList = a.m_next);
						var c = a.m_bodyA,
							d = a.m_bodyB;
						if (c.SetAwake(!0), d.SetAwake(!0), a.m_edgeA.prev && (a.m_edgeA.prev.next = a.m_edgeA.next), a.m_edgeA.next && (a.m_edgeA.next.prev = a.m_edgeA.prev), a.m_edgeA == c.m_jointList && (c.m_jointList = a.m_edgeA.next), a.m_edgeA.prev = null, a.m_edgeA.next = null, a.m_edgeB.prev && (a.m_edgeB.prev.next = a.m_edgeB.next), a.m_edgeB.next && (a.m_edgeB.next.prev = a.m_edgeB.prev), a.m_edgeB == d.m_jointList && (d.m_jointList = a.m_edgeB.next), a.m_edgeB.prev = null, a.m_edgeB.next = null, K.Destroy(a, null), --this.m_jointCount, 0 == b)
							for (var e = d.GetContactList(); e;) e.other == c && e.contact.FlagForFiltering(), e = e.next
					}, G.prototype.AddController = function(a) {
						return a.m_next = this.m_controllerList, a.m_prev = null, this.m_controllerList = a, a.m_world = this, this.m_controllerCount++, a
					}, G.prototype.RemoveController = function(a) {
						a.m_prev && (a.m_prev.m_next = a.m_next), a.m_next && (a.m_next.m_prev = a.m_prev), this.m_controllerList == a && (this.m_controllerList = a.m_next), this.m_controllerCount--
					}, G.prototype.CreateController = function(a) {
						if (a.m_world != this) throw new Error("Controller can only be a member of one world");
						return a.m_next = this.m_controllerList, a.m_prev = null, this.m_controllerList && (this.m_controllerList.m_prev = a), this.m_controllerList = a, ++this.m_controllerCount, a.m_world = this, a
					}, G.prototype.DestroyController = function(a) {
						a.Clear(), a.m_next && (a.m_next.m_prev = a.m_prev), a.m_prev && (a.m_prev.m_next = a.m_next), a == this.m_controllerList && (this.m_controllerList = a.m_next), --this.m_controllerCount
					}, G.prototype.SetWarmStarting = function(a) {
						G.m_warmStarting = a
					}, G.prototype.SetContinuousPhysics = function(a) {
						G.m_continuousPhysics = a
					}, G.prototype.GetBodyCount = function() {
						return this.m_bodyCount
					}, G.prototype.GetJointCount = function() {
						return this.m_jointCount
					}, G.prototype.GetContactCount = function() {
						return this.m_contactCount
					}, G.prototype.SetGravity = function(a) {
						this.m_gravity = a
					}, G.prototype.GetGravity = function() {
						return this.m_gravity
					}, G.prototype.GetGroundBody = function() {
						return this.m_groundBody
					}, G.prototype.Step = function(a, b, c) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = 0), this.m_flags & G.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~G.e_newFixture), this.m_flags |= G.e_locked;
						var d = G.s_timestep2;
						d.dt = a, d.velocityIterations = b, d.positionIterations = c, d.inv_dt = a > 0 ? 1 / a : 0, d.dtRatio = this.m_inv_dt0 * a, d.warmStarting = G.m_warmStarting, this.m_contactManager.Collide(), d.dt > 0 && this.Solve(d), G.m_continuousPhysics && d.dt > 0 && this.SolveTOI(d), d.dt > 0 && (this.m_inv_dt0 = d.inv_dt), this.m_flags &= ~G.e_locked
					}, G.prototype.ClearForces = function() {
						for (var a = this.m_bodyList; a; a = a.m_next) a.m_force.SetZero(), a.m_torque = 0
					}, G.prototype.DrawDebugData = function() {
						if (null != this.m_debugDraw) {
							this.m_debugDraw.m_sprite.graphics.clear();
							var a, b, c, d, e, f, i = this.m_debugDraw.GetFlags(),
								k = (new g, new g, new g, new j, new j, [new g, new g, new g, new g]),
								l = new h(0, 0, 0);
							if (i & z.e_shapeBit)
								for (a = this.m_bodyList; a; a = a.m_next)
									for (f = a.m_xf, b = a.GetFixtureList(); b; b = b.m_next) c = b.GetShape(), 0 == a.IsActive() ? (l.Set(.5, .5, .3), this.DrawShape(c, f, l)) : a.GetType() == t.b2_staticBody ? (l.Set(.5, .9, .5), this.DrawShape(c, f, l)) : a.GetType() == t.b2_kinematicBody ? (l.Set(.5, .5, .9), this.DrawShape(c, f, l)) : 0 == a.IsAwake() ? (l.Set(.6, .6, .6), this.DrawShape(c, f, l)) : (l.Set(.9, .7, .7), this.DrawShape(c, f, l));
							if (i & z.e_jointBit)
								for (d = this.m_jointList; d; d = d.m_next) this.DrawJoint(d);
							if (i & z.e_controllerBit)
								for (var m = this.m_controllerList; m; m = m.m_next) m.Draw(this.m_debugDraw);
							if (i & z.e_pairBit) {
								l.Set(.3, .9, .9);
								for (var n = this.m_contactManager.m_contactList; n; n = n.GetNext()) {
									var o = n.GetFixtureA(),
										p = n.GetFixtureB(),
										q = o.GetAABB().GetCenter(),
										r = p.GetAABB().GetCenter();
									this.m_debugDraw.DrawSegment(q, r, l)
								}
							}
							if (i & z.e_aabbBit)
								for (e = this.m_contactManager.m_broadPhase, k = [new g, new g, new g, new g], a = this.m_bodyList; a; a = a.GetNext())
									if (0 != a.IsActive())
										for (b = a.GetFixtureList(); b; b = b.GetNext()) {
											var s = e.GetFatAABB(b.m_proxy);
											k[0].Set(s.lowerBound.x, s.lowerBound.y), k[1].Set(s.upperBound.x, s.lowerBound.y), k[2].Set(s.upperBound.x, s.upperBound.y), k[3].Set(s.lowerBound.x, s.upperBound.y), this.m_debugDraw.DrawPolygon(k, 4, l)
										}
							if (i & z.e_centerOfMassBit)
								for (a = this.m_bodyList; a; a = a.m_next) f = G.s_xf, f.R = a.m_xf.R, f.position = a.GetWorldCenter(), this.m_debugDraw.DrawTransform(f)
						}
					}, G.prototype.QueryAABB = function(a, b) {
						function c(b) {
							return a(e.GetUserData(b))
						}
						var d = this,
							e = d.m_contactManager.m_broadPhase;
						e.Query(c, b)
					}, G.prototype.QueryShape = function(a, b, c) {
						function d(d) {
							var e = g.GetUserData(d) instanceof C ? g.GetUserData(d) : null;
							return s.TestOverlap(b, c, e.GetShape(), e.GetBody().GetTransform()) ? a(e) : !0
						}
						var e = this;
						void 0 === c && (c = null), null == c && (c = new f, c.SetIdentity());
						var g = e.m_contactManager.m_broadPhase,
							h = new j;
						b.ComputeAABB(h, c), g.Query(d, h)
					}, G.prototype.QueryPoint = function(a, b) {
						function c(c) {
							var d = e.GetUserData(c) instanceof C ? e.GetUserData(c) : null;
							return d.TestPoint(b) ? a(d) : !0
						}
						var d = this,
							e = d.m_contactManager.m_broadPhase,
							f = new j;
						f.lowerBound.Set(b.x - i.b2_linearSlop, b.y - i.b2_linearSlop), f.upperBound.Set(b.x + i.b2_linearSlop, b.y + i.b2_linearSlop), e.Query(c, f)
					}, G.prototype.RayCast = function(a, b, c) {
						function d(d, e) {
							var i = f.GetUserData(e),
								j = i instanceof C ? i : null,
								k = j.RayCast(h, d);
							if (k) {
								var l = h.fraction,
									m = new g((1 - l) * b.x + l * c.x, (1 - l) * b.y + l * c.y);
								return a(j, m, h.normal, l)
							}
							return d.maxFraction
						}
						var e = this,
							f = e.m_contactManager.m_broadPhase,
							h = new n,
							i = new m(b, c);
						f.RayCast(d, i)
					}, G.prototype.RayCastOne = function(a, b) {
						function c(a, b, c, e) {
							return void 0 === e && (e = 0), d = a, e
						}
						var d, e = this;
						return e.RayCast(c, a, b), d
					}, G.prototype.RayCastAll = function(a, b) {
						function d(a, b, c, d) {
							return void 0 === d && (d = 0), f[f.length] = a, 1
						}
						var e = this,
							f = new c;
						return e.RayCast(d, a, b), f
					}, G.prototype.GetBodyList = function() {
						return this.m_bodyList
					}, G.prototype.GetJointList = function() {
						return this.m_jointList
					}, G.prototype.GetContactList = function() {
						return this.m_contactList
					}, G.prototype.IsLocked = function() {
						return (this.m_flags & G.e_locked) > 0
					}, G.prototype.Solve = function(a) {
						for (var b, c = this.m_controllerList; c; c = c.m_next) c.Step(a);
						var d = this.m_island;
						for (d.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver), b = this.m_bodyList; b; b = b.m_next) b.m_flags &= ~t.e_islandFlag;
						for (var e = this.m_contactList; e; e = e.m_next) e.m_flags &= ~H.e_islandFlag;
						for (var f = this.m_jointList; f; f = f.m_next) f.m_islandFlag = !1;
						for (var g = (parseInt(this.m_bodyCount), this.s_stack), h = this.m_bodyList; h; h = h.m_next)
							if (!(h.m_flags & t.e_islandFlag) && 0 != h.IsAwake() && 0 != h.IsActive() && h.GetType() != t.b2_staticBody) {
								d.Clear();
								var i = 0;
								for (g[i++] = h, h.m_flags |= t.e_islandFlag; i > 0;)
									if (b = g[--i], d.AddBody(b), 0 == b.IsAwake() && b.SetAwake(!0), b.GetType() != t.b2_staticBody) {
										for (var j, k = b.m_contactList; k; k = k.next) k.contact.m_flags & H.e_islandFlag || 1 != k.contact.IsSensor() && 0 != k.contact.IsEnabled() && 0 != k.contact.IsTouching() && (d.AddContact(k.contact), k.contact.m_flags |= H.e_islandFlag, j = k.other, j.m_flags & t.e_islandFlag || (g[i++] = j, j.m_flags |= t.e_islandFlag));
										for (var l = b.m_jointList; l; l = l.next) 1 != l.joint.m_islandFlag && (j = l.other, 0 != j.IsActive() && (d.AddJoint(l.joint), l.joint.m_islandFlag = !0, j.m_flags & t.e_islandFlag || (g[i++] = j, j.m_flags |= t.e_islandFlag)))
									} d.Solve(a, this.m_gravity, this.m_allowSleep);
								for (var m = 0; m < d.m_bodyCount; ++m) b = d.m_bodies[m], b.GetType() == t.b2_staticBody && (b.m_flags &= ~t.e_islandFlag)
							} for (m = 0; m < g.length && g[m]; ++m) g[m] = null;
						for (b = this.m_bodyList; b; b = b.m_next) 0 != b.IsAwake() && 0 != b.IsActive() && b.GetType() != t.b2_staticBody && b.SynchronizeFixtures();
						this.m_contactManager.FindNewContacts()
					}, G.prototype.SolveTOI = function(a) {
						var b, c, d, e, f, g, h, j = this.m_island;
						j.Initialize(this.m_bodyCount, i.b2_maxTOIContactsPerIsland, i.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
						var k = G.s_queue;
						for (b = this.m_bodyList; b; b = b.m_next) b.m_flags &= ~t.e_islandFlag, b.m_sweep.t0 = 0;
						var l;
						for (l = this.m_contactList; l; l = l.m_next) l.m_flags &= ~(H.e_toiFlag | H.e_islandFlag);
						for (h = this.m_jointList; h; h = h.m_next) h.m_islandFlag = !1;
						for (;;) {
							var m = null,
								n = 1;
							for (l = this.m_contactList; l; l = l.m_next)
								if (1 != l.IsSensor() && 0 != l.IsEnabled() && 0 != l.IsContinuous()) {
									var o = 1;
									if (l.m_flags & H.e_toiFlag) o = l.m_toi;
									else {
										if (c = l.m_fixtureA, d = l.m_fixtureB, e = c.m_body, f = d.m_body, !(e.GetType() == t.b2_dynamicBody && 0 != e.IsAwake() || f.GetType() == t.b2_dynamicBody && 0 != f.IsAwake())) continue;
										var p = e.m_sweep.t0;
										e.m_sweep.t0 < f.m_sweep.t0 ? (p = f.m_sweep.t0, e.m_sweep.Advance(p)) : f.m_sweep.t0 < e.m_sweep.t0 && (p = e.m_sweep.t0, f.m_sweep.Advance(p)), o = l.ComputeTOI(e.m_sweep, f.m_sweep), i.b2Assert(o >= 0 && 1 >= o), o > 0 && 1 > o && (o = (1 - o) * p + o, o > 1 && (o = 1)), l.m_toi = o, l.m_flags |= H.e_toiFlag
									}
									Number.MIN_VALUE < o && n > o && (m = l, n = o)
								} if (null == m || 1 - 100 * Number.MIN_VALUE < n) break;
							if (c = m.m_fixtureA, d = m.m_fixtureB, e = c.m_body, f = d.m_body, G.s_backupA.Set(e.m_sweep), G.s_backupB.Set(f.m_sweep), e.Advance(n), f.Advance(n), m.Update(this.m_contactManager.m_contactListener), m.m_flags &= ~H.e_toiFlag, 1 != m.IsSensor() && 0 != m.IsEnabled()) {
								if (0 != m.IsTouching()) {
									var q = e;
									q.GetType() != t.b2_dynamicBody && (q = f), j.Clear();
									var r = 0,
										s = 0;
									for (k[r + s++] = q, q.m_flags |= t.e_islandFlag; s > 0;)
										if (b = k[r++], --s, j.AddBody(b), 0 == b.IsAwake() && b.SetAwake(!0), b.GetType() == t.b2_dynamicBody) {
											for (g = b.m_contactList; g && j.m_contactCount != j.m_contactCapacity; g = g.next)
												if (!(g.contact.m_flags & H.e_islandFlag) && 1 != g.contact.IsSensor() && 0 != g.contact.IsEnabled() && 0 != g.contact.IsTouching()) {
													j.AddContact(g.contact), g.contact.m_flags |= H.e_islandFlag;
													var u = g.other;
													u.m_flags & t.e_islandFlag || (u.GetType() != t.b2_staticBody && (u.Advance(n), u.SetAwake(!0)), k[r + s] = u, ++s, u.m_flags |= t.e_islandFlag)
												} for (var v = b.m_jointList; v; v = v.next) j.m_jointCount != j.m_jointCapacity && 1 != v.joint.m_islandFlag && (u = v.other, 0 != u.IsActive() && (j.AddJoint(v.joint), v.joint.m_islandFlag = !0, u.m_flags & t.e_islandFlag || (u.GetType() != t.b2_staticBody && (u.Advance(n), u.SetAwake(!0)), k[r + s] = u, ++s, u.m_flags |= t.e_islandFlag)))
										} var w = G.s_timestep;
									w.warmStarting = !1, w.dt = (1 - n) * a.dt, w.inv_dt = 1 / w.dt, w.dtRatio = 0, w.velocityIterations = a.velocityIterations, w.positionIterations = a.positionIterations, j.SolveTOI(w);
									var x = 0;
									for (x = 0; x < j.m_bodyCount; ++x)
										if (b = j.m_bodies[x], b.m_flags &= ~t.e_islandFlag, 0 != b.IsAwake() && b.GetType() == t.b2_dynamicBody)
											for (b.SynchronizeFixtures(), g = b.m_contactList; g; g = g.next) g.contact.m_flags &= ~H.e_toiFlag;
									for (x = 0; x < j.m_contactCount; ++x) l = j.m_contacts[x], l.m_flags &= ~(H.e_toiFlag | H.e_islandFlag);
									for (x = 0; x < j.m_jointCount; ++x) h = j.m_joints[x], h.m_islandFlag = !1;
									this.m_contactManager.FindNewContacts()
								}
							} else e.m_sweep.Set(G.s_backupA), f.m_sweep.Set(G.s_backupB), e.SynchronizeTransform(), f.SynchronizeTransform()
						}
					}, G.prototype.DrawJoint = function(a) {
						var b = a.GetBodyA(),
							c = a.GetBodyB(),
							d = b.m_xf,
							e = c.m_xf,
							f = d.position,
							g = e.position,
							h = a.GetAnchorA(),
							i = a.GetAnchorB(),
							j = G.s_jointColor;
						switch (a.m_type) {
							case K.e_distanceJoint:
								this.m_debugDraw.DrawSegment(h, i, j);
								break;
							case K.e_pulleyJoint:
								var k = a instanceof L ? a : null,
									l = k.GetGroundAnchorA(),
									m = k.GetGroundAnchorB();
								this.m_debugDraw.DrawSegment(l, h, j), this.m_debugDraw.DrawSegment(m, i, j), this.m_debugDraw.DrawSegment(l, m, j);
								break;
							case K.e_mouseJoint:
								this.m_debugDraw.DrawSegment(h, i, j);
								break;
							default:
								b != this.m_groundBody && this.m_debugDraw.DrawSegment(f, h, j), this.m_debugDraw.DrawSegment(h, i, j), c != this.m_groundBody && this.m_debugDraw.DrawSegment(g, i, j)
						}
					}, G.prototype.DrawShape = function(a, d, e) {
						switch (a.m_type) {
							case s.e_circleShape:
								var f = a instanceof o ? a : null,
									g = b.MulX(d, f.m_p),
									h = f.m_radius,
									i = d.R.col1;
								this.m_debugDraw.DrawSolidCircle(g, h, i, e);
								break;
							case s.e_polygonShape:
								var j = 0,
									k = a instanceof r ? a : null,
									l = parseInt(k.GetVertexCount()),
									m = k.GetVertices(),
									n = new c(l);
								for (j = 0; l > j; ++j) n[j] = b.MulX(d, m[j]);
								this.m_debugDraw.DrawSolidPolygon(n, l, e);
								break;
							case s.e_edgeShape:
								var q = a instanceof p ? a : null;
								this.m_debugDraw.DrawSegment(b.MulX(d, q.GetVertex1()), b.MulX(d, q.GetVertex2()), e)
						}
					}, a.postDefs.push(function() {
						a.Dynamics.b2World.s_timestep2 = new F, a.Dynamics.b2World.s_xf = new f, a.Dynamics.b2World.s_backupA = new e, a.Dynamics.b2World.s_backupB = new e, a.Dynamics.b2World.s_timestep = new F, a.Dynamics.b2World.s_queue = new c, a.Dynamics.b2World.s_jointColor = new h(.5, .8, .8), a.Dynamics.b2World.e_newFixture = 1, a.Dynamics.b2World.e_locked = 2
					})
				}(),
				function() {
					{
						var b = a.Collision.Shapes.b2CircleShape,
							e = (a.Collision.Shapes.b2EdgeChainDef, a.Collision.Shapes.b2EdgeShape),
							f = (a.Collision.Shapes.b2MassData, a.Collision.Shapes.b2PolygonShape),
							g = a.Collision.Shapes.b2Shape,
							h = a.Dynamics.Contacts.b2CircleContact,
							i = a.Dynamics.Contacts.b2Contact,
							j = a.Dynamics.Contacts.b2ContactConstraint,
							k = a.Dynamics.Contacts.b2ContactConstraintPoint,
							l = a.Dynamics.Contacts.b2ContactEdge,
							m = a.Dynamics.Contacts.b2ContactFactory,
							n = a.Dynamics.Contacts.b2ContactRegister,
							o = a.Dynamics.Contacts.b2ContactResult,
							p = a.Dynamics.Contacts.b2ContactSolver,
							q = a.Dynamics.Contacts.b2EdgeAndCircleContact,
							r = a.Dynamics.Contacts.b2NullContact,
							s = a.Dynamics.Contacts.b2PolyAndCircleContact,
							t = a.Dynamics.Contacts.b2PolyAndEdgeContact,
							u = a.Dynamics.Contacts.b2PolygonContact,
							v = a.Dynamics.Contacts.b2PositionSolverManifold,
							w = a.Dynamics.b2Body,
							x = (a.Dynamics.b2BodyDef, a.Dynamics.b2ContactFilter, a.Dynamics.b2ContactImpulse, a.Dynamics.b2ContactListener, a.Dynamics.b2ContactManager, a.Dynamics.b2DebugDraw, a.Dynamics.b2DestructionListener, a.Dynamics.b2FilterData, a.Dynamics.b2Fixture, a.Dynamics.b2FixtureDef, a.Dynamics.b2Island, a.Dynamics.b2TimeStep),
							y = (a.Dynamics.b2World, a.Common.b2Color, a.Common.b2internal, a.Common.b2Settings),
							z = a.Common.Math.b2Mat22,
							A = (a.Common.Math.b2Mat33, a.Common.Math.b2Math),
							B = (a.Common.Math.b2Sweep, a.Common.Math.b2Transform, a.Common.Math.b2Vec2),
							C = (a.Common.Math.b2Vec3, a.Collision.b2AABB, a.Collision.b2Bound, a.Collision.b2BoundValues, a.Collision.b2Collision),
							D = a.Collision.b2ContactID,
							E = (a.Collision.b2ContactPoint, a.Collision.b2Distance, a.Collision.b2DistanceInput, a.Collision.b2DistanceOutput, a.Collision.b2DistanceProxy, a.Collision.b2DynamicTree, a.Collision.b2DynamicTreeBroadPhase, a.Collision.b2DynamicTreeNode, a.Collision.b2DynamicTreePair, a.Collision.b2Manifold),
							F = (a.Collision.b2ManifoldPoint, a.Collision.b2Point, a.Collision.b2RayCastInput, a.Collision.b2RayCastOutput, a.Collision.b2Segment, a.Collision.b2SeparationFunction, a.Collision.b2Simplex, a.Collision.b2SimplexCache, a.Collision.b2SimplexVertex, a.Collision.b2TimeOfImpact),
							G = a.Collision.b2TOIInput,
							H = a.Collision.b2WorldManifold;
						a.Collision.ClipVertex, a.Collision.Features, a.Collision.IBroadPhase
					}
					a.inherit(h, a.Dynamics.Contacts.b2Contact), h.prototype.__super = a.Dynamics.Contacts.b2Contact.prototype, h.b2CircleContact = function() {
						a.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
					}, h.Create = function() {
						return new h
					}, h.Destroy = function() {}, h.prototype.Reset = function(a, b) {
						this.__super.Reset.call(this, a, b)
					}, h.prototype.Evaluate = function() {
						var a = this.m_fixtureA.GetBody(),
							c = this.m_fixtureB.GetBody();
						C.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape() instanceof b ? this.m_fixtureA.GetShape() : null, a.m_xf, this.m_fixtureB.GetShape() instanceof b ? this.m_fixtureB.GetShape() : null, c.m_xf)
					}, i.b2Contact = function() {
						this.m_nodeA = new l, this.m_nodeB = new l, this.m_manifold = new E, this.m_oldManifold = new E
					}, i.prototype.GetManifold = function() {
						return this.m_manifold
					}, i.prototype.GetWorldManifold = function(a) {
						var b = this.m_fixtureA.GetBody(),
							c = this.m_fixtureB.GetBody(),
							d = this.m_fixtureA.GetShape(),
							e = this.m_fixtureB.GetShape();
						a.Initialize(this.m_manifold, b.GetTransform(), d.m_radius, c.GetTransform(), e.m_radius)
					}, i.prototype.IsTouching = function() {
						return (this.m_flags & i.e_touchingFlag) == i.e_touchingFlag
					}, i.prototype.IsContinuous = function() {
						return (this.m_flags & i.e_continuousFlag) == i.e_continuousFlag
					}, i.prototype.SetSensor = function(a) {
						a ? this.m_flags |= i.e_sensorFlag : this.m_flags &= ~i.e_sensorFlag
					}, i.prototype.IsSensor = function() {
						return (this.m_flags & i.e_sensorFlag) == i.e_sensorFlag
					}, i.prototype.SetEnabled = function(a) {
						a ? this.m_flags |= i.e_enabledFlag : this.m_flags &= ~i.e_enabledFlag
					}, i.prototype.IsEnabled = function() {
						return (this.m_flags & i.e_enabledFlag) == i.e_enabledFlag
					}, i.prototype.GetNext = function() {
						return this.m_next
					}, i.prototype.GetFixtureA = function() {
						return this.m_fixtureA
					}, i.prototype.GetFixtureB = function() {
						return this.m_fixtureB
					}, i.prototype.FlagForFiltering = function() {
						this.m_flags |= i.e_filterFlag
					}, i.prototype.b2Contact = function() {}, i.prototype.Reset = function(a, b) {
						if (void 0 === a && (a = null), void 0 === b && (b = null), this.m_flags = i.e_enabledFlag, !a || !b) return this.m_fixtureA = null, this.m_fixtureB = null, void 0;
						(a.IsSensor() || b.IsSensor()) && (this.m_flags |= i.e_sensorFlag);
						var c = a.GetBody(),
							d = b.GetBody();
						(c.GetType() != w.b2_dynamicBody || c.IsBullet() || d.GetType() != w.b2_dynamicBody || d.IsBullet()) && (this.m_flags |= i.e_continuousFlag), this.m_fixtureA = a, this.m_fixtureB = b, this.m_manifold.m_pointCount = 0, this.m_prev = null, this.m_next = null, this.m_nodeA.contact = null, this.m_nodeA.prev = null, this.m_nodeA.next = null, this.m_nodeA.other = null, this.m_nodeB.contact = null, this.m_nodeB.prev = null, this.m_nodeB.next = null, this.m_nodeB.other = null
					}, i.prototype.Update = function(a) {
						var b = this.m_oldManifold;
						this.m_oldManifold = this.m_manifold, this.m_manifold = b, this.m_flags |= i.e_enabledFlag;
						var c = !1,
							d = (this.m_flags & i.e_touchingFlag) == i.e_touchingFlag,
							e = this.m_fixtureA.m_body,
							f = this.m_fixtureB.m_body,
							h = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
						if (this.m_flags & i.e_sensorFlag) {
							if (h) {
								var j = this.m_fixtureA.GetShape(),
									k = this.m_fixtureB.GetShape(),
									l = e.GetTransform(),
									m = f.GetTransform();
								c = g.TestOverlap(j, l, k, m)
							}
							this.m_manifold.m_pointCount = 0
						} else {
							if (e.GetType() != w.b2_dynamicBody || e.IsBullet() || f.GetType() != w.b2_dynamicBody || f.IsBullet() ? this.m_flags |= i.e_continuousFlag : this.m_flags &= ~i.e_continuousFlag, h) {
								this.Evaluate(), c = this.m_manifold.m_pointCount > 0;
								for (var n = 0; n < this.m_manifold.m_pointCount; ++n) {
									var o = this.m_manifold.m_points[n];
									o.m_normalImpulse = 0, o.m_tangentImpulse = 0;
									for (var p = o.m_id, q = 0; q < this.m_oldManifold.m_pointCount; ++q) {
										var r = this.m_oldManifold.m_points[q];
										if (r.m_id.key == p.key) {
											o.m_normalImpulse = r.m_normalImpulse, o.m_tangentImpulse = r.m_tangentImpulse;
											break
										}
									}
								}
							} else this.m_manifold.m_pointCount = 0;
							c != d && (e.SetAwake(!0), f.SetAwake(!0))
						}
						c ? this.m_flags |= i.e_touchingFlag : this.m_flags &= ~i.e_touchingFlag, 0 == d && 1 == c && a.BeginContact(this), 1 == d && 0 == c && a.EndContact(this), 0 == (this.m_flags & i.e_sensorFlag) && a.PreSolve(this, this.m_oldManifold)
					}, i.prototype.Evaluate = function() {}, i.prototype.ComputeTOI = function(a, b) {
						return i.s_input.proxyA.Set(this.m_fixtureA.GetShape()), i.s_input.proxyB.Set(this.m_fixtureB.GetShape()), i.s_input.sweepA = a, i.s_input.sweepB = b, i.s_input.tolerance = y.b2_linearSlop, F.TimeOfImpact(i.s_input)
					}, a.postDefs.push(function() {
						a.Dynamics.Contacts.b2Contact.e_sensorFlag = 1, a.Dynamics.Contacts.b2Contact.e_continuousFlag = 2, a.Dynamics.Contacts.b2Contact.e_islandFlag = 4, a.Dynamics.Contacts.b2Contact.e_toiFlag = 8, a.Dynamics.Contacts.b2Contact.e_touchingFlag = 16, a.Dynamics.Contacts.b2Contact.e_enabledFlag = 32, a.Dynamics.Contacts.b2Contact.e_filterFlag = 64, a.Dynamics.Contacts.b2Contact.s_input = new G
					}), j.b2ContactConstraint = function() {
						this.localPlaneNormal = new B, this.localPoint = new B, this.normal = new B, this.normalMass = new z, this.K = new z
					}, j.prototype.b2ContactConstraint = function() {
						this.points = new c(y.b2_maxManifoldPoints);
						for (var a = 0; a < y.b2_maxManifoldPoints; a++) this.points[a] = new k
					}, k.b2ContactConstraintPoint = function() {
						this.localPoint = new B, this.rA = new B, this.rB = new B
					}, l.b2ContactEdge = function() {}, m.b2ContactFactory = function() {}, m.prototype.b2ContactFactory = function(a) {
						this.m_allocator = a, this.InitializeRegisters()
					}, m.prototype.AddType = function(a, b, c, d) {
						void 0 === c && (c = 0), void 0 === d && (d = 0), this.m_registers[c][d].createFcn = a, this.m_registers[c][d].destroyFcn = b, this.m_registers[c][d].primary = !0, c != d && (this.m_registers[d][c].createFcn = a, this.m_registers[d][c].destroyFcn = b, this.m_registers[d][c].primary = !1)
					}, m.prototype.InitializeRegisters = function() {
						this.m_registers = new c(g.e_shapeTypeCount);
						for (var a = 0; a < g.e_shapeTypeCount; a++) {
							this.m_registers[a] = new c(g.e_shapeTypeCount);
							for (var b = 0; b < g.e_shapeTypeCount; b++) this.m_registers[a][b] = new n
						}
						this.AddType(h.Create, h.Destroy, g.e_circleShape, g.e_circleShape), this.AddType(s.Create, s.Destroy, g.e_polygonShape, g.e_circleShape), this.AddType(u.Create, u.Destroy, g.e_polygonShape, g.e_polygonShape), this.AddType(q.Create, q.Destroy, g.e_edgeShape, g.e_circleShape), this.AddType(t.Create, t.Destroy, g.e_polygonShape, g.e_edgeShape)
					}, m.prototype.Create = function(a, b) {
						var c, d = parseInt(a.GetType()),
							e = parseInt(b.GetType()),
							f = this.m_registers[d][e];
						if (f.pool) return c = f.pool, f.pool = c.m_next, f.poolCount--, c.Reset(a, b), c;
						var g = f.createFcn;
						return null != g ? f.primary ? (c = g(this.m_allocator), c.Reset(a, b), c) : (c = g(this.m_allocator), c.Reset(b, a), c) : null
					}, m.prototype.Destroy = function(a) {
						a.m_manifold.m_pointCount > 0 && (a.m_fixtureA.m_body.SetAwake(!0), a.m_fixtureB.m_body.SetAwake(!0));
						var b = parseInt(a.m_fixtureA.GetType()),
							c = parseInt(a.m_fixtureB.GetType()),
							d = this.m_registers[b][c];
						d.poolCount++, a.m_next = d.pool, d.pool = a;
						var e = d.destroyFcn;
						e(a, this.m_allocator)
					}, n.b2ContactRegister = function() {}, o.b2ContactResult = function() {
						this.position = new B, this.normal = new B, this.id = new D
					}, p.b2ContactSolver = function() {
						this.m_step = new x, this.m_constraints = new c
					}, p.prototype.b2ContactSolver = function() {}, p.prototype.Initialize = function(a, b, c, d) {
						void 0 === c && (c = 0);
						var e;
						this.m_step.Set(a), this.m_allocator = d;
						var f = 0;
						for (this.m_constraintCount = c; this.m_constraints.length < this.m_constraintCount;) this.m_constraints[this.m_constraints.length] = new j;
						for (f = 0; c > f; ++f) {
							e = b[f];
							var g = e.m_fixtureA,
								h = e.m_fixtureB,
								i = g.m_shape,
								k = h.m_shape,
								l = i.m_radius,
								m = k.m_radius,
								n = g.m_body,
								o = h.m_body,
								q = e.GetManifold(),
								r = y.b2MixFriction(g.GetFriction(), h.GetFriction()),
								s = y.b2MixRestitution(g.GetRestitution(), h.GetRestitution()),
								t = n.m_linearVelocity.x,
								u = n.m_linearVelocity.y,
								v = o.m_linearVelocity.x,
								w = o.m_linearVelocity.y,
								x = n.m_angularVelocity,
								z = o.m_angularVelocity;
							y.b2Assert(q.m_pointCount > 0), p.s_worldManifold.Initialize(q, n.m_xf, l, o.m_xf, m);
							var A = p.s_worldManifold.m_normal.x,
								B = p.s_worldManifold.m_normal.y,
								C = this.m_constraints[f];
							C.bodyA = n, C.bodyB = o, C.manifold = q, C.normal.x = A, C.normal.y = B, C.pointCount = q.m_pointCount, C.friction = r, C.restitution = s, C.localPlaneNormal.x = q.m_localPlaneNormal.x, C.localPlaneNormal.y = q.m_localPlaneNormal.y, C.localPoint.x = q.m_localPoint.x, C.localPoint.y = q.m_localPoint.y, C.radius = l + m, C.type = q.m_type;
							for (var D = 0; D < C.pointCount; ++D) {
								var E = q.m_points[D],
									F = C.points[D];
								F.normalImpulse = E.m_normalImpulse, F.tangentImpulse = E.m_tangentImpulse, F.localPoint.SetV(E.m_localPoint);
								var G = F.rA.x = p.s_worldManifold.m_points[D].x - n.m_sweep.c.x,
									H = F.rA.y = p.s_worldManifold.m_points[D].y - n.m_sweep.c.y,
									I = F.rB.x = p.s_worldManifold.m_points[D].x - o.m_sweep.c.x,
									J = F.rB.y = p.s_worldManifold.m_points[D].y - o.m_sweep.c.y,
									K = G * B - H * A,
									L = I * B - J * A;
								K *= K, L *= L;
								var M = n.m_invMass + o.m_invMass + n.m_invI * K + o.m_invI * L;
								F.normalMass = 1 / M;
								var N = n.m_mass * n.m_invMass + o.m_mass * o.m_invMass;
								N += n.m_mass * n.m_invI * K + o.m_mass * o.m_invI * L, F.equalizedMass = 1 / N;
								var O = B,
									P = -A,
									Q = G * P - H * O,
									R = I * P - J * O;
								Q *= Q, R *= R;
								var S = n.m_invMass + o.m_invMass + n.m_invI * Q + o.m_invI * R;
								F.tangentMass = 1 / S, F.velocityBias = 0;
								var T = v + -z * J - t - -x * H,
									U = w + z * I - u - x * G,
									V = C.normal.x * T + C.normal.y * U;
								V < -y.b2_velocityThreshold && (F.velocityBias += -C.restitution * V)
							}
							if (2 == C.pointCount) {
								var W = C.points[0],
									X = C.points[1],
									Y = n.m_invMass,
									Z = n.m_invI,
									$ = o.m_invMass,
									_ = o.m_invI,
									ab = W.rA.x * B - W.rA.y * A,
									bb = W.rB.x * B - W.rB.y * A,
									cb = X.rA.x * B - X.rA.y * A,
									db = X.rB.x * B - X.rB.y * A,
									eb = Y + $ + Z * ab * ab + _ * bb * bb,
									fb = Y + $ + Z * cb * cb + _ * db * db,
									gb = Y + $ + Z * ab * cb + _ * bb * db,
									hb = 100;
								hb * (eb * fb - gb * gb) > eb * eb ? (C.K.col1.Set(eb, gb), C.K.col2.Set(gb, fb), C.K.GetInverse(C.normalMass)) : C.pointCount = 1
							}
						}
					}, p.prototype.InitVelocityConstraints = function(a) {
						for (var b = 0; b < this.m_constraintCount; ++b) {
							var c = this.m_constraints[b],
								d = c.bodyA,
								e = c.bodyB,
								f = d.m_invMass,
								g = d.m_invI,
								h = e.m_invMass,
								i = e.m_invI,
								j = c.normal.x,
								k = c.normal.y,
								l = k,
								m = -j,
								n = 0,
								o = 0;
							if (a.warmStarting)
								for (o = c.pointCount, n = 0; o > n; ++n) {
									var p = c.points[n];
									p.normalImpulse *= a.dtRatio, p.tangentImpulse *= a.dtRatio;
									var q = p.normalImpulse * j + p.tangentImpulse * l,
										r = p.normalImpulse * k + p.tangentImpulse * m;
									d.m_angularVelocity -= g * (p.rA.x * r - p.rA.y * q), d.m_linearVelocity.x -= f * q, d.m_linearVelocity.y -= f * r, e.m_angularVelocity += i * (p.rB.x * r - p.rB.y * q), e.m_linearVelocity.x += h * q, e.m_linearVelocity.y += h * r
								} else
									for (o = c.pointCount, n = 0; o > n; ++n) {
										var s = c.points[n];
										s.normalImpulse = 0, s.tangentImpulse = 0
									}
						}
					}, p.prototype.SolveVelocityConstraints = function() {
						for (var a, b, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0; s < this.m_constraintCount; ++s) {
							var t = this.m_constraints[s],
								u = t.bodyA,
								v = t.bodyB,
								w = u.m_angularVelocity,
								x = v.m_angularVelocity,
								y = u.m_linearVelocity,
								z = v.m_linearVelocity,
								B = u.m_invMass,
								C = u.m_invI,
								D = v.m_invMass,
								E = v.m_invI,
								F = t.normal.x,
								G = t.normal.y,
								H = G,
								I = -F,
								J = t.friction;
							for (c = 0; c < t.pointCount; c++) a = t.points[c], d = z.x - x * a.rB.y - y.x + w * a.rA.y, e = z.y + x * a.rB.x - y.y - w * a.rA.x, g = d * H + e * I, h = a.tangentMass * -g, i = J * a.normalImpulse, j = A.Clamp(a.tangentImpulse + h, -i, i), h = j - a.tangentImpulse, k = h * H, l = h * I, y.x -= B * k, y.y -= B * l, w -= C * (a.rA.x * l - a.rA.y * k), z.x += D * k, z.y += D * l, x += E * (a.rB.x * l - a.rB.y * k), a.tangentImpulse = j; {
								parseInt(t.pointCount)
							}
							if (1 == t.pointCount) a = t.points[0], d = z.x + -x * a.rB.y - y.x - -w * a.rA.y, e = z.y + x * a.rB.x - y.y - w * a.rA.x, f = d * F + e * G, h = -a.normalMass * (f - a.velocityBias), j = a.normalImpulse + h, j = j > 0 ? j : 0, h = j - a.normalImpulse, k = h * F, l = h * G, y.x -= B * k, y.y -= B * l, w -= C * (a.rA.x * l - a.rA.y * k), z.x += D * k, z.y += D * l, x += E * (a.rB.x * l - a.rB.y * k), a.normalImpulse = j;
							else {
								var K = t.points[0],
									L = t.points[1],
									M = K.normalImpulse,
									N = L.normalImpulse,
									O = z.x - x * K.rB.y - y.x + w * K.rA.y,
									P = z.y + x * K.rB.x - y.y - w * K.rA.x,
									Q = z.x - x * L.rB.y - y.x + w * L.rA.y,
									R = z.y + x * L.rB.x - y.y - w * L.rA.x,
									S = O * F + P * G,
									T = Q * F + R * G,
									U = S - K.velocityBias,
									V = T - L.velocityBias;
								b = t.K, U -= b.col1.x * M + b.col2.x * N, V -= b.col1.y * M + b.col2.y * N;
								for (;;) {
									b = t.normalMass;
									var W = -(b.col1.x * U + b.col2.x * V),
										X = -(b.col1.y * U + b.col2.y * V);
									if (W >= 0 && X >= 0) {
										m = W - M, n = X - N, o = m * F, p = m * G, q = n * F, r = n * G, y.x -= B * (o + q), y.y -= B * (p + r), w -= C * (K.rA.x * p - K.rA.y * o + L.rA.x * r - L.rA.y * q), z.x += D * (o + q), z.y += D * (p + r), x += E * (K.rB.x * p - K.rB.y * o + L.rB.x * r - L.rB.y * q), K.normalImpulse = W, L.normalImpulse = X;
										break
									}
									if (W = -K.normalMass * U, X = 0, S = 0, T = t.K.col1.y * W + V, W >= 0 && T >= 0) {
										m = W - M, n = X - N, o = m * F, p = m * G, q = n * F, r = n * G, y.x -= B * (o + q), y.y -= B * (p + r), w -= C * (K.rA.x * p - K.rA.y * o + L.rA.x * r - L.rA.y * q), z.x += D * (o + q), z.y += D * (p + r), x += E * (K.rB.x * p - K.rB.y * o + L.rB.x * r - L.rB.y * q), K.normalImpulse = W, L.normalImpulse = X;
										break
									}
									if (W = 0, X = -L.normalMass * V, S = t.K.col2.x * X + U, T = 0, X >= 0 && S >= 0) {
										m = W - M, n = X - N, o = m * F, p = m * G, q = n * F, r = n * G, y.x -= B * (o + q), y.y -= B * (p + r), w -= C * (K.rA.x * p - K.rA.y * o + L.rA.x * r - L.rA.y * q), z.x += D * (o + q), z.y += D * (p + r), x += E * (K.rB.x * p - K.rB.y * o + L.rB.x * r - L.rB.y * q), K.normalImpulse = W, L.normalImpulse = X;
										break
									}
									if (W = 0, X = 0, S = U, T = V, S >= 0 && T >= 0) {
										m = W - M, n = X - N, o = m * F, p = m * G, q = n * F, r = n * G, y.x -= B * (o + q), y.y -= B * (p + r), w -= C * (K.rA.x * p - K.rA.y * o + L.rA.x * r - L.rA.y * q), z.x += D * (o + q), z.y += D * (p + r), x += E * (K.rB.x * p - K.rB.y * o + L.rB.x * r - L.rB.y * q), K.normalImpulse = W, L.normalImpulse = X;
										break
									}
									break
								}
							}
							u.m_angularVelocity = w, v.m_angularVelocity = x
						}
					}, p.prototype.FinalizeVelocityConstraints = function() {
						for (var a = 0; a < this.m_constraintCount; ++a)
							for (var b = this.m_constraints[a], c = b.manifold, d = 0; d < b.pointCount; ++d) {
								var e = c.m_points[d],
									f = b.points[d];
								e.m_normalImpulse = f.normalImpulse, e.m_tangentImpulse = f.tangentImpulse
							}
					}, p.prototype.SolvePositionConstraints = function(a) {
						void 0 === a && (a = 0);
						for (var b = 0, c = 0; c < this.m_constraintCount; c++) {
							var d = this.m_constraints[c],
								e = d.bodyA,
								f = d.bodyB,
								g = e.m_mass * e.m_invMass,
								h = e.m_mass * e.m_invI,
								i = f.m_mass * f.m_invMass,
								j = f.m_mass * f.m_invI;
							p.s_psm.Initialize(d);
							for (var k = p.s_psm.m_normal, l = 0; l < d.pointCount; l++) {
								var m = d.points[l],
									n = p.s_psm.m_points[l],
									o = p.s_psm.m_separations[l],
									q = n.x - e.m_sweep.c.x,
									r = n.y - e.m_sweep.c.y,
									s = n.x - f.m_sweep.c.x,
									t = n.y - f.m_sweep.c.y;
								b = o > b ? b : o;
								var u = A.Clamp(a * (o + y.b2_linearSlop), -y.b2_maxLinearCorrection, 0),
									v = -m.equalizedMass * u,
									w = v * k.x,
									x = v * k.y;
								e.m_sweep.c.x -= g * w, e.m_sweep.c.y -= g * x, e.m_sweep.a -= h * (q * x - r * w), e.SynchronizeTransform(), f.m_sweep.c.x += i * w, f.m_sweep.c.y += i * x, f.m_sweep.a += j * (s * x - t * w), f.SynchronizeTransform()
							}
						}
						return b > -1.5 * y.b2_linearSlop
					}, a.postDefs.push(function() {
						a.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new H, a.Dynamics.Contacts.b2ContactSolver.s_psm = new v
					}), a.inherit(q, a.Dynamics.Contacts.b2Contact), q.prototype.__super = a.Dynamics.Contacts.b2Contact.prototype, q.b2EdgeAndCircleContact = function() {
						a.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
					}, q.Create = function() {
						return new q
					}, q.Destroy = function() {}, q.prototype.Reset = function(a, b) {
						this.__super.Reset.call(this, a, b)
					}, q.prototype.Evaluate = function() {
						var a = this.m_fixtureA.GetBody(),
							c = this.m_fixtureB.GetBody();
						this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof e ? this.m_fixtureA.GetShape() : null, a.m_xf, this.m_fixtureB.GetShape() instanceof b ? this.m_fixtureB.GetShape() : null, c.m_xf)
					}, q.prototype.b2CollideEdgeAndCircle = function() {}, a.inherit(r, a.Dynamics.Contacts.b2Contact), r.prototype.__super = a.Dynamics.Contacts.b2Contact.prototype, r.b2NullContact = function() {
						a.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
					}, r.prototype.b2NullContact = function() {
						this.__super.b2Contact.call(this)
					}, r.prototype.Evaluate = function() {}, a.inherit(s, a.Dynamics.Contacts.b2Contact), s.prototype.__super = a.Dynamics.Contacts.b2Contact.prototype, s.b2PolyAndCircleContact = function() {
						a.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
					}, s.Create = function() {
						return new s
					}, s.Destroy = function() {}, s.prototype.Reset = function(a, b) {
						this.__super.Reset.call(this, a, b), y.b2Assert(a.GetType() == g.e_polygonShape), y.b2Assert(b.GetType() == g.e_circleShape)
					}, s.prototype.Evaluate = function() {
						var a = this.m_fixtureA.m_body,
							c = this.m_fixtureB.m_body;
						C.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof f ? this.m_fixtureA.GetShape() : null, a.m_xf, this.m_fixtureB.GetShape() instanceof b ? this.m_fixtureB.GetShape() : null, c.m_xf)
					}, a.inherit(t, a.Dynamics.Contacts.b2Contact), t.prototype.__super = a.Dynamics.Contacts.b2Contact.prototype, t.b2PolyAndEdgeContact = function() {
						a.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
					}, t.Create = function() {
						return new t
					}, t.Destroy = function() {}, t.prototype.Reset = function(a, b) {
						this.__super.Reset.call(this, a, b), y.b2Assert(a.GetType() == g.e_polygonShape), y.b2Assert(b.GetType() == g.e_edgeShape)
					}, t.prototype.Evaluate = function() {
						var a = this.m_fixtureA.GetBody(),
							b = this.m_fixtureB.GetBody();
						this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape() instanceof f ? this.m_fixtureA.GetShape() : null, a.m_xf, this.m_fixtureB.GetShape() instanceof e ? this.m_fixtureB.GetShape() : null, b.m_xf)
					}, t.prototype.b2CollidePolyAndEdge = function() {}, a.inherit(u, a.Dynamics.Contacts.b2Contact), u.prototype.__super = a.Dynamics.Contacts.b2Contact.prototype, u.b2PolygonContact = function() {
						a.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
					}, u.Create = function() {
						return new u
					}, u.Destroy = function() {}, u.prototype.Reset = function(a, b) {
						this.__super.Reset.call(this, a, b)
					}, u.prototype.Evaluate = function() {
						var a = this.m_fixtureA.GetBody(),
							b = this.m_fixtureB.GetBody();
						C.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape() instanceof f ? this.m_fixtureA.GetShape() : null, a.m_xf, this.m_fixtureB.GetShape() instanceof f ? this.m_fixtureB.GetShape() : null, b.m_xf)
					}, v.b2PositionSolverManifold = function() {}, v.prototype.b2PositionSolverManifold = function() {
						this.m_normal = new B, this.m_separations = new d(y.b2_maxManifoldPoints), this.m_points = new c(y.b2_maxManifoldPoints);
						for (var a = 0; a < y.b2_maxManifoldPoints; a++) this.m_points[a] = new B
					}, v.prototype.Initialize = function(a) {
						y.b2Assert(a.pointCount > 0);
						var b, c, d = 0,
							e = 0,
							f = 0,
							g = 0,
							h = 0;
						switch (a.type) {
							case E.e_circles:
								b = a.bodyA.m_xf.R, c = a.localPoint;
								var i = a.bodyA.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y),
									j = a.bodyA.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y);
								b = a.bodyB.m_xf.R, c = a.points[0].localPoint;
								var k = a.bodyB.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y),
									l = a.bodyB.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y),
									m = k - i,
									n = l - j,
									o = m * m + n * n;
								if (o > Number.MIN_VALUE * Number.MIN_VALUE) {
									var p = Math.sqrt(o);
									this.m_normal.x = m / p, this.m_normal.y = n / p
								} else this.m_normal.x = 1, this.m_normal.y = 0;
								this.m_points[0].x = .5 * (i + k), this.m_points[0].y = .5 * (j + l), this.m_separations[0] = m * this.m_normal.x + n * this.m_normal.y - a.radius;
								break;
							case E.e_faceA:
								for (b = a.bodyA.m_xf.R, c = a.localPlaneNormal, this.m_normal.x = b.col1.x * c.x + b.col2.x * c.y, this.m_normal.y = b.col1.y * c.x + b.col2.y * c.y, b = a.bodyA.m_xf.R, c = a.localPoint, g = a.bodyA.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y), h = a.bodyA.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y), b = a.bodyB.m_xf.R, d = 0; d < a.pointCount; ++d) c = a.points[d].localPoint, e = a.bodyB.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y), f = a.bodyB.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y), this.m_separations[d] = (e - g) * this.m_normal.x + (f - h) * this.m_normal.y - a.radius, this.m_points[d].x = e, this.m_points[d].y = f;
								break;
							case E.e_faceB:
								for (b = a.bodyB.m_xf.R, c = a.localPlaneNormal, this.m_normal.x = b.col1.x * c.x + b.col2.x * c.y, this.m_normal.y = b.col1.y * c.x + b.col2.y * c.y, b = a.bodyB.m_xf.R, c = a.localPoint, g = a.bodyB.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y), h = a.bodyB.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y), b = a.bodyA.m_xf.R, d = 0; d < a.pointCount; ++d) c = a.points[d].localPoint, e = a.bodyA.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y), f = a.bodyA.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y), this.m_separations[d] = (e - g) * this.m_normal.x + (f - h) * this.m_normal.y - a.radius, this.m_points[d].Set(e, f);
								this.m_normal.x *= -1, this.m_normal.y *= -1
						}
					}, a.postDefs.push(function() {
						a.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new B, a.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new B
					})
				}(),
				function() {
					var b = (a.Dynamics.b2Body, a.Dynamics.b2BodyDef, a.Dynamics.b2ContactFilter, a.Dynamics.b2ContactImpulse, a.Dynamics.b2ContactListener, a.Dynamics.b2ContactManager, a.Dynamics.b2DebugDraw, a.Dynamics.b2DestructionListener, a.Dynamics.b2FilterData, a.Dynamics.b2Fixture, a.Dynamics.b2FixtureDef, a.Dynamics.b2Island, a.Dynamics.b2TimeStep, a.Dynamics.b2World, a.Common.Math.b2Mat22),
						c = (a.Common.Math.b2Mat33, a.Common.Math.b2Math),
						d = (a.Common.Math.b2Sweep, a.Common.Math.b2Transform, a.Common.Math.b2Vec2),
						e = (a.Common.Math.b2Vec3, a.Common.b2Color),
						f = (a.Common.b2internal, a.Common.b2Settings, a.Collision.Shapes.b2CircleShape, a.Collision.Shapes.b2EdgeChainDef, a.Collision.Shapes.b2EdgeShape, a.Collision.Shapes.b2MassData, a.Collision.Shapes.b2PolygonShape, a.Collision.Shapes.b2Shape, a.Dynamics.Controllers.b2BuoyancyController),
						g = a.Dynamics.Controllers.b2ConstantAccelController,
						h = a.Dynamics.Controllers.b2ConstantForceController,
						i = a.Dynamics.Controllers.b2Controller,
						j = a.Dynamics.Controllers.b2ControllerEdge,
						k = a.Dynamics.Controllers.b2GravityController,
						l = a.Dynamics.Controllers.b2TensorDampingController;
					a.inherit(f, a.Dynamics.Controllers.b2Controller), f.prototype.__super = a.Dynamics.Controllers.b2Controller.prototype, f.b2BuoyancyController = function() {
						a.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.normal = new d(0, -1), this.offset = 0, this.density = 0, this.velocity = new d(0, 0), this.linearDrag = 2, this.angularDrag = 1, this.useDensity = !1, this.useWorldGravity = !0, this.gravity = null
					}, f.prototype.Step = function() {
						if (this.m_bodyList) {
							this.useWorldGravity && (this.gravity = this.GetWorld().GetGravity().Copy());
							for (var a = this.m_bodyList; a; a = a.nextBody) {
								var b = a.body;
								if (0 != b.IsAwake()) {
									for (var c = new d, e = new d, f = 0, g = 0, h = b.GetFixtureList(); h; h = h.GetNext()) {
										var i = new d,
											j = h.GetShape().ComputeSubmergedArea(this.normal, this.offset, b.GetTransform(), i);
										f += j, c.x += j * i.x, c.y += j * i.y;
										var k = 0;
										k = this.useDensity ? 1 : 1, g += j * k, e.x += j * i.x * k, e.y += j * i.y * k
									}
									if (c.x /= f, c.y /= f, e.x /= g, e.y /= g, !(f < Number.MIN_VALUE)) {
										var l = this.gravity.GetNegative();
										l.Multiply(this.density * f), b.ApplyForce(l, e);
										var m = b.GetLinearVelocityFromWorldPoint(c);
										m.Subtract(this.velocity), m.Multiply(-this.linearDrag * f), b.ApplyForce(m, c), b.ApplyTorque(-b.GetInertia() / b.GetMass() * f * b.GetAngularVelocity() * this.angularDrag)
									}
								}
							}
						}
					}, f.prototype.Draw = function(a) {
						var b = 1e3,
							c = new d,
							f = new d;
						c.x = this.normal.x * this.offset + this.normal.y * b, c.y = this.normal.y * this.offset - this.normal.x * b, f.x = this.normal.x * this.offset - this.normal.y * b, f.y = this.normal.y * this.offset + this.normal.x * b;
						var g = new e(0, 0, 1);
						a.DrawSegment(c, f, g)
					}, a.inherit(g, a.Dynamics.Controllers.b2Controller), g.prototype.__super = a.Dynamics.Controllers.b2Controller.prototype, g.b2ConstantAccelController = function() {
						a.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.A = new d(0, 0)
					}, g.prototype.Step = function(a) {
						for (var b = new d(this.A.x * a.dt, this.A.y * a.dt), c = this.m_bodyList; c; c = c.nextBody) {
							var e = c.body;
							e.IsAwake() && e.SetLinearVelocity(new d(e.GetLinearVelocity().x + b.x, e.GetLinearVelocity().y + b.y))
						}
					}, a.inherit(h, a.Dynamics.Controllers.b2Controller), h.prototype.__super = a.Dynamics.Controllers.b2Controller.prototype, h.b2ConstantForceController = function() {
						a.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.F = new d(0, 0)
					}, h.prototype.Step = function() {
						for (var a = this.m_bodyList; a; a = a.nextBody) {
							var b = a.body;
							b.IsAwake() && b.ApplyForce(this.F, b.GetWorldCenter())
						}
					}, i.b2Controller = function() {}, i.prototype.Step = function() {}, i.prototype.Draw = function() {}, i.prototype.AddBody = function(a) {
						var b = new j;
						b.controller = this, b.body = a, b.nextBody = this.m_bodyList, b.prevBody = null, this.m_bodyList = b, b.nextBody && (b.nextBody.prevBody = b), this.m_bodyCount++, b.nextController = a.m_controllerList, b.prevController = null, a.m_controllerList = b, b.nextController && (b.nextController.prevController = b), a.m_controllerCount++
					}, i.prototype.RemoveBody = function(a) {
						for (var b = a.m_controllerList; b && b.controller != this;) b = b.nextController;
						b.prevBody && (b.prevBody.nextBody = b.nextBody), b.nextBody && (b.nextBody.prevBody = b.prevBody), b.nextController && (b.nextController.prevController = b.prevController), b.prevController && (b.prevController.nextController = b.nextController), this.m_bodyList == b && (this.m_bodyList = b.nextBody), a.m_controllerList == b && (a.m_controllerList = b.nextController), a.m_controllerCount--, this.m_bodyCount--
					}, i.prototype.Clear = function() {
						for (; this.m_bodyList;) this.RemoveBody(this.m_bodyList.body)
					}, i.prototype.GetNext = function() {
						return this.m_next
					}, i.prototype.GetWorld = function() {
						return this.m_world
					}, i.prototype.GetBodyList = function() {
						return this.m_bodyList
					}, j.b2ControllerEdge = function() {}, a.inherit(k, a.Dynamics.Controllers.b2Controller), k.prototype.__super = a.Dynamics.Controllers.b2Controller.prototype, k.b2GravityController = function() {
						a.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.G = 1, this.invSqr = !0
					}, k.prototype.Step = function() {
						var a = null,
							b = null,
							c = null,
							e = 0,
							f = null,
							g = null,
							h = null,
							i = 0,
							j = 0,
							k = 0,
							l = null;
						if (this.invSqr)
							for (a = this.m_bodyList; a; a = a.nextBody)
								for (b = a.body, c = b.GetWorldCenter(), e = b.GetMass(), f = this.m_bodyList; f != a; f = f.nextBody) g = f.body, h = g.GetWorldCenter(), i = h.x - c.x, j = h.y - c.y, k = i * i + j * j, k < Number.MIN_VALUE || (l = new d(i, j), l.Multiply(this.G / k / Math.sqrt(k) * e * g.GetMass()), b.IsAwake() && b.ApplyForce(l, c), l.Multiply(-1), g.IsAwake() && g.ApplyForce(l, h));
						else
							for (a = this.m_bodyList; a; a = a.nextBody)
								for (b = a.body, c = b.GetWorldCenter(), e = b.GetMass(), f = this.m_bodyList; f != a; f = f.nextBody) g = f.body, h = g.GetWorldCenter(), i = h.x - c.x, j = h.y - c.y, k = i * i + j * j, k < Number.MIN_VALUE || (l = new d(i, j), l.Multiply(this.G / k * e * g.GetMass()), b.IsAwake() && b.ApplyForce(l, c), l.Multiply(-1), g.IsAwake() && g.ApplyForce(l, h))
					}, a.inherit(l, a.Dynamics.Controllers.b2Controller), l.prototype.__super = a.Dynamics.Controllers.b2Controller.prototype, l.b2TensorDampingController = function() {
						a.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.T = new b, this.maxTimestep = 0
					}, l.prototype.SetAxisAligned = function(a, b) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), this.T.col1.x = -a, this.T.col1.y = 0, this.T.col2.x = 0, this.T.col2.y = -b, this.maxTimestep = a > 0 || b > 0 ? 1 / Math.max(a, b) : 0
					}, l.prototype.Step = function(a) {
						var b = a.dt;
						if (!(b <= Number.MIN_VALUE)) {
							b > this.maxTimestep && this.maxTimestep > 0 && (b = this.maxTimestep);
							for (var e = this.m_bodyList; e; e = e.nextBody) {
								var f = e.body;
								if (f.IsAwake()) {
									var g = f.GetWorldVector(c.MulMV(this.T, f.GetLocalVector(f.GetLinearVelocity())));
									f.SetLinearVelocity(new d(f.GetLinearVelocity().x + g.x * b, f.GetLinearVelocity().y + g.y * b))
								}
							}
						}
					}
				}(),
				function() {
					{
						var b = (a.Common.b2Color, a.Common.b2internal, a.Common.b2Settings),
							c = a.Common.Math.b2Mat22,
							d = a.Common.Math.b2Mat33,
							e = a.Common.Math.b2Math,
							f = (a.Common.Math.b2Sweep, a.Common.Math.b2Transform, a.Common.Math.b2Vec2),
							g = a.Common.Math.b2Vec3,
							h = a.Dynamics.Joints.b2DistanceJoint,
							i = a.Dynamics.Joints.b2DistanceJointDef,
							j = a.Dynamics.Joints.b2FrictionJoint,
							k = a.Dynamics.Joints.b2FrictionJointDef,
							l = a.Dynamics.Joints.b2GearJoint,
							m = a.Dynamics.Joints.b2GearJointDef,
							n = a.Dynamics.Joints.b2Jacobian,
							o = a.Dynamics.Joints.b2Joint,
							p = a.Dynamics.Joints.b2JointDef,
							q = a.Dynamics.Joints.b2JointEdge,
							r = a.Dynamics.Joints.b2LineJoint,
							s = a.Dynamics.Joints.b2LineJointDef,
							t = a.Dynamics.Joints.b2MouseJoint,
							u = a.Dynamics.Joints.b2MouseJointDef,
							v = a.Dynamics.Joints.b2PrismaticJoint,
							w = a.Dynamics.Joints.b2PrismaticJointDef,
							x = a.Dynamics.Joints.b2PulleyJoint,
							y = a.Dynamics.Joints.b2PulleyJointDef,
							z = a.Dynamics.Joints.b2RevoluteJoint,
							A = a.Dynamics.Joints.b2RevoluteJointDef,
							B = a.Dynamics.Joints.b2WeldJoint,
							C = a.Dynamics.Joints.b2WeldJointDef;
						a.Dynamics.b2Body, a.Dynamics.b2BodyDef, a.Dynamics.b2ContactFilter, a.Dynamics.b2ContactImpulse, a.Dynamics.b2ContactListener, a.Dynamics.b2ContactManager, a.Dynamics.b2DebugDraw, a.Dynamics.b2DestructionListener, a.Dynamics.b2FilterData, a.Dynamics.b2Fixture, a.Dynamics.b2FixtureDef, a.Dynamics.b2Island, a.Dynamics.b2TimeStep, a.Dynamics.b2World
					}
					a.inherit(h, a.Dynamics.Joints.b2Joint), h.prototype.__super = a.Dynamics.Joints.b2Joint.prototype, h.b2DistanceJoint = function() {
						a.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new f, this.m_localAnchor2 = new f, this.m_u = new f
					}, h.prototype.GetAnchorA = function() {
						return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
					}, h.prototype.GetAnchorB = function() {
						return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
					}, h.prototype.GetReactionForce = function(a) {
						return void 0 === a && (a = 0), new f(a * this.m_impulse * this.m_u.x, a * this.m_impulse * this.m_u.y)
					}, h.prototype.GetReactionTorque = function(a) {
						return void 0 === a && (a = 0), 0
					}, h.prototype.GetLength = function() {
						return this.m_length
					}, h.prototype.SetLength = function(a) {
						void 0 === a && (a = 0), this.m_length = a
					}, h.prototype.GetFrequency = function() {
						return this.m_frequencyHz
					}, h.prototype.SetFrequency = function(a) {
						void 0 === a && (a = 0), this.m_frequencyHz = a
					}, h.prototype.GetDampingRatio = function() {
						return this.m_dampingRatio
					}, h.prototype.SetDampingRatio = function(a) {
						void 0 === a && (a = 0), this.m_dampingRatio = a
					}, h.prototype.b2DistanceJoint = function(a) {
						this.__super.b2Joint.call(this, a);
						this.m_localAnchor1.SetV(a.localAnchorA), this.m_localAnchor2.SetV(a.localAnchorB), this.m_length = a.length, this.m_frequencyHz = a.frequencyHz, this.m_dampingRatio = a.dampingRatio, this.m_impulse = 0, this.m_gamma = 0, this.m_bias = 0
					}, h.prototype.InitVelocityConstraints = function(a) {
						var c, d = 0,
							e = this.m_bodyA,
							f = this.m_bodyB;
						c = e.m_xf.R;
						var g = this.m_localAnchor1.x - e.m_sweep.localCenter.x,
							h = this.m_localAnchor1.y - e.m_sweep.localCenter.y;
						d = c.col1.x * g + c.col2.x * h, h = c.col1.y * g + c.col2.y * h, g = d, c = f.m_xf.R;
						var i = this.m_localAnchor2.x - f.m_sweep.localCenter.x,
							j = this.m_localAnchor2.y - f.m_sweep.localCenter.y;
						d = c.col1.x * i + c.col2.x * j, j = c.col1.y * i + c.col2.y * j, i = d, this.m_u.x = f.m_sweep.c.x + i - e.m_sweep.c.x - g, this.m_u.y = f.m_sweep.c.y + j - e.m_sweep.c.y - h;
						var k = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
						k > b.b2_linearSlop ? this.m_u.Multiply(1 / k) : this.m_u.SetZero();
						var l = g * this.m_u.y - h * this.m_u.x,
							m = i * this.m_u.y - j * this.m_u.x,
							n = e.m_invMass + e.m_invI * l * l + f.m_invMass + f.m_invI * m * m;
						if (this.m_mass = 0 != n ? 1 / n : 0, this.m_frequencyHz > 0) {
							var o = k - this.m_length,
								p = 2 * Math.PI * this.m_frequencyHz,
								q = 2 * this.m_mass * this.m_dampingRatio * p,
								r = this.m_mass * p * p;
							this.m_gamma = a.dt * (q + a.dt * r), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = o * a.dt * r * this.m_gamma, this.m_mass = n + this.m_gamma, this.m_mass = 0 != this.m_mass ? 1 / this.m_mass : 0
						}
						if (a.warmStarting) {
							this.m_impulse *= a.dtRatio;
							var s = this.m_impulse * this.m_u.x,
								t = this.m_impulse * this.m_u.y;
							e.m_linearVelocity.x -= e.m_invMass * s, e.m_linearVelocity.y -= e.m_invMass * t, e.m_angularVelocity -= e.m_invI * (g * t - h * s), f.m_linearVelocity.x += f.m_invMass * s, f.m_linearVelocity.y += f.m_invMass * t, f.m_angularVelocity += f.m_invI * (i * t - j * s)
						} else this.m_impulse = 0
					}, h.prototype.SolveVelocityConstraints = function() {
						var a, b = this.m_bodyA,
							c = this.m_bodyB;
						a = b.m_xf.R;
						var d = this.m_localAnchor1.x - b.m_sweep.localCenter.x,
							e = this.m_localAnchor1.y - b.m_sweep.localCenter.y,
							f = a.col1.x * d + a.col2.x * e;
						e = a.col1.y * d + a.col2.y * e, d = f, a = c.m_xf.R;
						var g = this.m_localAnchor2.x - c.m_sweep.localCenter.x,
							h = this.m_localAnchor2.y - c.m_sweep.localCenter.y;
						f = a.col1.x * g + a.col2.x * h, h = a.col1.y * g + a.col2.y * h, g = f;
						var i = b.m_linearVelocity.x + -b.m_angularVelocity * e,
							j = b.m_linearVelocity.y + b.m_angularVelocity * d,
							k = c.m_linearVelocity.x + -c.m_angularVelocity * h,
							l = c.m_linearVelocity.y + c.m_angularVelocity * g,
							m = this.m_u.x * (k - i) + this.m_u.y * (l - j),
							n = -this.m_mass * (m + this.m_bias + this.m_gamma * this.m_impulse);
						this.m_impulse += n;
						var o = n * this.m_u.x,
							p = n * this.m_u.y;
						b.m_linearVelocity.x -= b.m_invMass * o, b.m_linearVelocity.y -= b.m_invMass * p, b.m_angularVelocity -= b.m_invI * (d * p - e * o), c.m_linearVelocity.x += c.m_invMass * o, c.m_linearVelocity.y += c.m_invMass * p, c.m_angularVelocity += c.m_invI * (g * p - h * o)
					}, h.prototype.SolvePositionConstraints = function(a) {
						void 0 === a && (a = 0);
						var c;
						if (this.m_frequencyHz > 0) return !0;
						var d = this.m_bodyA,
							f = this.m_bodyB;
						c = d.m_xf.R;
						var g = this.m_localAnchor1.x - d.m_sweep.localCenter.x,
							h = this.m_localAnchor1.y - d.m_sweep.localCenter.y,
							i = c.col1.x * g + c.col2.x * h;
						h = c.col1.y * g + c.col2.y * h, g = i, c = f.m_xf.R;
						var j = this.m_localAnchor2.x - f.m_sweep.localCenter.x,
							k = this.m_localAnchor2.y - f.m_sweep.localCenter.y;
						i = c.col1.x * j + c.col2.x * k, k = c.col1.y * j + c.col2.y * k, j = i;
						var l = f.m_sweep.c.x + j - d.m_sweep.c.x - g,
							m = f.m_sweep.c.y + k - d.m_sweep.c.y - h,
							n = Math.sqrt(l * l + m * m);
						l /= n, m /= n;
						var o = n - this.m_length;
						o = e.Clamp(o, -b.b2_maxLinearCorrection, b.b2_maxLinearCorrection);
						var p = -this.m_mass * o;
						this.m_u.Set(l, m);
						var q = p * this.m_u.x,
							r = p * this.m_u.y;
						return d.m_sweep.c.x -= d.m_invMass * q, d.m_sweep.c.y -= d.m_invMass * r, d.m_sweep.a -= d.m_invI * (g * r - h * q), f.m_sweep.c.x += f.m_invMass * q, f.m_sweep.c.y += f.m_invMass * r, f.m_sweep.a += f.m_invI * (j * r - k * q), d.SynchronizeTransform(), f.SynchronizeTransform(), e.Abs(o) < b.b2_linearSlop
					}, a.inherit(i, a.Dynamics.Joints.b2JointDef), i.prototype.__super = a.Dynamics.Joints.b2JointDef.prototype, i.b2DistanceJointDef = function() {
						a.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new f, this.localAnchorB = new f
					}, i.prototype.b2DistanceJointDef = function() {
						this.__super.b2JointDef.call(this), this.type = o.e_distanceJoint, this.length = 1, this.frequencyHz = 0, this.dampingRatio = 0
					}, i.prototype.Initialize = function(a, b, c, d) {
						this.bodyA = a, this.bodyB = b, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(d));
						var e = d.x - c.x,
							f = d.y - c.y;
						this.length = Math.sqrt(e * e + f * f), this.frequencyHz = 0, this.dampingRatio = 0
					}, a.inherit(j, a.Dynamics.Joints.b2Joint), j.prototype.__super = a.Dynamics.Joints.b2Joint.prototype, j.b2FrictionJoint = function() {
						a.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new f, this.m_localAnchorB = new f, this.m_linearMass = new c, this.m_linearImpulse = new f
					}, j.prototype.GetAnchorA = function() {
						return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
					}, j.prototype.GetAnchorB = function() {
						return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
					}, j.prototype.GetReactionForce = function(a) {
						return void 0 === a && (a = 0), new f(a * this.m_linearImpulse.x, a * this.m_linearImpulse.y)
					}, j.prototype.GetReactionTorque = function(a) {
						return void 0 === a && (a = 0), a * this.m_angularImpulse
					}, j.prototype.SetMaxForce = function(a) {
						void 0 === a && (a = 0), this.m_maxForce = a
					}, j.prototype.GetMaxForce = function() {
						return this.m_maxForce
					}, j.prototype.SetMaxTorque = function(a) {
						void 0 === a && (a = 0), this.m_maxTorque = a
					}, j.prototype.GetMaxTorque = function() {
						return this.m_maxTorque
					}, j.prototype.b2FrictionJoint = function(a) {
						this.__super.b2Joint.call(this, a), this.m_localAnchorA.SetV(a.localAnchorA), this.m_localAnchorB.SetV(a.localAnchorB), this.m_linearMass.SetZero(), this.m_angularMass = 0, this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0, this.m_maxForce = a.maxForce, this.m_maxTorque = a.maxTorque
					}, j.prototype.InitVelocityConstraints = function(a) {
						var b, d = 0,
							e = this.m_bodyA,
							f = this.m_bodyB;
						b = e.m_xf.R;
						var g = this.m_localAnchorA.x - e.m_sweep.localCenter.x,
							h = this.m_localAnchorA.y - e.m_sweep.localCenter.y;
						d = b.col1.x * g + b.col2.x * h, h = b.col1.y * g + b.col2.y * h, g = d, b = f.m_xf.R;
						var i = this.m_localAnchorB.x - f.m_sweep.localCenter.x,
							j = this.m_localAnchorB.y - f.m_sweep.localCenter.y;
						d = b.col1.x * i + b.col2.x * j, j = b.col1.y * i + b.col2.y * j, i = d;
						var k = e.m_invMass,
							l = f.m_invMass,
							m = e.m_invI,
							n = f.m_invI,
							o = new c;
						if (o.col1.x = k + l, o.col2.x = 0, o.col1.y = 0, o.col2.y = k + l, o.col1.x += m * h * h, o.col2.x += -m * g * h, o.col1.y += -m * g * h, o.col2.y += m * g * g, o.col1.x += n * j * j, o.col2.x += -n * i * j, o.col1.y += -n * i * j, o.col2.y += n * i * i, o.GetInverse(this.m_linearMass), this.m_angularMass = m + n, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), a.warmStarting) {
							this.m_linearImpulse.x *= a.dtRatio, this.m_linearImpulse.y *= a.dtRatio, this.m_angularImpulse *= a.dtRatio;
							var p = this.m_linearImpulse;
							e.m_linearVelocity.x -= k * p.x, e.m_linearVelocity.y -= k * p.y, e.m_angularVelocity -= m * (g * p.y - h * p.x + this.m_angularImpulse), f.m_linearVelocity.x += l * p.x, f.m_linearVelocity.y += l * p.y, f.m_angularVelocity += n * (i * p.y - j * p.x + this.m_angularImpulse)
						} else this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0
					}, j.prototype.SolveVelocityConstraints = function(a) {
						var b, c = 0,
							d = this.m_bodyA,
							g = this.m_bodyB,
							h = d.m_linearVelocity,
							i = d.m_angularVelocity,
							j = g.m_linearVelocity,
							k = g.m_angularVelocity,
							l = d.m_invMass,
							m = g.m_invMass,
							n = d.m_invI,
							o = g.m_invI;
						b = d.m_xf.R;
						var p = this.m_localAnchorA.x - d.m_sweep.localCenter.x,
							q = this.m_localAnchorA.y - d.m_sweep.localCenter.y;
						c = b.col1.x * p + b.col2.x * q, q = b.col1.y * p + b.col2.y * q, p = c, b = g.m_xf.R;
						var r = this.m_localAnchorB.x - g.m_sweep.localCenter.x,
							s = this.m_localAnchorB.y - g.m_sweep.localCenter.y;
						c = b.col1.x * r + b.col2.x * s, s = b.col1.y * r + b.col2.y * s, r = c;
						var t = 0,
							u = k - i,
							v = -this.m_angularMass * u,
							w = this.m_angularImpulse;
						t = a.dt * this.m_maxTorque, this.m_angularImpulse = e.Clamp(this.m_angularImpulse + v, -t, t), v = this.m_angularImpulse - w, i -= n * v, k += o * v;
						var x = j.x - k * s - h.x + i * q,
							y = j.y + k * r - h.y - i * p,
							z = e.MulMV(this.m_linearMass, new f(-x, -y)),
							A = this.m_linearImpulse.Copy();
						this.m_linearImpulse.Add(z), t = a.dt * this.m_maxForce, this.m_linearImpulse.LengthSquared() > t * t && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Multiply(t)), z = e.SubtractVV(this.m_linearImpulse, A), h.x -= l * z.x, h.y -= l * z.y, i -= n * (p * z.y - q * z.x), j.x += m * z.x, j.y += m * z.y, k += o * (r * z.y - s * z.x), d.m_angularVelocity = i, g.m_angularVelocity = k
					}, j.prototype.SolvePositionConstraints = function(a) {
						return void 0 === a && (a = 0), !0
					}, a.inherit(k, a.Dynamics.Joints.b2JointDef), k.prototype.__super = a.Dynamics.Joints.b2JointDef.prototype, k.b2FrictionJointDef = function() {
						a.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new f, this.localAnchorB = new f
					}, k.prototype.b2FrictionJointDef = function() {
						this.__super.b2JointDef.call(this), this.type = o.e_frictionJoint, this.maxForce = 0, this.maxTorque = 0
					}, k.prototype.Initialize = function(a, b, c) {
						this.bodyA = a, this.bodyB = b, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(c))
					}, a.inherit(l, a.Dynamics.Joints.b2Joint), l.prototype.__super = a.Dynamics.Joints.b2Joint.prototype, l.b2GearJoint = function() {
						a.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new f, this.m_groundAnchor2 = new f, this.m_localAnchor1 = new f, this.m_localAnchor2 = new f, this.m_J = new n
					}, l.prototype.GetAnchorA = function() {
						return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
					}, l.prototype.GetAnchorB = function() {
						return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
					}, l.prototype.GetReactionForce = function(a) {
						return void 0 === a && (a = 0), new f(a * this.m_impulse * this.m_J.linearB.x, a * this.m_impulse * this.m_J.linearB.y)
					}, l.prototype.GetReactionTorque = function(a) {
						void 0 === a && (a = 0);
						var b = this.m_bodyB.m_xf.R,
							c = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x,
							d = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y,
							e = b.col1.x * c + b.col2.x * d;
						d = b.col1.y * c + b.col2.y * d, c = e;
						var f = this.m_impulse * this.m_J.linearB.x,
							g = this.m_impulse * this.m_J.linearB.y;
						return a * (this.m_impulse * this.m_J.angularB - c * g + d * f)
					}, l.prototype.GetRatio = function() {
						return this.m_ratio
					}, l.prototype.SetRatio = function(a) {
						void 0 === a && (a = 0), this.m_ratio = a
					}, l.prototype.b2GearJoint = function(a) {
						this.__super.b2Joint.call(this, a);
						var b = parseInt(a.joint1.m_type),
							c = parseInt(a.joint2.m_type);
						this.m_revolute1 = null, this.m_prismatic1 = null, this.m_revolute2 = null, this.m_prismatic2 = null;
						var d = 0,
							e = 0;
						this.m_ground1 = a.joint1.GetBodyA(), this.m_bodyA = a.joint1.GetBodyB(), b == o.e_revoluteJoint ? (this.m_revolute1 = a.joint1 instanceof z ? a.joint1 : null, this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2), d = this.m_revolute1.GetJointAngle()) : (this.m_prismatic1 = a.joint1 instanceof v ? a.joint1 : null, this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2), d = this.m_prismatic1.GetJointTranslation()), this.m_ground2 = a.joint2.GetBodyA(), this.m_bodyB = a.joint2.GetBodyB(), c == o.e_revoluteJoint ? (this.m_revolute2 = a.joint2 instanceof z ? a.joint2 : null, this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2), e = this.m_revolute2.GetJointAngle()) : (this.m_prismatic2 = a.joint2 instanceof v ? a.joint2 : null, this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2), e = this.m_prismatic2.GetJointTranslation()), this.m_ratio = a.ratio, this.m_constant = d + this.m_ratio * e, this.m_impulse = 0
					}, l.prototype.InitVelocityConstraints = function(a) {
						var b, c, d = this.m_ground1,
							e = this.m_ground2,
							f = this.m_bodyA,
							g = this.m_bodyB,
							h = 0,
							i = 0,
							j = 0,
							k = 0,
							l = 0,
							m = 0,
							n = 0;
						this.m_J.SetZero(), this.m_revolute1 ? (this.m_J.angularA = -1, n += f.m_invI) : (b = d.m_xf.R, c = this.m_prismatic1.m_localXAxis1, h = b.col1.x * c.x + b.col2.x * c.y, i = b.col1.y * c.x + b.col2.y * c.y, b = f.m_xf.R, j = this.m_localAnchor1.x - f.m_sweep.localCenter.x, k = this.m_localAnchor1.y - f.m_sweep.localCenter.y, m = b.col1.x * j + b.col2.x * k, k = b.col1.y * j + b.col2.y * k, j = m, l = j * i - k * h, this.m_J.linearA.Set(-h, -i), this.m_J.angularA = -l, n += f.m_invMass + f.m_invI * l * l), this.m_revolute2 ? (this.m_J.angularB = -this.m_ratio, n += this.m_ratio * this.m_ratio * g.m_invI) : (b = e.m_xf.R, c = this.m_prismatic2.m_localXAxis1, h = b.col1.x * c.x + b.col2.x * c.y, i = b.col1.y * c.x + b.col2.y * c.y, b = g.m_xf.R, j = this.m_localAnchor2.x - g.m_sweep.localCenter.x, k = this.m_localAnchor2.y - g.m_sweep.localCenter.y, m = b.col1.x * j + b.col2.x * k, k = b.col1.y * j + b.col2.y * k, j = m, l = j * i - k * h, this.m_J.linearB.Set(-this.m_ratio * h, -this.m_ratio * i), this.m_J.angularB = -this.m_ratio * l, n += this.m_ratio * this.m_ratio * (g.m_invMass + g.m_invI * l * l)), this.m_mass = n > 0 ? 1 / n : 0, a.warmStarting ? (f.m_linearVelocity.x += f.m_invMass * this.m_impulse * this.m_J.linearA.x, f.m_linearVelocity.y += f.m_invMass * this.m_impulse * this.m_J.linearA.y, f.m_angularVelocity += f.m_invI * this.m_impulse * this.m_J.angularA, g.m_linearVelocity.x += g.m_invMass * this.m_impulse * this.m_J.linearB.x, g.m_linearVelocity.y += g.m_invMass * this.m_impulse * this.m_J.linearB.y, g.m_angularVelocity += g.m_invI * this.m_impulse * this.m_J.angularB) : this.m_impulse = 0
					}, l.prototype.SolveVelocityConstraints = function() {
						var a = this.m_bodyA,
							b = this.m_bodyB,
							c = this.m_J.Compute(a.m_linearVelocity, a.m_angularVelocity, b.m_linearVelocity, b.m_angularVelocity),
							d = -this.m_mass * c;
						this.m_impulse += d, a.m_linearVelocity.x += a.m_invMass * d * this.m_J.linearA.x, a.m_linearVelocity.y += a.m_invMass * d * this.m_J.linearA.y, a.m_angularVelocity += a.m_invI * d * this.m_J.angularA, b.m_linearVelocity.x += b.m_invMass * d * this.m_J.linearB.x, b.m_linearVelocity.y += b.m_invMass * d * this.m_J.linearB.y, b.m_angularVelocity += b.m_invI * d * this.m_J.angularB
					}, l.prototype.SolvePositionConstraints = function(a) {
						void 0 === a && (a = 0);
						var c = 0,
							d = this.m_bodyA,
							e = this.m_bodyB,
							f = 0,
							g = 0;
						f = this.m_revolute1 ? this.m_revolute1.GetJointAngle() : this.m_prismatic1.GetJointTranslation(), g = this.m_revolute2 ? this.m_revolute2.GetJointAngle() : this.m_prismatic2.GetJointTranslation();
						var h = this.m_constant - (f + this.m_ratio * g),
							i = -this.m_mass * h;
						return d.m_sweep.c.x += d.m_invMass * i * this.m_J.linearA.x, d.m_sweep.c.y += d.m_invMass * i * this.m_J.linearA.y, d.m_sweep.a += d.m_invI * i * this.m_J.angularA, e.m_sweep.c.x += e.m_invMass * i * this.m_J.linearB.x, e.m_sweep.c.y += e.m_invMass * i * this.m_J.linearB.y, e.m_sweep.a += e.m_invI * i * this.m_J.angularB, d.SynchronizeTransform(), e.SynchronizeTransform(), c < b.b2_linearSlop
					}, a.inherit(m, a.Dynamics.Joints.b2JointDef), m.prototype.__super = a.Dynamics.Joints.b2JointDef.prototype, m.b2GearJointDef = function() {
						a.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments)
					}, m.prototype.b2GearJointDef = function() {
						this.__super.b2JointDef.call(this), this.type = o.e_gearJoint, this.joint1 = null, this.joint2 = null, this.ratio = 1
					}, n.b2Jacobian = function() {
						this.linearA = new f, this.linearB = new f
					}, n.prototype.SetZero = function() {
						this.linearA.SetZero(), this.angularA = 0, this.linearB.SetZero(), this.angularB = 0
					}, n.prototype.Set = function(a, b, c, d) {
						void 0 === b && (b = 0), void 0 === d && (d = 0), this.linearA.SetV(a), this.angularA = b, this.linearB.SetV(c), this.angularB = d
					}, n.prototype.Compute = function(a, b, c, d) {
						return void 0 === b && (b = 0), void 0 === d && (d = 0), this.linearA.x * a.x + this.linearA.y * a.y + this.angularA * b + (this.linearB.x * c.x + this.linearB.y * c.y) + this.angularB * d
					}, o.b2Joint = function() {
						this.m_edgeA = new q, this.m_edgeB = new q, this.m_localCenterA = new f, this.m_localCenterB = new f
					}, o.prototype.GetType = function() {
						return this.m_type
					}, o.prototype.GetAnchorA = function() {
						return null
					}, o.prototype.GetAnchorB = function() {
						return null
					}, o.prototype.GetReactionForce = function(a) {
						return void 0 === a && (a = 0), null
					}, o.prototype.GetReactionTorque = function(a) {
						return void 0 === a && (a = 0), 0
					}, o.prototype.GetBodyA = function() {
						return this.m_bodyA
					}, o.prototype.GetBodyB = function() {
						return this.m_bodyB
					}, o.prototype.GetNext = function() {
						return this.m_next
					}, o.prototype.GetUserData = function() {
						return this.m_userData
					}, o.prototype.SetUserData = function(a) {
						this.m_userData = a
					}, o.prototype.IsActive = function() {
						return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
					}, o.Create = function(a) {
						var b = null;
						switch (a.type) {
							case o.e_distanceJoint:
								b = new h(a instanceof i ? a : null);
								break;
							case o.e_mouseJoint:
								b = new t(a instanceof u ? a : null);
								break;
							case o.e_prismaticJoint:
								b = new v(a instanceof w ? a : null);
								break;
							case o.e_revoluteJoint:
								b = new z(a instanceof A ? a : null);
								break;
							case o.e_pulleyJoint:
								b = new x(a instanceof y ? a : null);
								break;
							case o.e_gearJoint:
								b = new l(a instanceof m ? a : null);
								break;
							case o.e_lineJoint:
								b = new r(a instanceof s ? a : null);
								break;
							case o.e_weldJoint:
								b = new B(a instanceof C ? a : null);
								break;
							case o.e_frictionJoint:
								b = new j(a instanceof k ? a : null)
						}
						return b
					}, o.Destroy = function() {}, o.prototype.b2Joint = function(a) {
						b.b2Assert(a.bodyA != a.bodyB), this.m_type = a.type, this.m_prev = null, this.m_next = null, this.m_bodyA = a.bodyA, this.m_bodyB = a.bodyB, this.m_collideConnected = a.collideConnected, this.m_islandFlag = !1, this.m_userData = a.userData
					}, o.prototype.InitVelocityConstraints = function() {}, o.prototype.SolveVelocityConstraints = function() {}, o.prototype.FinalizeVelocityConstraints = function() {}, o.prototype.SolvePositionConstraints = function(a) {
						return void 0 === a && (a = 0), !1
					}, a.postDefs.push(function() {
						a.Dynamics.Joints.b2Joint.e_unknownJoint = 0, a.Dynamics.Joints.b2Joint.e_revoluteJoint = 1, a.Dynamics.Joints.b2Joint.e_prismaticJoint = 2, a.Dynamics.Joints.b2Joint.e_distanceJoint = 3, a.Dynamics.Joints.b2Joint.e_pulleyJoint = 4, a.Dynamics.Joints.b2Joint.e_mouseJoint = 5, a.Dynamics.Joints.b2Joint.e_gearJoint = 6, a.Dynamics.Joints.b2Joint.e_lineJoint = 7, a.Dynamics.Joints.b2Joint.e_weldJoint = 8, a.Dynamics.Joints.b2Joint.e_frictionJoint = 9, a.Dynamics.Joints.b2Joint.e_inactiveLimit = 0, a.Dynamics.Joints.b2Joint.e_atLowerLimit = 1, a.Dynamics.Joints.b2Joint.e_atUpperLimit = 2, a.Dynamics.Joints.b2Joint.e_equalLimits = 3
					}), p.b2JointDef = function() {}, p.prototype.b2JointDef = function() {
						this.type = o.e_unknownJoint, this.userData = null, this.bodyA = null, this.bodyB = null, this.collideConnected = !1
					}, q.b2JointEdge = function() {}, a.inherit(r, a.Dynamics.Joints.b2Joint), r.prototype.__super = a.Dynamics.Joints.b2Joint.prototype, r.b2LineJoint = function() {
						a.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new f, this.m_localAnchor2 = new f, this.m_localXAxis1 = new f, this.m_localYAxis1 = new f, this.m_axis = new f, this.m_perp = new f, this.m_K = new c, this.m_impulse = new f
					}, r.prototype.GetAnchorA = function() {
						return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
					}, r.prototype.GetAnchorB = function() {
						return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
					}, r.prototype.GetReactionForce = function(a) {
						return void 0 === a && (a = 0), new f(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
					}, r.prototype.GetReactionTorque = function(a) {
						return void 0 === a && (a = 0), a * this.m_impulse.y
					}, r.prototype.GetJointTranslation = function() {
						var a = this.m_bodyA,
							b = this.m_bodyB,
							c = a.GetWorldPoint(this.m_localAnchor1),
							d = b.GetWorldPoint(this.m_localAnchor2),
							e = d.x - c.x,
							f = d.y - c.y,
							g = a.GetWorldVector(this.m_localXAxis1),
							h = g.x * e + g.y * f;
						return h
					}, r.prototype.GetJointSpeed = function() {
						var a, b = this.m_bodyA,
							c = this.m_bodyB;
						a = b.m_xf.R;
						var d = this.m_localAnchor1.x - b.m_sweep.localCenter.x,
							e = this.m_localAnchor1.y - b.m_sweep.localCenter.y,
							f = a.col1.x * d + a.col2.x * e;
						e = a.col1.y * d + a.col2.y * e, d = f, a = c.m_xf.R;
						var g = this.m_localAnchor2.x - c.m_sweep.localCenter.x,
							h = this.m_localAnchor2.y - c.m_sweep.localCenter.y;
						f = a.col1.x * g + a.col2.x * h, h = a.col1.y * g + a.col2.y * h, g = f;
						var i = b.m_sweep.c.x + d,
							j = b.m_sweep.c.y + e,
							k = c.m_sweep.c.x + g,
							l = c.m_sweep.c.y + h,
							m = k - i,
							n = l - j,
							o = b.GetWorldVector(this.m_localXAxis1),
							p = b.m_linearVelocity,
							q = c.m_linearVelocity,
							r = b.m_angularVelocity,
							s = c.m_angularVelocity,
							t = m * -r * o.y + n * r * o.x + (o.x * (q.x + -s * h - p.x - -r * e) + o.y * (q.y + s * g - p.y - r * d));
						return t
					}, r.prototype.IsLimitEnabled = function() {
						return this.m_enableLimit
					}, r.prototype.EnableLimit = function(a) {
						this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = a
					}, r.prototype.GetLowerLimit = function() {
						return this.m_lowerTranslation
					}, r.prototype.GetUpperLimit = function() {
						return this.m_upperTranslation
					}, r.prototype.SetLimits = function(a, b) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = a, this.m_upperTranslation = b
					}, r.prototype.IsMotorEnabled = function() {
						return this.m_enableMotor
					}, r.prototype.EnableMotor = function(a) {
						this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = a
					}, r.prototype.SetMotorSpeed = function(a) {
						void 0 === a && (a = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = a
					}, r.prototype.GetMotorSpeed = function() {
						return this.m_motorSpeed
					}, r.prototype.SetMaxMotorForce = function(a) {
						void 0 === a && (a = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = a
					}, r.prototype.GetMaxMotorForce = function() {
						return this.m_maxMotorForce
					}, r.prototype.GetMotorForce = function() {
						return this.m_motorImpulse
					}, r.prototype.b2LineJoint = function(a) {
						this.__super.b2Joint.call(this, a);
						this.m_localAnchor1.SetV(a.localAnchorA), this.m_localAnchor2.SetV(a.localAnchorB), this.m_localXAxis1.SetV(a.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = a.lowerTranslation, this.m_upperTranslation = a.upperTranslation, this.m_maxMotorForce = a.maxMotorForce, this.m_motorSpeed = a.motorSpeed, this.m_enableLimit = a.enableLimit, this.m_enableMotor = a.enableMotor, this.m_limitState = o.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero()
					}, r.prototype.InitVelocityConstraints = function(a) {
						var c, d = this.m_bodyA,
							f = this.m_bodyB,
							g = 0;
						this.m_localCenterA.SetV(d.GetLocalCenter()), this.m_localCenterB.SetV(f.GetLocalCenter()); {
							var h = d.GetTransform();
							f.GetTransform()
						}
						c = d.m_xf.R;
						var i = this.m_localAnchor1.x - this.m_localCenterA.x,
							j = this.m_localAnchor1.y - this.m_localCenterA.y;
						g = c.col1.x * i + c.col2.x * j, j = c.col1.y * i + c.col2.y * j, i = g, c = f.m_xf.R;
						var k = this.m_localAnchor2.x - this.m_localCenterB.x,
							l = this.m_localAnchor2.y - this.m_localCenterB.y;
						g = c.col1.x * k + c.col2.x * l, l = c.col1.y * k + c.col2.y * l, k = g;
						var m = f.m_sweep.c.x + k - d.m_sweep.c.x - i,
							n = f.m_sweep.c.y + l - d.m_sweep.c.y - j;
						this.m_invMassA = d.m_invMass, this.m_invMassB = f.m_invMass, this.m_invIA = d.m_invI, this.m_invIB = f.m_invI, this.m_axis.SetV(e.MulMV(h.R, this.m_localXAxis1)), this.m_a1 = (m + i) * this.m_axis.y - (n + j) * this.m_axis.x, this.m_a2 = k * this.m_axis.y - l * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0, this.m_perp.SetV(e.MulMV(h.R, this.m_localYAxis1)), this.m_s1 = (m + i) * this.m_perp.y - (n + j) * this.m_perp.x, this.m_s2 = k * this.m_perp.y - l * this.m_perp.x;
						var p = this.m_invMassA,
							q = this.m_invMassB,
							r = this.m_invIA,
							s = this.m_invIB;
						if (this.m_K.col1.x = p + q + r * this.m_s1 * this.m_s1 + s * this.m_s2 * this.m_s2, this.m_K.col1.y = r * this.m_s1 * this.m_a1 + s * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = p + q + r * this.m_a1 * this.m_a1 + s * this.m_a2 * this.m_a2, this.m_enableLimit) {
							var t = this.m_axis.x * m + this.m_axis.y * n;
							e.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b.b2_linearSlop ? this.m_limitState = o.e_equalLimits : t <= this.m_lowerTranslation ? this.m_limitState != o.e_atLowerLimit && (this.m_limitState = o.e_atLowerLimit, this.m_impulse.y = 0) : t >= this.m_upperTranslation ? this.m_limitState != o.e_atUpperLimit && (this.m_limitState = o.e_atUpperLimit, this.m_impulse.y = 0) : (this.m_limitState = o.e_inactiveLimit, this.m_impulse.y = 0)
						} else this.m_limitState = o.e_inactiveLimit;
						if (0 == this.m_enableMotor && (this.m_motorImpulse = 0), a.warmStarting) {
							this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, this.m_motorImpulse *= a.dtRatio;
							var u = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x,
								v = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y,
								w = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1,
								x = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
							d.m_linearVelocity.x -= this.m_invMassA * u, d.m_linearVelocity.y -= this.m_invMassA * v, d.m_angularVelocity -= this.m_invIA * w, f.m_linearVelocity.x += this.m_invMassB * u, f.m_linearVelocity.y += this.m_invMassB * v, f.m_angularVelocity += this.m_invIB * x
						} else this.m_impulse.SetZero(), this.m_motorImpulse = 0
					}, r.prototype.SolveVelocityConstraints = function(a) {
						var b = this.m_bodyA,
							c = this.m_bodyB,
							d = b.m_linearVelocity,
							g = b.m_angularVelocity,
							h = c.m_linearVelocity,
							i = c.m_angularVelocity,
							j = 0,
							k = 0,
							l = 0,
							m = 0;
						if (this.m_enableMotor && this.m_limitState != o.e_equalLimits) {
							var n = this.m_axis.x * (h.x - d.x) + this.m_axis.y * (h.y - d.y) + this.m_a2 * i - this.m_a1 * g,
								p = this.m_motorMass * (this.m_motorSpeed - n),
								q = this.m_motorImpulse,
								r = a.dt * this.m_maxMotorForce;
							this.m_motorImpulse = e.Clamp(this.m_motorImpulse + p, -r, r), p = this.m_motorImpulse - q, j = p * this.m_axis.x, k = p * this.m_axis.y, l = p * this.m_a1, m = p * this.m_a2, d.x -= this.m_invMassA * j, d.y -= this.m_invMassA * k, g -= this.m_invIA * l, h.x += this.m_invMassB * j, h.y += this.m_invMassB * k, i += this.m_invIB * m
						}
						var s = this.m_perp.x * (h.x - d.x) + this.m_perp.y * (h.y - d.y) + this.m_s2 * i - this.m_s1 * g;
						if (this.m_enableLimit && this.m_limitState != o.e_inactiveLimit) {
							var t = this.m_axis.x * (h.x - d.x) + this.m_axis.y * (h.y - d.y) + this.m_a2 * i - this.m_a1 * g,
								u = this.m_impulse.Copy(),
								v = this.m_K.Solve(new f, -s, -t);
							this.m_impulse.Add(v), this.m_limitState == o.e_atLowerLimit ? this.m_impulse.y = e.Max(this.m_impulse.y, 0) : this.m_limitState == o.e_atUpperLimit && (this.m_impulse.y = e.Min(this.m_impulse.y, 0));
							var w = -s - (this.m_impulse.y - u.y) * this.m_K.col2.x,
								x = 0;
							x = 0 != this.m_K.col1.x ? w / this.m_K.col1.x + u.x : u.x, this.m_impulse.x = x, v.x = this.m_impulse.x - u.x, v.y = this.m_impulse.y - u.y, j = v.x * this.m_perp.x + v.y * this.m_axis.x, k = v.x * this.m_perp.y + v.y * this.m_axis.y, l = v.x * this.m_s1 + v.y * this.m_a1, m = v.x * this.m_s2 + v.y * this.m_a2, d.x -= this.m_invMassA * j, d.y -= this.m_invMassA * k, g -= this.m_invIA * l, h.x += this.m_invMassB * j, h.y += this.m_invMassB * k, i += this.m_invIB * m
						} else {
							var y = 0;
							y = 0 != this.m_K.col1.x ? -s / this.m_K.col1.x : 0, this.m_impulse.x += y, j = y * this.m_perp.x, k = y * this.m_perp.y, l = y * this.m_s1, m = y * this.m_s2, d.x -= this.m_invMassA * j, d.y -= this.m_invMassA * k, g -= this.m_invIA * l, h.x += this.m_invMassB * j, h.y += this.m_invMassB * k, i += this.m_invIB * m
						}
						b.m_linearVelocity.SetV(d), b.m_angularVelocity = g, c.m_linearVelocity.SetV(h), c.m_angularVelocity = i
					}, r.prototype.SolvePositionConstraints = function(a) {
						void 0 === a && (a = 0);
						var d, g = this.m_bodyA,
							h = this.m_bodyB,
							i = g.m_sweep.c,
							j = g.m_sweep.a,
							k = h.m_sweep.c,
							l = h.m_sweep.a,
							m = 0,
							n = 0,
							o = 0,
							p = 0,
							q = 0,
							r = 0,
							s = 0,
							t = !1,
							u = 0,
							v = c.FromAngle(j),
							w = c.FromAngle(l);
						d = v;
						var x = this.m_localAnchor1.x - this.m_localCenterA.x,
							y = this.m_localAnchor1.y - this.m_localCenterA.y;
						m = d.col1.x * x + d.col2.x * y, y = d.col1.y * x + d.col2.y * y, x = m, d = w;
						var z = this.m_localAnchor2.x - this.m_localCenterB.x,
							A = this.m_localAnchor2.y - this.m_localCenterB.y;
						m = d.col1.x * z + d.col2.x * A, A = d.col1.y * z + d.col2.y * A, z = m;
						var B = k.x + z - i.x - x,
							C = k.y + A - i.y - y;
						if (this.m_enableLimit) {
							this.m_axis = e.MulMV(v, this.m_localXAxis1), this.m_a1 = (B + x) * this.m_axis.y - (C + y) * this.m_axis.x, this.m_a2 = z * this.m_axis.y - A * this.m_axis.x;
							var D = this.m_axis.x * B + this.m_axis.y * C;
							e.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b.b2_linearSlop ? (u = e.Clamp(D, -b.b2_maxLinearCorrection, b.b2_maxLinearCorrection), r = e.Abs(D), t = !0) : D <= this.m_lowerTranslation ? (u = e.Clamp(D - this.m_lowerTranslation + b.b2_linearSlop, -b.b2_maxLinearCorrection, 0), r = this.m_lowerTranslation - D, t = !0) : D >= this.m_upperTranslation && (u = e.Clamp(D - this.m_upperTranslation + b.b2_linearSlop, 0, b.b2_maxLinearCorrection), r = D - this.m_upperTranslation, t = !0)
						}
						this.m_perp = e.MulMV(v, this.m_localYAxis1), this.m_s1 = (B + x) * this.m_perp.y - (C + y) * this.m_perp.x, this.m_s2 = z * this.m_perp.y - A * this.m_perp.x;
						var E = new f,
							F = this.m_perp.x * B + this.m_perp.y * C;
						if (r = e.Max(r, e.Abs(F)), s = 0, t) n = this.m_invMassA, o = this.m_invMassB, p = this.m_invIA, q = this.m_invIB, this.m_K.col1.x = n + o + p * this.m_s1 * this.m_s1 + q * this.m_s2 * this.m_s2, this.m_K.col1.y = p * this.m_s1 * this.m_a1 + q * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = n + o + p * this.m_a1 * this.m_a1 + q * this.m_a2 * this.m_a2, this.m_K.Solve(E, -F, -u);
						else {
							n = this.m_invMassA, o = this.m_invMassB, p = this.m_invIA, q = this.m_invIB;
							var G = n + o + p * this.m_s1 * this.m_s1 + q * this.m_s2 * this.m_s2,
								H = 0;
							H = 0 != G ? -F / G : 0, E.x = H, E.y = 0
						}
						var I = E.x * this.m_perp.x + E.y * this.m_axis.x,
							J = E.x * this.m_perp.y + E.y * this.m_axis.y,
							K = E.x * this.m_s1 + E.y * this.m_a1,
							L = E.x * this.m_s2 + E.y * this.m_a2;
						return i.x -= this.m_invMassA * I, i.y -= this.m_invMassA * J, j -= this.m_invIA * K, k.x += this.m_invMassB * I, k.y += this.m_invMassB * J, l += this.m_invIB * L, g.m_sweep.a = j, h.m_sweep.a = l, g.SynchronizeTransform(), h.SynchronizeTransform(), r <= b.b2_linearSlop && s <= b.b2_angularSlop
					}, a.inherit(s, a.Dynamics.Joints.b2JointDef), s.prototype.__super = a.Dynamics.Joints.b2JointDef.prototype, s.b2LineJointDef = function() {
						a.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new f, this.localAnchorB = new f, this.localAxisA = new f
					}, s.prototype.b2LineJointDef = function() {
						this.__super.b2JointDef.call(this), this.type = o.e_lineJoint, this.localAxisA.Set(1, 0), this.enableLimit = !1, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = !1, this.maxMotorForce = 0, this.motorSpeed = 0
					}, s.prototype.Initialize = function(a, b, c, d) {
						this.bodyA = a, this.bodyB = b, this.localAnchorA = this.bodyA.GetLocalPoint(c), this.localAnchorB = this.bodyB.GetLocalPoint(c), this.localAxisA = this.bodyA.GetLocalVector(d)
					}, a.inherit(t, a.Dynamics.Joints.b2Joint), t.prototype.__super = a.Dynamics.Joints.b2Joint.prototype, t.b2MouseJoint = function() {
						a.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new c, this.K1 = new c, this.K2 = new c, this.m_localAnchor = new f, this.m_target = new f, this.m_impulse = new f, this.m_mass = new c, this.m_C = new f
					}, t.prototype.GetAnchorA = function() {
						return this.m_target
					}, t.prototype.GetAnchorB = function() {
						return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
					}, t.prototype.GetReactionForce = function(a) {
						return void 0 === a && (a = 0), new f(a * this.m_impulse.x, a * this.m_impulse.y)
					}, t.prototype.GetReactionTorque = function(a) {
						return void 0 === a && (a = 0), 0
					}, t.prototype.GetTarget = function() {
						return this.m_target
					}, t.prototype.SetTarget = function(a) {
						0 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0), this.m_target = a
					}, t.prototype.GetMaxForce = function() {
						return this.m_maxForce
					}, t.prototype.SetMaxForce = function(a) {
						void 0 === a && (a = 0), this.m_maxForce = a
					}, t.prototype.GetFrequency = function() {
						return this.m_frequencyHz
					}, t.prototype.SetFrequency = function(a) {
						void 0 === a && (a = 0), this.m_frequencyHz = a
					}, t.prototype.GetDampingRatio = function() {
						return this.m_dampingRatio
					}, t.prototype.SetDampingRatio = function(a) {
						void 0 === a && (a = 0), this.m_dampingRatio = a
					}, t.prototype.b2MouseJoint = function(a) {
						this.__super.b2Joint.call(this, a), this.m_target.SetV(a.target);
						var b = this.m_target.x - this.m_bodyB.m_xf.position.x,
							c = this.m_target.y - this.m_bodyB.m_xf.position.y,
							d = this.m_bodyB.m_xf.R;
						this.m_localAnchor.x = b * d.col1.x + c * d.col1.y, this.m_localAnchor.y = b * d.col2.x + c * d.col2.y, this.m_maxForce = a.maxForce, this.m_impulse.SetZero(), this.m_frequencyHz = a.frequencyHz, this.m_dampingRatio = a.dampingRatio, this.m_beta = 0, this.m_gamma = 0
					}, t.prototype.InitVelocityConstraints = function(a) {
						var b = this.m_bodyB,
							c = b.GetMass(),
							d = 2 * Math.PI * this.m_frequencyHz,
							e = 2 * c * this.m_dampingRatio * d,
							f = c * d * d;
						this.m_gamma = a.dt * (e + a.dt * f), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_beta = a.dt * f * this.m_gamma;
						var g;
						g = b.m_xf.R;
						var h = this.m_localAnchor.x - b.m_sweep.localCenter.x,
							i = this.m_localAnchor.y - b.m_sweep.localCenter.y,
							j = g.col1.x * h + g.col2.x * i;
						i = g.col1.y * h + g.col2.y * i, h = j;
						var k = b.m_invMass,
							l = b.m_invI;
						this.K1.col1.x = k, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = k, this.K2.col1.x = l * i * i, this.K2.col2.x = -l * h * i, this.K2.col1.y = -l * h * i, this.K2.col2.y = l * h * h, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.col1.x += this.m_gamma, this.K.col2.y += this.m_gamma, this.K.GetInverse(this.m_mass), this.m_C.x = b.m_sweep.c.x + h - this.m_target.x, this.m_C.y = b.m_sweep.c.y + i - this.m_target.y, b.m_angularVelocity *= .98, this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, b.m_linearVelocity.x += k * this.m_impulse.x, b.m_linearVelocity.y += k * this.m_impulse.y, b.m_angularVelocity += l * (h * this.m_impulse.y - i * this.m_impulse.x)
					}, t.prototype.SolveVelocityConstraints = function(a) {
						var b, c = this.m_bodyB,
							d = 0,
							e = 0;
						b = c.m_xf.R;
						var f = this.m_localAnchor.x - c.m_sweep.localCenter.x,
							g = this.m_localAnchor.y - c.m_sweep.localCenter.y;
						d = b.col1.x * f + b.col2.x * g, g = b.col1.y * f + b.col2.y * g, f = d;
						var h = c.m_linearVelocity.x + -c.m_angularVelocity * g,
							i = c.m_linearVelocity.y + c.m_angularVelocity * f;
						b = this.m_mass, d = h + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x, e = i + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
						var j = -(b.col1.x * d + b.col2.x * e),
							k = -(b.col1.y * d + b.col2.y * e),
							l = this.m_impulse.x,
							m = this.m_impulse.y;
						this.m_impulse.x += j, this.m_impulse.y += k;
						var n = a.dt * this.m_maxForce;
						this.m_impulse.LengthSquared() > n * n && this.m_impulse.Multiply(n / this.m_impulse.Length()), j = this.m_impulse.x - l, k = this.m_impulse.y - m, c.m_linearVelocity.x += c.m_invMass * j, c.m_linearVelocity.y += c.m_invMass * k, c.m_angularVelocity += c.m_invI * (f * k - g * j)
					}, t.prototype.SolvePositionConstraints = function(a) {
						return void 0 === a && (a = 0), !0
					}, a.inherit(u, a.Dynamics.Joints.b2JointDef), u.prototype.__super = a.Dynamics.Joints.b2JointDef.prototype, u.b2MouseJointDef = function() {
						a.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.target = new f
					}, u.prototype.b2MouseJointDef = function() {
						this.__super.b2JointDef.call(this), this.type = o.e_mouseJoint, this.maxForce = 0, this.frequencyHz = 5, this.dampingRatio = .7
					}, a.inherit(v, a.Dynamics.Joints.b2Joint), v.prototype.__super = a.Dynamics.Joints.b2Joint.prototype, v.b2PrismaticJoint = function() {
						a.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new f, this.m_localAnchor2 = new f, this.m_localXAxis1 = new f, this.m_localYAxis1 = new f, this.m_axis = new f, this.m_perp = new f, this.m_K = new d, this.m_impulse = new g
					}, v.prototype.GetAnchorA = function() {
						return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
					}, v.prototype.GetAnchorB = function() {
						return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
					}, v.prototype.GetReactionForce = function(a) {
						return void 0 === a && (a = 0), new f(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
					}, v.prototype.GetReactionTorque = function(a) {
						return void 0 === a && (a = 0), a * this.m_impulse.y
					}, v.prototype.GetJointTranslation = function() {
						var a = this.m_bodyA,
							b = this.m_bodyB,
							c = a.GetWorldPoint(this.m_localAnchor1),
							d = b.GetWorldPoint(this.m_localAnchor2),
							e = d.x - c.x,
							f = d.y - c.y,
							g = a.GetWorldVector(this.m_localXAxis1),
							h = g.x * e + g.y * f;
						return h
					}, v.prototype.GetJointSpeed = function() {
						var a, b = this.m_bodyA,
							c = this.m_bodyB;
						a = b.m_xf.R;
						var d = this.m_localAnchor1.x - b.m_sweep.localCenter.x,
							e = this.m_localAnchor1.y - b.m_sweep.localCenter.y,
							f = a.col1.x * d + a.col2.x * e;
						e = a.col1.y * d + a.col2.y * e, d = f, a = c.m_xf.R;
						var g = this.m_localAnchor2.x - c.m_sweep.localCenter.x,
							h = this.m_localAnchor2.y - c.m_sweep.localCenter.y;
						f = a.col1.x * g + a.col2.x * h, h = a.col1.y * g + a.col2.y * h, g = f;
						var i = b.m_sweep.c.x + d,
							j = b.m_sweep.c.y + e,
							k = c.m_sweep.c.x + g,
							l = c.m_sweep.c.y + h,
							m = k - i,
							n = l - j,
							o = b.GetWorldVector(this.m_localXAxis1),
							p = b.m_linearVelocity,
							q = c.m_linearVelocity,
							r = b.m_angularVelocity,
							s = c.m_angularVelocity,
							t = m * -r * o.y + n * r * o.x + (o.x * (q.x + -s * h - p.x - -r * e) + o.y * (q.y + s * g - p.y - r * d));
						return t
					}, v.prototype.IsLimitEnabled = function() {
						return this.m_enableLimit
					}, v.prototype.EnableLimit = function(a) {
						this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = a
					}, v.prototype.GetLowerLimit = function() {
						return this.m_lowerTranslation
					}, v.prototype.GetUpperLimit = function() {
						return this.m_upperTranslation
					}, v.prototype.SetLimits = function(a, b) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = a, this.m_upperTranslation = b
					}, v.prototype.IsMotorEnabled = function() {
						return this.m_enableMotor
					}, v.prototype.EnableMotor = function(a) {
						this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = a
					}, v.prototype.SetMotorSpeed = function(a) {
						void 0 === a && (a = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = a
					}, v.prototype.GetMotorSpeed = function() {
						return this.m_motorSpeed
					}, v.prototype.SetMaxMotorForce = function(a) {
						void 0 === a && (a = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = a
					}, v.prototype.GetMotorForce = function() {
						return this.m_motorImpulse
					}, v.prototype.b2PrismaticJoint = function(a) {
						this.__super.b2Joint.call(this, a);
						this.m_localAnchor1.SetV(a.localAnchorA), this.m_localAnchor2.SetV(a.localAnchorB), this.m_localXAxis1.SetV(a.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_refAngle = a.referenceAngle, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = a.lowerTranslation, this.m_upperTranslation = a.upperTranslation, this.m_maxMotorForce = a.maxMotorForce, this.m_motorSpeed = a.motorSpeed, this.m_enableLimit = a.enableLimit, this.m_enableMotor = a.enableMotor, this.m_limitState = o.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero()
					}, v.prototype.InitVelocityConstraints = function(a) {
						var c, d = this.m_bodyA,
							f = this.m_bodyB,
							g = 0;
						this.m_localCenterA.SetV(d.GetLocalCenter()), this.m_localCenterB.SetV(f.GetLocalCenter()); {
							var h = d.GetTransform();
							f.GetTransform()
						}
						c = d.m_xf.R;
						var i = this.m_localAnchor1.x - this.m_localCenterA.x,
							j = this.m_localAnchor1.y - this.m_localCenterA.y;
						g = c.col1.x * i + c.col2.x * j, j = c.col1.y * i + c.col2.y * j, i = g, c = f.m_xf.R;
						var k = this.m_localAnchor2.x - this.m_localCenterB.x,
							l = this.m_localAnchor2.y - this.m_localCenterB.y;
						g = c.col1.x * k + c.col2.x * l, l = c.col1.y * k + c.col2.y * l, k = g;
						var m = f.m_sweep.c.x + k - d.m_sweep.c.x - i,
							n = f.m_sweep.c.y + l - d.m_sweep.c.y - j;
						this.m_invMassA = d.m_invMass, this.m_invMassB = f.m_invMass, this.m_invIA = d.m_invI, this.m_invIB = f.m_invI, this.m_axis.SetV(e.MulMV(h.R, this.m_localXAxis1)), this.m_a1 = (m + i) * this.m_axis.y - (n + j) * this.m_axis.x, this.m_a2 = k * this.m_axis.y - l * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass > Number.MIN_VALUE && (this.m_motorMass = 1 / this.m_motorMass), this.m_perp.SetV(e.MulMV(h.R, this.m_localYAxis1)), this.m_s1 = (m + i) * this.m_perp.y - (n + j) * this.m_perp.x, this.m_s2 = k * this.m_perp.y - l * this.m_perp.x;
						var p = this.m_invMassA,
							q = this.m_invMassB,
							r = this.m_invIA,
							s = this.m_invIB;
						if (this.m_K.col1.x = p + q + r * this.m_s1 * this.m_s1 + s * this.m_s2 * this.m_s2, this.m_K.col1.y = r * this.m_s1 + s * this.m_s2, this.m_K.col1.z = r * this.m_s1 * this.m_a1 + s * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = r + s, this.m_K.col2.z = r * this.m_a1 + s * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = p + q + r * this.m_a1 * this.m_a1 + s * this.m_a2 * this.m_a2, this.m_enableLimit) {
							var t = this.m_axis.x * m + this.m_axis.y * n;
							e.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b.b2_linearSlop ? this.m_limitState = o.e_equalLimits : t <= this.m_lowerTranslation ? this.m_limitState != o.e_atLowerLimit && (this.m_limitState = o.e_atLowerLimit, this.m_impulse.z = 0) : t >= this.m_upperTranslation ? this.m_limitState != o.e_atUpperLimit && (this.m_limitState = o.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = o.e_inactiveLimit, this.m_impulse.z = 0)
						} else this.m_limitState = o.e_inactiveLimit;
						if (0 == this.m_enableMotor && (this.m_motorImpulse = 0), a.warmStarting) {
							this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, this.m_motorImpulse *= a.dtRatio;
							var u = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x,
								v = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y,
								w = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1,
								x = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
							d.m_linearVelocity.x -= this.m_invMassA * u, d.m_linearVelocity.y -= this.m_invMassA * v, d.m_angularVelocity -= this.m_invIA * w, f.m_linearVelocity.x += this.m_invMassB * u, f.m_linearVelocity.y += this.m_invMassB * v, f.m_angularVelocity += this.m_invIB * x
						} else this.m_impulse.SetZero(), this.m_motorImpulse = 0
					}, v.prototype.SolveVelocityConstraints = function(a) {
						var b = this.m_bodyA,
							c = this.m_bodyB,
							d = b.m_linearVelocity,
							h = b.m_angularVelocity,
							i = c.m_linearVelocity,
							j = c.m_angularVelocity,
							k = 0,
							l = 0,
							m = 0,
							n = 0;
						if (this.m_enableMotor && this.m_limitState != o.e_equalLimits) {
							var p = this.m_axis.x * (i.x - d.x) + this.m_axis.y * (i.y - d.y) + this.m_a2 * j - this.m_a1 * h,
								q = this.m_motorMass * (this.m_motorSpeed - p),
								r = this.m_motorImpulse,
								s = a.dt * this.m_maxMotorForce;
							this.m_motorImpulse = e.Clamp(this.m_motorImpulse + q, -s, s), q = this.m_motorImpulse - r, k = q * this.m_axis.x, l = q * this.m_axis.y, m = q * this.m_a1, n = q * this.m_a2, d.x -= this.m_invMassA * k, d.y -= this.m_invMassA * l, h -= this.m_invIA * m, i.x += this.m_invMassB * k, i.y += this.m_invMassB * l, j += this.m_invIB * n
						}
						var t = this.m_perp.x * (i.x - d.x) + this.m_perp.y * (i.y - d.y) + this.m_s2 * j - this.m_s1 * h,
							u = j - h;
						if (this.m_enableLimit && this.m_limitState != o.e_inactiveLimit) {
							var v = this.m_axis.x * (i.x - d.x) + this.m_axis.y * (i.y - d.y) + this.m_a2 * j - this.m_a1 * h,
								w = this.m_impulse.Copy(),
								x = this.m_K.Solve33(new g, -t, -u, -v);
							this.m_impulse.Add(x), this.m_limitState == o.e_atLowerLimit ? this.m_impulse.z = e.Max(this.m_impulse.z, 0) : this.m_limitState == o.e_atUpperLimit && (this.m_impulse.z = e.Min(this.m_impulse.z, 0));
							var y = -t - (this.m_impulse.z - w.z) * this.m_K.col3.x,
								z = -u - (this.m_impulse.z - w.z) * this.m_K.col3.y,
								A = this.m_K.Solve22(new f, y, z);
							A.x += w.x, A.y += w.y, this.m_impulse.x = A.x, this.m_impulse.y = A.y, x.x = this.m_impulse.x - w.x, x.y = this.m_impulse.y - w.y, x.z = this.m_impulse.z - w.z, k = x.x * this.m_perp.x + x.z * this.m_axis.x, l = x.x * this.m_perp.y + x.z * this.m_axis.y, m = x.x * this.m_s1 + x.y + x.z * this.m_a1, n = x.x * this.m_s2 + x.y + x.z * this.m_a2, d.x -= this.m_invMassA * k, d.y -= this.m_invMassA * l, h -= this.m_invIA * m, i.x += this.m_invMassB * k, i.y += this.m_invMassB * l, j += this.m_invIB * n
						} else {
							var B = this.m_K.Solve22(new f, -t, -u);
							this.m_impulse.x += B.x, this.m_impulse.y += B.y, k = B.x * this.m_perp.x, l = B.x * this.m_perp.y, m = B.x * this.m_s1 + B.y, n = B.x * this.m_s2 + B.y, d.x -= this.m_invMassA * k, d.y -= this.m_invMassA * l, h -= this.m_invIA * m, i.x += this.m_invMassB * k, i.y += this.m_invMassB * l, j += this.m_invIB * n
						}
						b.m_linearVelocity.SetV(d), b.m_angularVelocity = h, c.m_linearVelocity.SetV(i), c.m_angularVelocity = j
					}, v.prototype.SolvePositionConstraints = function(a) {
						void 0 === a && (a = 0);
						var d, h = this.m_bodyA,
							i = this.m_bodyB,
							j = h.m_sweep.c,
							k = h.m_sweep.a,
							l = i.m_sweep.c,
							m = i.m_sweep.a,
							n = 0,
							o = 0,
							p = 0,
							q = 0,
							r = 0,
							s = 0,
							t = 0,
							u = !1,
							v = 0,
							w = c.FromAngle(k),
							x = c.FromAngle(m);
						d = w;
						var y = this.m_localAnchor1.x - this.m_localCenterA.x,
							z = this.m_localAnchor1.y - this.m_localCenterA.y;
						n = d.col1.x * y + d.col2.x * z, z = d.col1.y * y + d.col2.y * z, y = n, d = x;
						var A = this.m_localAnchor2.x - this.m_localCenterB.x,
							B = this.m_localAnchor2.y - this.m_localCenterB.y;
						n = d.col1.x * A + d.col2.x * B, B = d.col1.y * A + d.col2.y * B, A = n;
						var C = l.x + A - j.x - y,
							D = l.y + B - j.y - z;
						if (this.m_enableLimit) {
							this.m_axis = e.MulMV(w, this.m_localXAxis1), this.m_a1 = (C + y) * this.m_axis.y - (D + z) * this.m_axis.x, this.m_a2 = A * this.m_axis.y - B * this.m_axis.x;
							var E = this.m_axis.x * C + this.m_axis.y * D;
							e.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b.b2_linearSlop ? (v = e.Clamp(E, -b.b2_maxLinearCorrection, b.b2_maxLinearCorrection), s = e.Abs(E), u = !0) : E <= this.m_lowerTranslation ? (v = e.Clamp(E - this.m_lowerTranslation + b.b2_linearSlop, -b.b2_maxLinearCorrection, 0), s = this.m_lowerTranslation - E, u = !0) : E >= this.m_upperTranslation && (v = e.Clamp(E - this.m_upperTranslation + b.b2_linearSlop, 0, b.b2_maxLinearCorrection), s = E - this.m_upperTranslation, u = !0)
						}
						this.m_perp = e.MulMV(w, this.m_localYAxis1), this.m_s1 = (C + y) * this.m_perp.y - (D + z) * this.m_perp.x, this.m_s2 = A * this.m_perp.y - B * this.m_perp.x;
						var F = new g,
							G = this.m_perp.x * C + this.m_perp.y * D,
							H = m - k - this.m_refAngle;
						if (s = e.Max(s, e.Abs(G)), t = e.Abs(H), u) o = this.m_invMassA, p = this.m_invMassB, q = this.m_invIA, r = this.m_invIB, this.m_K.col1.x = o + p + q * this.m_s1 * this.m_s1 + r * this.m_s2 * this.m_s2, this.m_K.col1.y = q * this.m_s1 + r * this.m_s2, this.m_K.col1.z = q * this.m_s1 * this.m_a1 + r * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = q + r, this.m_K.col2.z = q * this.m_a1 + r * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = o + p + q * this.m_a1 * this.m_a1 + r * this.m_a2 * this.m_a2, this.m_K.Solve33(F, -G, -H, -v);
						else {
							o = this.m_invMassA, p = this.m_invMassB, q = this.m_invIA, r = this.m_invIB;
							var I = o + p + q * this.m_s1 * this.m_s1 + r * this.m_s2 * this.m_s2,
								J = q * this.m_s1 + r * this.m_s2,
								K = q + r;
							this.m_K.col1.Set(I, J, 0), this.m_K.col2.Set(J, K, 0);
							var L = this.m_K.Solve22(new f, -G, -H);
							F.x = L.x, F.y = L.y, F.z = 0
						}
						var M = F.x * this.m_perp.x + F.z * this.m_axis.x,
							N = F.x * this.m_perp.y + F.z * this.m_axis.y,
							O = F.x * this.m_s1 + F.y + F.z * this.m_a1,
							P = F.x * this.m_s2 + F.y + F.z * this.m_a2;
						return j.x -= this.m_invMassA * M, j.y -= this.m_invMassA * N, k -= this.m_invIA * O, l.x += this.m_invMassB * M, l.y += this.m_invMassB * N, m += this.m_invIB * P, h.m_sweep.a = k, i.m_sweep.a = m, h.SynchronizeTransform(), i.SynchronizeTransform(), s <= b.b2_linearSlop && t <= b.b2_angularSlop
					}, a.inherit(w, a.Dynamics.Joints.b2JointDef), w.prototype.__super = a.Dynamics.Joints.b2JointDef.prototype, w.b2PrismaticJointDef = function() {
						a.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new f, this.localAnchorB = new f, this.localAxisA = new f
					}, w.prototype.b2PrismaticJointDef = function() {
						this.__super.b2JointDef.call(this), this.type = o.e_prismaticJoint, this.localAxisA.Set(1, 0), this.referenceAngle = 0, this.enableLimit = !1, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = !1, this.maxMotorForce = 0, this.motorSpeed = 0
					}, w.prototype.Initialize = function(a, b, c, d) {
						this.bodyA = a, this.bodyB = b, this.localAnchorA = this.bodyA.GetLocalPoint(c), this.localAnchorB = this.bodyB.GetLocalPoint(c), this.localAxisA = this.bodyA.GetLocalVector(d), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
					}, a.inherit(x, a.Dynamics.Joints.b2Joint), x.prototype.__super = a.Dynamics.Joints.b2Joint.prototype, x.b2PulleyJoint = function() {
						a.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new f, this.m_groundAnchor2 = new f, this.m_localAnchor1 = new f, this.m_localAnchor2 = new f, this.m_u1 = new f, this.m_u2 = new f
					}, x.prototype.GetAnchorA = function() {
						return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
					}, x.prototype.GetAnchorB = function() {
						return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
					}, x.prototype.GetReactionForce = function(a) {
						return void 0 === a && (a = 0), new f(a * this.m_impulse * this.m_u2.x, a * this.m_impulse * this.m_u2.y)
					}, x.prototype.GetReactionTorque = function(a) {
						return void 0 === a && (a = 0), 0
					}, x.prototype.GetGroundAnchorA = function() {
						var a = this.m_ground.m_xf.position.Copy();
						return a.Add(this.m_groundAnchor1), a
					}, x.prototype.GetGroundAnchorB = function() {
						var a = this.m_ground.m_xf.position.Copy();
						return a.Add(this.m_groundAnchor2), a
					}, x.prototype.GetLength1 = function() {
						var a = this.m_bodyA.GetWorldPoint(this.m_localAnchor1),
							b = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x,
							c = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
							d = a.x - b,
							e = a.y - c;
						return Math.sqrt(d * d + e * e)
					}, x.prototype.GetLength2 = function() {
						var a = this.m_bodyB.GetWorldPoint(this.m_localAnchor2),
							b = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
							c = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y,
							d = a.x - b,
							e = a.y - c;
						return Math.sqrt(d * d + e * e)
					}, x.prototype.GetRatio = function() {
						return this.m_ratio
					}, x.prototype.b2PulleyJoint = function(a) {
						this.__super.b2Joint.call(this, a);
						this.m_ground = this.m_bodyA.m_world.m_groundBody, this.m_groundAnchor1.x = a.groundAnchorA.x - this.m_ground.m_xf.position.x, this.m_groundAnchor1.y = a.groundAnchorA.y - this.m_ground.m_xf.position.y, this.m_groundAnchor2.x = a.groundAnchorB.x - this.m_ground.m_xf.position.x, this.m_groundAnchor2.y = a.groundAnchorB.y - this.m_ground.m_xf.position.y, this.m_localAnchor1.SetV(a.localAnchorA), this.m_localAnchor2.SetV(a.localAnchorB), this.m_ratio = a.ratio, this.m_constant = a.lengthA + this.m_ratio * a.lengthB, this.m_maxLength1 = e.Min(a.maxLengthA, this.m_constant - this.m_ratio * x.b2_minPulleyLength), this.m_maxLength2 = e.Min(a.maxLengthB, (this.m_constant - x.b2_minPulleyLength) / this.m_ratio), this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0
					}, x.prototype.InitVelocityConstraints = function(a) {
						var c, d = this.m_bodyA,
							e = this.m_bodyB;
						c = d.m_xf.R;
						var f = this.m_localAnchor1.x - d.m_sweep.localCenter.x,
							g = this.m_localAnchor1.y - d.m_sweep.localCenter.y,
							h = c.col1.x * f + c.col2.x * g;
						g = c.col1.y * f + c.col2.y * g, f = h, c = e.m_xf.R;
						var i = this.m_localAnchor2.x - e.m_sweep.localCenter.x,
							j = this.m_localAnchor2.y - e.m_sweep.localCenter.y;
						h = c.col1.x * i + c.col2.x * j, j = c.col1.y * i + c.col2.y * j, i = h;
						var k = d.m_sweep.c.x + f,
							l = d.m_sweep.c.y + g,
							m = e.m_sweep.c.x + i,
							n = e.m_sweep.c.y + j,
							p = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x,
							q = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
							r = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
							s = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
						this.m_u1.Set(k - p, l - q), this.m_u2.Set(m - r, n - s);
						var t = this.m_u1.Length(),
							u = this.m_u2.Length();
						t > b.b2_linearSlop ? this.m_u1.Multiply(1 / t) : this.m_u1.SetZero(), u > b.b2_linearSlop ? this.m_u2.Multiply(1 / u) : this.m_u2.SetZero();
						var v = this.m_constant - t - this.m_ratio * u;
						v > 0 ? (this.m_state = o.e_inactiveLimit, this.m_impulse = 0) : this.m_state = o.e_atUpperLimit, t < this.m_maxLength1 ? (this.m_limitState1 = o.e_inactiveLimit, this.m_limitImpulse1 = 0) : this.m_limitState1 = o.e_atUpperLimit, u < this.m_maxLength2 ? (this.m_limitState2 = o.e_inactiveLimit, this.m_limitImpulse2 = 0) : this.m_limitState2 = o.e_atUpperLimit;
						var w = f * this.m_u1.y - g * this.m_u1.x,
							x = i * this.m_u2.y - j * this.m_u2.x;
						if (this.m_limitMass1 = d.m_invMass + d.m_invI * w * w, this.m_limitMass2 = e.m_invMass + e.m_invI * x * x, this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2, this.m_limitMass1 = 1 / this.m_limitMass1, this.m_limitMass2 = 1 / this.m_limitMass2, this.m_pulleyMass = 1 / this.m_pulleyMass, a.warmStarting) {
							this.m_impulse *= a.dtRatio, this.m_limitImpulse1 *= a.dtRatio, this.m_limitImpulse2 *= a.dtRatio;
							var y = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x,
								z = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y,
								A = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x,
								B = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
							d.m_linearVelocity.x += d.m_invMass * y, d.m_linearVelocity.y += d.m_invMass * z, d.m_angularVelocity += d.m_invI * (f * z - g * y), e.m_linearVelocity.x += e.m_invMass * A, e.m_linearVelocity.y += e.m_invMass * B, e.m_angularVelocity += e.m_invI * (i * B - j * A)
						} else this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0
					}, x.prototype.SolveVelocityConstraints = function() {
						var a, b = this.m_bodyA,
							c = this.m_bodyB;
						a = b.m_xf.R;
						var d = this.m_localAnchor1.x - b.m_sweep.localCenter.x,
							f = this.m_localAnchor1.y - b.m_sweep.localCenter.y,
							g = a.col1.x * d + a.col2.x * f;
						f = a.col1.y * d + a.col2.y * f, d = g, a = c.m_xf.R;
						var h = this.m_localAnchor2.x - c.m_sweep.localCenter.x,
							i = this.m_localAnchor2.y - c.m_sweep.localCenter.y;
						g = a.col1.x * h + a.col2.x * i, i = a.col1.y * h + a.col2.y * i, h = g;
						var j = 0,
							k = 0,
							l = 0,
							m = 0,
							n = 0,
							p = 0,
							q = 0,
							r = 0,
							s = 0,
							t = 0,
							u = 0;
						this.m_state == o.e_atUpperLimit && (j = b.m_linearVelocity.x + -b.m_angularVelocity * f, k = b.m_linearVelocity.y + b.m_angularVelocity * d, l = c.m_linearVelocity.x + -c.m_angularVelocity * i, m = c.m_linearVelocity.y + c.m_angularVelocity * h, s = -(this.m_u1.x * j + this.m_u1.y * k) - this.m_ratio * (this.m_u2.x * l + this.m_u2.y * m), t = this.m_pulleyMass * -s, u = this.m_impulse, this.m_impulse = e.Max(0, this.m_impulse + t), t = this.m_impulse - u, n = -t * this.m_u1.x, p = -t * this.m_u1.y, q = -this.m_ratio * t * this.m_u2.x, r = -this.m_ratio * t * this.m_u2.y, b.m_linearVelocity.x += b.m_invMass * n, b.m_linearVelocity.y += b.m_invMass * p, b.m_angularVelocity += b.m_invI * (d * p - f * n), c.m_linearVelocity.x += c.m_invMass * q, c.m_linearVelocity.y += c.m_invMass * r, c.m_angularVelocity += c.m_invI * (h * r - i * q)), this.m_limitState1 == o.e_atUpperLimit && (j = b.m_linearVelocity.x + -b.m_angularVelocity * f, k = b.m_linearVelocity.y + b.m_angularVelocity * d, s = -(this.m_u1.x * j + this.m_u1.y * k), t = -this.m_limitMass1 * s, u = this.m_limitImpulse1, this.m_limitImpulse1 = e.Max(0, this.m_limitImpulse1 + t), t = this.m_limitImpulse1 - u, n = -t * this.m_u1.x, p = -t * this.m_u1.y, b.m_linearVelocity.x += b.m_invMass * n, b.m_linearVelocity.y += b.m_invMass * p, b.m_angularVelocity += b.m_invI * (d * p - f * n)), this.m_limitState2 == o.e_atUpperLimit && (l = c.m_linearVelocity.x + -c.m_angularVelocity * i, m = c.m_linearVelocity.y + c.m_angularVelocity * h, s = -(this.m_u2.x * l + this.m_u2.y * m), t = -this.m_limitMass2 * s, u = this.m_limitImpulse2, this.m_limitImpulse2 = e.Max(0, this.m_limitImpulse2 + t), t = this.m_limitImpulse2 - u, q = -t * this.m_u2.x, r = -t * this.m_u2.y, c.m_linearVelocity.x += c.m_invMass * q, c.m_linearVelocity.y += c.m_invMass * r, c.m_angularVelocity += c.m_invI * (h * r - i * q))
					}, x.prototype.SolvePositionConstraints = function(a) {
						void 0 === a && (a = 0);
						var c, d = this.m_bodyA,
							f = this.m_bodyB,
							g = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x,
							h = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
							i = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
							j = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y,
							k = 0,
							l = 0,
							m = 0,
							n = 0,
							p = 0,
							q = 0,
							r = 0,
							s = 0,
							t = 0,
							u = 0,
							v = 0,
							w = 0,
							x = 0,
							y = 0;
						return this.m_state == o.e_atUpperLimit && (c = d.m_xf.R, k = this.m_localAnchor1.x - d.m_sweep.localCenter.x, l = this.m_localAnchor1.y - d.m_sweep.localCenter.y, x = c.col1.x * k + c.col2.x * l, l = c.col1.y * k + c.col2.y * l, k = x, c = f.m_xf.R, m = this.m_localAnchor2.x - f.m_sweep.localCenter.x, n = this.m_localAnchor2.y - f.m_sweep.localCenter.y, x = c.col1.x * m + c.col2.x * n, n = c.col1.y * m + c.col2.y * n, m = x, p = d.m_sweep.c.x + k, q = d.m_sweep.c.y + l, r = f.m_sweep.c.x + m, s = f.m_sweep.c.y + n, this.m_u1.Set(p - g, q - h), this.m_u2.Set(r - i, s - j), t = this.m_u1.Length(), u = this.m_u2.Length(), t > b.b2_linearSlop ? this.m_u1.Multiply(1 / t) : this.m_u1.SetZero(), u > b.b2_linearSlop ? this.m_u2.Multiply(1 / u) : this.m_u2.SetZero(), v = this.m_constant - t - this.m_ratio * u, y = e.Max(y, -v), v = e.Clamp(v + b.b2_linearSlop, -b.b2_maxLinearCorrection, 0), w = -this.m_pulleyMass * v, p = -w * this.m_u1.x, q = -w * this.m_u1.y, r = -this.m_ratio * w * this.m_u2.x, s = -this.m_ratio * w * this.m_u2.y, d.m_sweep.c.x += d.m_invMass * p, d.m_sweep.c.y += d.m_invMass * q, d.m_sweep.a += d.m_invI * (k * q - l * p), f.m_sweep.c.x += f.m_invMass * r, f.m_sweep.c.y += f.m_invMass * s, f.m_sweep.a += f.m_invI * (m * s - n * r), d.SynchronizeTransform(), f.SynchronizeTransform()), this.m_limitState1 == o.e_atUpperLimit && (c = d.m_xf.R, k = this.m_localAnchor1.x - d.m_sweep.localCenter.x, l = this.m_localAnchor1.y - d.m_sweep.localCenter.y, x = c.col1.x * k + c.col2.x * l, l = c.col1.y * k + c.col2.y * l, k = x, p = d.m_sweep.c.x + k, q = d.m_sweep.c.y + l, this.m_u1.Set(p - g, q - h), t = this.m_u1.Length(), t > b.b2_linearSlop ? (this.m_u1.x *= 1 / t, this.m_u1.y *= 1 / t) : this.m_u1.SetZero(), v = this.m_maxLength1 - t, y = e.Max(y, -v), v = e.Clamp(v + b.b2_linearSlop, -b.b2_maxLinearCorrection, 0), w = -this.m_limitMass1 * v, p = -w * this.m_u1.x, q = -w * this.m_u1.y, d.m_sweep.c.x += d.m_invMass * p, d.m_sweep.c.y += d.m_invMass * q, d.m_sweep.a += d.m_invI * (k * q - l * p), d.SynchronizeTransform()), this.m_limitState2 == o.e_atUpperLimit && (c = f.m_xf.R, m = this.m_localAnchor2.x - f.m_sweep.localCenter.x, n = this.m_localAnchor2.y - f.m_sweep.localCenter.y, x = c.col1.x * m + c.col2.x * n, n = c.col1.y * m + c.col2.y * n, m = x, r = f.m_sweep.c.x + m, s = f.m_sweep.c.y + n, this.m_u2.Set(r - i, s - j), u = this.m_u2.Length(), u > b.b2_linearSlop ? (this.m_u2.x *= 1 / u, this.m_u2.y *= 1 / u) : this.m_u2.SetZero(), v = this.m_maxLength2 - u, y = e.Max(y, -v), v = e.Clamp(v + b.b2_linearSlop, -b.b2_maxLinearCorrection, 0), w = -this.m_limitMass2 * v, r = -w * this.m_u2.x, s = -w * this.m_u2.y, f.m_sweep.c.x += f.m_invMass * r, f.m_sweep.c.y += f.m_invMass * s, f.m_sweep.a += f.m_invI * (m * s - n * r), f.SynchronizeTransform()), y < b.b2_linearSlop
					}, a.postDefs.push(function() {
						a.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2
					}), a.inherit(y, a.Dynamics.Joints.b2JointDef), y.prototype.__super = a.Dynamics.Joints.b2JointDef.prototype, y.b2PulleyJointDef = function() {
						a.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.groundAnchorA = new f, this.groundAnchorB = new f, this.localAnchorA = new f, this.localAnchorB = new f
					}, y.prototype.b2PulleyJointDef = function() {
						this.__super.b2JointDef.call(this), this.type = o.e_pulleyJoint, this.groundAnchorA.Set(-1, 1), this.groundAnchorB.Set(1, 1), this.localAnchorA.Set(-1, 0), this.localAnchorB.Set(1, 0), this.lengthA = 0, this.maxLengthA = 0, this.lengthB = 0, this.maxLengthB = 0, this.ratio = 1, this.collideConnected = !0
					}, y.prototype.Initialize = function(a, b, c, d, e, f, g) {
						void 0 === g && (g = 0), this.bodyA = a, this.bodyB = b, this.groundAnchorA.SetV(c), this.groundAnchorB.SetV(d), this.localAnchorA = this.bodyA.GetLocalPoint(e), this.localAnchorB = this.bodyB.GetLocalPoint(f);
						var h = e.x - c.x,
							i = e.y - c.y;
						this.lengthA = Math.sqrt(h * h + i * i);
						var j = f.x - d.x,
							k = f.y - d.y;
						this.lengthB = Math.sqrt(j * j + k * k), this.ratio = g;
						var l = this.lengthA + this.ratio * this.lengthB;
						this.maxLengthA = l - this.ratio * x.b2_minPulleyLength, this.maxLengthB = (l - x.b2_minPulleyLength) / this.ratio
					}, a.inherit(z, a.Dynamics.Joints.b2Joint), z.prototype.__super = a.Dynamics.Joints.b2Joint.prototype, z.b2RevoluteJoint = function() {
						a.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new c, this.K1 = new c, this.K2 = new c, this.K3 = new c, this.impulse3 = new g, this.impulse2 = new f, this.reduced = new f, this.m_localAnchor1 = new f, this.m_localAnchor2 = new f, this.m_impulse = new g, this.m_mass = new d
					}, z.prototype.GetAnchorA = function() {
						return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
					}, z.prototype.GetAnchorB = function() {
						return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
					}, z.prototype.GetReactionForce = function(a) {
						return void 0 === a && (a = 0), new f(a * this.m_impulse.x, a * this.m_impulse.y)
					}, z.prototype.GetReactionTorque = function(a) {
						return void 0 === a && (a = 0), a * this.m_impulse.z
					}, z.prototype.GetJointAngle = function() {
						return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
					}, z.prototype.GetJointSpeed = function() {
						return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
					}, z.prototype.IsLimitEnabled = function() {
						return this.m_enableLimit
					}, z.prototype.EnableLimit = function(a) {
						this.m_enableLimit = a
					}, z.prototype.GetLowerLimit = function() {
						return this.m_lowerAngle
					}, z.prototype.GetUpperLimit = function() {
						return this.m_upperAngle
					}, z.prototype.SetLimits = function(a, b) {
						void 0 === a && (a = 0), void 0 === b && (b = 0), this.m_lowerAngle = a, this.m_upperAngle = b
					}, z.prototype.IsMotorEnabled = function() {
						return this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor
					}, z.prototype.EnableMotor = function(a) {
						this.m_enableMotor = a
					}, z.prototype.SetMotorSpeed = function(a) {
						void 0 === a && (a = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = a
					}, z.prototype.GetMotorSpeed = function() {
						return this.m_motorSpeed
					}, z.prototype.SetMaxMotorTorque = function(a) {
						void 0 === a && (a = 0), this.m_maxMotorTorque = a
					}, z.prototype.GetMotorTorque = function() {
						return this.m_maxMotorTorque
					}, z.prototype.b2RevoluteJoint = function(a) {
						this.__super.b2Joint.call(this, a), this.m_localAnchor1.SetV(a.localAnchorA), this.m_localAnchor2.SetV(a.localAnchorB), this.m_referenceAngle = a.referenceAngle, this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerAngle = a.lowerAngle, this.m_upperAngle = a.upperAngle, this.m_maxMotorTorque = a.maxMotorTorque, this.m_motorSpeed = a.motorSpeed, this.m_enableLimit = a.enableLimit, this.m_enableMotor = a.enableMotor, this.m_limitState = o.e_inactiveLimit
					}, z.prototype.InitVelocityConstraints = function(a) {
						var c, d = this.m_bodyA,
							f = this.m_bodyB,
							g = 0;
						this.m_enableMotor || this.m_enableLimit, c = d.m_xf.R;
						var h = this.m_localAnchor1.x - d.m_sweep.localCenter.x,
							i = this.m_localAnchor1.y - d.m_sweep.localCenter.y;
						g = c.col1.x * h + c.col2.x * i, i = c.col1.y * h + c.col2.y * i, h = g, c = f.m_xf.R;
						var j = this.m_localAnchor2.x - f.m_sweep.localCenter.x,
							k = this.m_localAnchor2.y - f.m_sweep.localCenter.y;
						g = c.col1.x * j + c.col2.x * k, k = c.col1.y * j + c.col2.y * k, j = g;
						var l = d.m_invMass,
							m = f.m_invMass,
							n = d.m_invI,
							p = f.m_invI;
						if (this.m_mass.col1.x = l + m + i * i * n + k * k * p, this.m_mass.col2.x = -i * h * n - k * j * p, this.m_mass.col3.x = -i * n - k * p, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = l + m + h * h * n + j * j * p, this.m_mass.col3.y = h * n + j * p, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = n + p, this.m_motorMass = 1 / (n + p), 0 == this.m_enableMotor && (this.m_motorImpulse = 0), this.m_enableLimit) {
							var q = f.m_sweep.a - d.m_sweep.a - this.m_referenceAngle;
							e.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b.b2_angularSlop ? this.m_limitState = o.e_equalLimits : q <= this.m_lowerAngle ? (this.m_limitState != o.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = o.e_atLowerLimit) : q >= this.m_upperAngle ? (this.m_limitState != o.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = o.e_atUpperLimit) : (this.m_limitState = o.e_inactiveLimit, this.m_impulse.z = 0)
						} else this.m_limitState = o.e_inactiveLimit;
						if (a.warmStarting) {
							this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, this.m_motorImpulse *= a.dtRatio;
							var r = this.m_impulse.x,
								s = this.m_impulse.y;
							d.m_linearVelocity.x -= l * r, d.m_linearVelocity.y -= l * s, d.m_angularVelocity -= n * (h * s - i * r + this.m_motorImpulse + this.m_impulse.z), f.m_linearVelocity.x += m * r, f.m_linearVelocity.y += m * s, f.m_angularVelocity += p * (j * s - k * r + this.m_motorImpulse + this.m_impulse.z)
						} else this.m_impulse.SetZero(), this.m_motorImpulse = 0
					}, z.prototype.SolveVelocityConstraints = function(a) {
						var b, c = this.m_bodyA,
							d = this.m_bodyB,
							f = 0,
							g = 0,
							h = 0,
							i = 0,
							j = 0,
							k = 0,
							l = c.m_linearVelocity,
							m = c.m_angularVelocity,
							n = d.m_linearVelocity,
							p = d.m_angularVelocity,
							q = c.m_invMass,
							r = d.m_invMass,
							s = c.m_invI,
							t = d.m_invI;
						if (this.m_enableMotor && this.m_limitState != o.e_equalLimits) {
							var u = p - m - this.m_motorSpeed,
								v = this.m_motorMass * -u,
								w = this.m_motorImpulse,
								x = a.dt * this.m_maxMotorTorque;
							this.m_motorImpulse = e.Clamp(this.m_motorImpulse + v, -x, x), v = this.m_motorImpulse - w, m -= s * v, p += t * v
						}
						if (this.m_enableLimit && this.m_limitState != o.e_inactiveLimit) {
							b = c.m_xf.R, h = this.m_localAnchor1.x - c.m_sweep.localCenter.x, i = this.m_localAnchor1.y - c.m_sweep.localCenter.y, f = b.col1.x * h + b.col2.x * i, i = b.col1.y * h + b.col2.y * i, h = f, b = d.m_xf.R, j = this.m_localAnchor2.x - d.m_sweep.localCenter.x, k = this.m_localAnchor2.y - d.m_sweep.localCenter.y, f = b.col1.x * j + b.col2.x * k, k = b.col1.y * j + b.col2.y * k, j = f;
							var y = n.x + -p * k - l.x - -m * i,
								z = n.y + p * j - l.y - m * h,
								A = p - m;
							this.m_mass.Solve33(this.impulse3, -y, -z, -A), this.m_limitState == o.e_equalLimits ? this.m_impulse.Add(this.impulse3) : this.m_limitState == o.e_atLowerLimit ? (g = this.m_impulse.z + this.impulse3.z, 0 > g && (this.m_mass.Solve22(this.reduced, -y, -z), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0)) : this.m_limitState == o.e_atUpperLimit && (g = this.m_impulse.z + this.impulse3.z, g > 0 && (this.m_mass.Solve22(this.reduced, -y, -z), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0)), l.x -= q * this.impulse3.x, l.y -= q * this.impulse3.y, m -= s * (h * this.impulse3.y - i * this.impulse3.x + this.impulse3.z), n.x += r * this.impulse3.x, n.y += r * this.impulse3.y, p += t * (j * this.impulse3.y - k * this.impulse3.x + this.impulse3.z)
						} else {
							b = c.m_xf.R, h = this.m_localAnchor1.x - c.m_sweep.localCenter.x, i = this.m_localAnchor1.y - c.m_sweep.localCenter.y, f = b.col1.x * h + b.col2.x * i, i = b.col1.y * h + b.col2.y * i, h = f, b = d.m_xf.R, j = this.m_localAnchor2.x - d.m_sweep.localCenter.x, k = this.m_localAnchor2.y - d.m_sweep.localCenter.y, f = b.col1.x * j + b.col2.x * k, k = b.col1.y * j + b.col2.y * k, j = f;
							var B = n.x + -p * k - l.x - -m * i,
								C = n.y + p * j - l.y - m * h;
							this.m_mass.Solve22(this.impulse2, -B, -C), this.m_impulse.x += this.impulse2.x, this.m_impulse.y += this.impulse2.y, l.x -= q * this.impulse2.x, l.y -= q * this.impulse2.y, m -= s * (h * this.impulse2.y - i * this.impulse2.x), n.x += r * this.impulse2.x, n.y += r * this.impulse2.y, p += t * (j * this.impulse2.y - k * this.impulse2.x)
						}
						c.m_linearVelocity.SetV(l), c.m_angularVelocity = m, d.m_linearVelocity.SetV(n), d.m_angularVelocity = p
					}, z.prototype.SolvePositionConstraints = function(a) {
						void 0 === a && (a = 0);
						var c, d = 0,
							f = this.m_bodyA,
							g = this.m_bodyB,
							h = 0,
							i = 0,
							j = 0,
							k = 0,
							l = 0;
						if (this.m_enableLimit && this.m_limitState != o.e_inactiveLimit) {
							var m = g.m_sweep.a - f.m_sweep.a - this.m_referenceAngle,
								n = 0;
							this.m_limitState == o.e_equalLimits ? (d = e.Clamp(m - this.m_lowerAngle, -b.b2_maxAngularCorrection, b.b2_maxAngularCorrection), n = -this.m_motorMass * d, h = e.Abs(d)) : this.m_limitState == o.e_atLowerLimit ? (d = m - this.m_lowerAngle, h = -d, d = e.Clamp(d + b.b2_angularSlop, -b.b2_maxAngularCorrection, 0), n = -this.m_motorMass * d) : this.m_limitState == o.e_atUpperLimit && (d = m - this.m_upperAngle, h = d, d = e.Clamp(d - b.b2_angularSlop, 0, b.b2_maxAngularCorrection), n = -this.m_motorMass * d), f.m_sweep.a -= f.m_invI * n, g.m_sweep.a += g.m_invI * n, f.SynchronizeTransform(), g.SynchronizeTransform()
						}
						c = f.m_xf.R;
						var p = this.m_localAnchor1.x - f.m_sweep.localCenter.x,
							q = this.m_localAnchor1.y - f.m_sweep.localCenter.y;
						j = c.col1.x * p + c.col2.x * q, q = c.col1.y * p + c.col2.y * q, p = j, c = g.m_xf.R;
						var r = this.m_localAnchor2.x - g.m_sweep.localCenter.x,
							s = this.m_localAnchor2.y - g.m_sweep.localCenter.y;
						j = c.col1.x * r + c.col2.x * s, s = c.col1.y * r + c.col2.y * s, r = j;
						var t = g.m_sweep.c.x + r - f.m_sweep.c.x - p,
							u = g.m_sweep.c.y + s - f.m_sweep.c.y - q,
							v = t * t + u * u,
							w = Math.sqrt(v);
						i = w;
						var x = f.m_invMass,
							y = g.m_invMass,
							A = f.m_invI,
							B = g.m_invI,
							C = 10 * b.b2_linearSlop;
						if (v > C * C) {
							var D = x + y,
								E = 1 / D;
							k = E * -t, l = E * -u;
							var F = .5;
							f.m_sweep.c.x -= F * x * k, f.m_sweep.c.y -= F * x * l, g.m_sweep.c.x += F * y * k, g.m_sweep.c.y += F * y * l, t = g.m_sweep.c.x + r - f.m_sweep.c.x - p, u = g.m_sweep.c.y + s - f.m_sweep.c.y - q
						}
						return this.K1.col1.x = x + y, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = x + y, this.K2.col1.x = A * q * q, this.K2.col2.x = -A * p * q, this.K2.col1.y = -A * p * q, this.K2.col2.y = A * p * p, this.K3.col1.x = B * s * s, this.K3.col2.x = -B * r * s, this.K3.col1.y = -B * r * s, this.K3.col2.y = B * r * r, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.AddM(this.K3), this.K.Solve(z.tImpulse, -t, -u), k = z.tImpulse.x, l = z.tImpulse.y, f.m_sweep.c.x -= f.m_invMass * k, f.m_sweep.c.y -= f.m_invMass * l, f.m_sweep.a -= f.m_invI * (p * l - q * k), g.m_sweep.c.x += g.m_invMass * k, g.m_sweep.c.y += g.m_invMass * l, g.m_sweep.a += g.m_invI * (r * l - s * k), f.SynchronizeTransform(), g.SynchronizeTransform(), i <= b.b2_linearSlop && h <= b.b2_angularSlop
					}, a.postDefs.push(function() {
						a.Dynamics.Joints.b2RevoluteJoint.tImpulse = new f
					}), a.inherit(A, a.Dynamics.Joints.b2JointDef), A.prototype.__super = a.Dynamics.Joints.b2JointDef.prototype, A.b2RevoluteJointDef = function() {
						a.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new f, this.localAnchorB = new f
					}, A.prototype.b2RevoluteJointDef = function() {
						this.__super.b2JointDef.call(this), this.type = o.e_revoluteJoint, this.localAnchorA.Set(0, 0), this.localAnchorB.Set(0, 0), this.referenceAngle = 0, this.lowerAngle = 0, this.upperAngle = 0, this.maxMotorTorque = 0, this.motorSpeed = 0, this.enableLimit = !1, this.enableMotor = !1
					}, A.prototype.Initialize = function(a, b, c) {
						this.bodyA = a, this.bodyB = b, this.localAnchorA = this.bodyA.GetLocalPoint(c), this.localAnchorB = this.bodyB.GetLocalPoint(c), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
					}, a.inherit(B, a.Dynamics.Joints.b2Joint), B.prototype.__super = a.Dynamics.Joints.b2Joint.prototype, B.b2WeldJoint = function() {
						a.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new f, this.m_localAnchorB = new f, this.m_impulse = new g, this.m_mass = new d
					}, B.prototype.GetAnchorA = function() {
						return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
					}, B.prototype.GetAnchorB = function() {
						return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
					}, B.prototype.GetReactionForce = function(a) {
						return void 0 === a && (a = 0), new f(a * this.m_impulse.x, a * this.m_impulse.y)
					}, B.prototype.GetReactionTorque = function(a) {
						return void 0 === a && (a = 0), a * this.m_impulse.z
					}, B.prototype.b2WeldJoint = function(a) {
						this.__super.b2Joint.call(this, a), this.m_localAnchorA.SetV(a.localAnchorA), this.m_localAnchorB.SetV(a.localAnchorB), this.m_referenceAngle = a.referenceAngle, this.m_impulse.SetZero(), this.m_mass = new d
					}, B.prototype.InitVelocityConstraints = function(a) {
						var b, c = 0,
							d = this.m_bodyA,
							e = this.m_bodyB;
						b = d.m_xf.R;
						var f = this.m_localAnchorA.x - d.m_sweep.localCenter.x,
							g = this.m_localAnchorA.y - d.m_sweep.localCenter.y;
						c = b.col1.x * f + b.col2.x * g, g = b.col1.y * f + b.col2.y * g, f = c, b = e.m_xf.R;
						var h = this.m_localAnchorB.x - e.m_sweep.localCenter.x,
							i = this.m_localAnchorB.y - e.m_sweep.localCenter.y;
						c = b.col1.x * h + b.col2.x * i, i = b.col1.y * h + b.col2.y * i, h = c;
						var j = d.m_invMass,
							k = e.m_invMass,
							l = d.m_invI,
							m = e.m_invI;
						this.m_mass.col1.x = j + k + g * g * l + i * i * m, this.m_mass.col2.x = -g * f * l - i * h * m, this.m_mass.col3.x = -g * l - i * m, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = j + k + f * f * l + h * h * m, this.m_mass.col3.y = f * l + h * m, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = l + m, a.warmStarting ? (this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, this.m_impulse.z *= a.dtRatio, d.m_linearVelocity.x -= j * this.m_impulse.x, d.m_linearVelocity.y -= j * this.m_impulse.y, d.m_angularVelocity -= l * (f * this.m_impulse.y - g * this.m_impulse.x + this.m_impulse.z), e.m_linearVelocity.x += k * this.m_impulse.x, e.m_linearVelocity.y += k * this.m_impulse.y, e.m_angularVelocity += m * (h * this.m_impulse.y - i * this.m_impulse.x + this.m_impulse.z)) : this.m_impulse.SetZero()
					}, B.prototype.SolveVelocityConstraints = function() {
						var a, b = 0,
							c = this.m_bodyA,
							d = this.m_bodyB,
							e = c.m_linearVelocity,
							f = c.m_angularVelocity,
							h = d.m_linearVelocity,
							i = d.m_angularVelocity,
							j = c.m_invMass,
							k = d.m_invMass,
							l = c.m_invI,
							m = d.m_invI;
						a = c.m_xf.R;
						var n = this.m_localAnchorA.x - c.m_sweep.localCenter.x,
							o = this.m_localAnchorA.y - c.m_sweep.localCenter.y;
						b = a.col1.x * n + a.col2.x * o, o = a.col1.y * n + a.col2.y * o, n = b, a = d.m_xf.R;
						var p = this.m_localAnchorB.x - d.m_sweep.localCenter.x,
							q = this.m_localAnchorB.y - d.m_sweep.localCenter.y;
						b = a.col1.x * p + a.col2.x * q, q = a.col1.y * p + a.col2.y * q, p = b;
						var r = h.x - i * q - e.x + f * o,
							s = h.y + i * p - e.y - f * n,
							t = i - f,
							u = new g;
						this.m_mass.Solve33(u, -r, -s, -t), this.m_impulse.Add(u), e.x -= j * u.x, e.y -= j * u.y, f -= l * (n * u.y - o * u.x + u.z), h.x += k * u.x, h.y += k * u.y, i += m * (p * u.y - q * u.x + u.z), c.m_angularVelocity = f, d.m_angularVelocity = i
					}, B.prototype.SolvePositionConstraints = function(a) {
						void 0 === a && (a = 0);
						var c, d = 0,
							f = this.m_bodyA,
							h = this.m_bodyB;
						c = f.m_xf.R;
						var i = this.m_localAnchorA.x - f.m_sweep.localCenter.x,
							j = this.m_localAnchorA.y - f.m_sweep.localCenter.y;
						d = c.col1.x * i + c.col2.x * j, j = c.col1.y * i + c.col2.y * j, i = d, c = h.m_xf.R;
						var k = this.m_localAnchorB.x - h.m_sweep.localCenter.x,
							l = this.m_localAnchorB.y - h.m_sweep.localCenter.y;
						d = c.col1.x * k + c.col2.x * l, l = c.col1.y * k + c.col2.y * l, k = d;
						var m = f.m_invMass,
							n = h.m_invMass,
							o = f.m_invI,
							p = h.m_invI,
							q = h.m_sweep.c.x + k - f.m_sweep.c.x - i,
							r = h.m_sweep.c.y + l - f.m_sweep.c.y - j,
							s = h.m_sweep.a - f.m_sweep.a - this.m_referenceAngle,
							t = 10 * b.b2_linearSlop,
							u = Math.sqrt(q * q + r * r),
							v = e.Abs(s);
						u > t && (o *= 1, p *= 1), this.m_mass.col1.x = m + n + j * j * o + l * l * p, this.m_mass.col2.x = -j * i * o - l * k * p, this.m_mass.col3.x = -j * o - l * p, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = m + n + i * i * o + k * k * p, this.m_mass.col3.y = i * o + k * p, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = o + p;
						var w = new g;
						return this.m_mass.Solve33(w, -q, -r, -s), f.m_sweep.c.x -= m * w.x, f.m_sweep.c.y -= m * w.y, f.m_sweep.a -= o * (i * w.y - j * w.x + w.z), h.m_sweep.c.x += n * w.x, h.m_sweep.c.y += n * w.y, h.m_sweep.a += p * (k * w.y - l * w.x + w.z), f.SynchronizeTransform(), h.SynchronizeTransform(), u <= b.b2_linearSlop && v <= b.b2_angularSlop
					}, a.inherit(C, a.Dynamics.Joints.b2JointDef), C.prototype.__super = a.Dynamics.Joints.b2JointDef.prototype, C.b2WeldJointDef = function() {
						a.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new f, this.localAnchorB = new f
					}, C.prototype.b2WeldJointDef = function() {
						this.__super.b2JointDef.call(this), this.type = o.e_weldJoint, this.referenceAngle = 0
					}, C.prototype.Initialize = function(a, b, c) {
						this.bodyA = a, this.bodyB = b, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(c)), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
					}
				}(),
				function() {
					var b = a.Dynamics.b2DebugDraw;
					b.b2DebugDraw = function() {
						this.m_drawScale = 1, this.m_lineThickness = 1, this.m_alpha = 1, this.m_fillAlpha = 1, this.m_xformScale = 1;
						this.m_sprite = {
							graphics: {
								clear: function() {}
							}
						}
					}, b.prototype._color = function(a, b) {
						return "rgba(" + ((16711680 & a) >> 16) + "," + ((65280 & a) >> 8) + "," + (255 & a) + "," + b + ")"
					}, b.prototype.b2DebugDraw = function() {
						this.m_drawFlags = 0
					}, b.prototype.SetFlags = function(a) {
						void 0 === a && (a = 0), this.m_drawFlags = a
					}, b.prototype.GetFlags = function() {
						return this.m_drawFlags
					}, b.prototype.AppendFlags = function(a) {
						void 0 === a && (a = 0), this.m_drawFlags |= a
					}, b.prototype.ClearFlags = function(a) {
						void 0 === a && (a = 0), this.m_drawFlags &= ~a
					}, b.prototype.SetSprite = function(a) {
						this.m_ctx = a
					}, b.prototype.GetSprite = function() {
						return this.m_ctx
					}, b.prototype.SetDrawScale = function(a) {
						void 0 === a && (a = 0), this.m_drawScale = a
					}, b.prototype.GetDrawScale = function() {
						return this.m_drawScale
					}, b.prototype.SetLineThickness = function(a) {
						void 0 === a && (a = 0), this.m_lineThickness = a, this.m_ctx.strokeWidth = a
					}, b.prototype.GetLineThickness = function() {
						return this.m_lineThickness
					}, b.prototype.SetAlpha = function(a) {
						void 0 === a && (a = 0), this.m_alpha = a
					}, b.prototype.GetAlpha = function() {
						return this.m_alpha
					}, b.prototype.SetFillAlpha = function(a) {
						void 0 === a && (a = 0), this.m_fillAlpha = a
					}, b.prototype.GetFillAlpha = function() {
						return this.m_fillAlpha
					}, b.prototype.SetXFormScale = function(a) {
						void 0 === a && (a = 0), this.m_xformScale = a
					}, b.prototype.GetXFormScale = function() {
						return this.m_xformScale
					}, b.prototype.DrawPolygon = function(a, b, c) {
						if (b) {
							var d = this.m_ctx,
								e = this.m_drawScale;
							d.beginPath(), d.strokeStyle = this._color(c.color, this.m_alpha), d.moveTo(a[0].x * e, a[0].y * e);
							for (var f = 1; b > f; f++) d.lineTo(a[f].x * e, a[f].y * e);
							d.lineTo(a[0].x * e, a[0].y * e), d.closePath(), d.stroke()
						}
					}, b.prototype.DrawSolidPolygon = function(a, b, c) {
						if (b) {
							var d = this.m_ctx,
								e = this.m_drawScale;
							d.beginPath(), d.strokeStyle = this._color(c.color, this.m_alpha), d.fillStyle = this._color(c.color, this.m_fillAlpha), d.moveTo(a[0].x * e, a[0].y * e);
							for (var f = 1; b > f; f++) d.lineTo(a[f].x * e, a[f].y * e);
							d.lineTo(a[0].x * e, a[0].y * e), d.closePath(), d.fill(), d.stroke()
						}
					}, b.prototype.DrawCircle = function(a, b, c) {
						if (b) {
							var d = this.m_ctx,
								e = this.m_drawScale;
							d.beginPath(), d.strokeStyle = this._color(c.color, this.m_alpha), d.arc(a.x * e, a.y * e, b * e, 0, 2 * Math.PI, !0), d.closePath(), d.stroke()
						}
					}, b.prototype.DrawSolidCircle = function(a, b, c, d) {
						if (b) {
							var e = this.m_ctx,
								f = this.m_drawScale,
								g = a.x * f,
								h = a.y * f;
							e.moveTo(0, 0), e.beginPath(), e.strokeStyle = this._color(d.color, this.m_alpha), e.fillStyle = this._color(d.color, this.m_fillAlpha), e.arc(g, h, b * f, 0, 2 * Math.PI, !0), e.moveTo(g, h), e.lineTo((a.x + c.x * b) * f, (a.y + c.y * b) * f), e.closePath(), e.fill(), e.stroke()
						}
					}, b.prototype.DrawSegment = function(a, b, c) {
						var d = this.m_ctx,
							e = this.m_drawScale;
						d.strokeStyle = this._color(c.color, this.m_alpha), d.beginPath(), d.moveTo(a.x * e, a.y * e), d.lineTo(b.x * e, b.y * e), d.closePath(), d.stroke()
					}, b.prototype.DrawTransform = function(a) {
						var b = this.m_ctx,
							c = this.m_drawScale;
						b.beginPath(), b.strokeStyle = this._color(16711680, this.m_alpha), b.moveTo(a.position.x * c, a.position.y * c), b.lineTo((a.position.x + this.m_xformScale * a.R.col1.x) * c, (a.position.y + this.m_xformScale * a.R.col1.y) * c), b.strokeStyle = this._color(65280, this.m_alpha), b.moveTo(a.position.x * c, a.position.y * c), b.lineTo((a.position.x + this.m_xformScale * a.R.col2.x) * c, (a.position.y + this.m_xformScale * a.R.col2.y) * c), b.closePath(), b.stroke()
					}
				}();
			var e;
			for (e = 0; e < a.postDefs.length; ++e) a.postDefs[e]();
			delete a.postDefs, b.exports = a
		}()
	}, {}],
	11: [function(a, b) {
		var c = a("./engine/perspective-layer"),
			d = a("./engine/collision-layer"),
			e = a("./engine/image-layer"),
			f = (a("./engine/animation"), a("./config")),
			g = a("./engine/camera"),
			h = a("./entities/entities"),
			i = a("./engine/physics"),
			j = a("./engine/input"),
			k = a("./engine/keys"),
			l = Class.extend({
				width: 1,
				height: 1,
				tilewidth: 16,
				tileheight: 16,
				layers: [],
				entities: [],
				realwidth: 16,
				realheight: 16,
				player: null,
				camera: null,
				spawn: {
					x: 0,
					y: 0
				},
				checkpoint: null,
				activemorph: 0,
				morphs: null,
				morphing: !1,
				morphSubject: null,
				stats: null,
				init: function(a, b) {
					i.resetWorld(), this.stats = b, this.layers = [], this.entities = [], this.initUI(a.morphs), this.spawn = {
						x: 0,
						y: 0
					}, this.height = a.height, this.width = a.width, this.tilewidth = a.tilewidth, this.tileheight = a.tileheight, this.realheight = this.tileheight * this.height, this.realwidth = this.tilewidth * this.width, this.initLayers(a.layers), this.initEntities(), this.player = new h.Player(this.spawn.x, this.spawn.y), this.entities.push(this.player), this.camera = new g(f.display.width / 2, f.display.height / 2, .2), this.camera.trap.size.x = f.display.width / 10, this.camera.trap.size.y = f.display.height / 5, this.camera.min.x = -f.perspective.pWidth, this.camera.min.y = -f.perspective.pHeight, this.camera.max.x = this.realwidth, this.camera.max.y = this.realheight, this.camera.lookAhead.x = f.display.width / 10, this.camera.set(this.player)
				},
				initUI: function(a) {
					var b = 1,
						c = $("#morphs > div");
					for (c.html(""), b; 7 > b; b++) c.append('<div id="' + b + '">x<span>0</span><figure></figure><div class="key">' + b + "</div></div>");
					this.morphs = [], b = 1;
					for (var d in a) {
						if (b > 6) break;
						var e = Object.$get(h, d);
						if (e) {
							var f = a[d],
								g = "#morphs > div #" + b;
							$(g + " span").text(f), $(g + " figure").css("background-position", "-" + e.bgpos.x + "px -" + e.bgpos.y + "px"), $(g).data("info", e.info), this.morphs.push({
								type: d,
								count: f,
								info: e.info
							}), b++
						}
					}
					this.setActiveMorph(0)
				},
				setActiveMorph: function(a) {
					if (!this.morphing) {
						this.activemorph = a, $("#morphs > div div").removeClass("active");
						var b = $("#morphs > div #" + (a + 1));
						b.addClass("active"), b.removeClass("flash");
						var c = this.morphs[a];
						c = c && c.count > 0 ? c.info : "Empty", $("#morphs > span").text(c), "Empty" !== c && ($("#morphs > span").addClass("flash"), b.addClass("flash"), window.setTimeout(function() {
							$("#morphs > span").removeClass("flash"), b.removeClass("flash")
						}, 1e3))
					}
				},
				activateFirstMorph: function() {
					for (var a = 0, b = this.morphs.length; b > a; a++)
						if (this.morphs[a] && this.morphs[a].count > 0) return this.setActiveMorph(a)
				},
				updateActiveMorph: function() {
					var a = this.morphs[this.activemorph];
					a && (a.count = a.count - 1, $("#morphs > div #" + (this.activemorph + 1) + " > span").text(a.count), a.count <= 0 && (a.count = 0, $("#morphs > div #" + (this.activemorph + 1)).data("info", "Empty"), $("#morphs > div #" + (this.activemorph + 1) + " > figure").css("background-position", "0 0"), $("#morphs > span").text("Empty"), this.activateFirstMorph()))
				},
				morph: function(a) {
					return "string" == typeof a && (a = Object.$get(h, a)), this.player.initMorph() ? (this.stats.transforms++, this.morphing = !0, this.morphSubject = a, i.setPaused(a.pauseWhileMorph), !0) : !1
				},
				respawnPlayer: function(a) {
					if (!this.player.isMorphing()) {
						if (a) {
							this.stats.deaths++;
							var b = $("body").css("background-color");
							$("body").animate({
								backgroundColor: jQuery.Color("#4F2222")
							}, 100, function() {
								$("body").animate({
									backgroundColor: jQuery.Color(b)
								}, 100)
							}), $("#container").fadeTo(50, .05).delay(100).fadeTo(300, 1)
						}
						this.player.respawn(this.spawn.x, this.spawn.y)
					}
				},
				doMorph: function() {
					var a = this.morphSubject;
					if (this.morphing && !this.player.isMorphing()) {
						if (a.control) {
							this.player.removeBody();
							var b = this.entities.indexOf(this.player);
							this.player = new a(this.player.pos.x - this.player.offset.x, this.player.pos.y - this.player.offset.y), this.entities[b] = this.player
						} else {
							var c = new a(this.player.pos.x - this.player.offset.x, this.player.pos.y - this.player.offset.y);
							this.respawnPlayer(), this.entities.push(c)
						}
						this.morphing = !1, i.setPaused(!1), this.updateActiveMorph()
					}
				},
				applyScale: function(a) {
					return Math.round(a * f.display.scale)
				},
				setSpawn: function(a, b) {
					this.spawn.x = a, this.spawn.y = b
				},
				initRegion: function(a) {
					"Spawn" == a.name && (this.spawn.x = a.x, this.spawn.y = a.y)
				},
				initEntities: function() {
					for (var a = {}, b = 0; b < this.entities.length; b++) {
						var c = this.entities[b];
						c._name && (a[c._name] = c)
					}
					for (var b = 0; b < this.entities.length; b++) {
						var c = this.entities[b];
						if (c._target) {
							for (var d = c._target.split(","), e = [], f = 0; f < d.length; f++) a[d[f]] && e.push(a[d[f]]);
							c.targets = e
						}
					}
				},
				initLayer: function(a) {
					if ("tilelayer" === a.type) "perspective" === a.properties.type && this.layers.push(new c(a, this.width, this.height, this.tilewidth, this.tileheight));
					else if ("objectgroup" === a.type && ("collision" === a.properties.type && this.layers.push(new d(a)), "image" === a.properties.type && this.layers.push(new e(a)), "entity" === a.properties.type))
						for (var b = 0; b < a.data.length; b++) {
							var f = a.data[b],
								g = Object.$get(h, f.name);
							if (g && "region" !== f.type) {
								var i = {};
								(f.properties && f.properties.target || f.properties.name) && (i._target = f.properties.target, i._name = f.properties.name);
								var g = new g(f.x, f.y, f);
								Object.$merge(g, i), this.entities.push(g)
							} else this.initRegion(f)
						}
				},
				initLayers: function(a) {
					for (var b in a) this.initLayer(a[b])
				},
				update: function(a) {
					var b;
					for (b = 1; 7 > b; b++)(j.isPressed(k["_" + b]) || j.isPressed(k["NUMPAD_" + b])) && this.setActiveMorph(b - 1);
					for (b = 0; b < this.entities.length; b++) this.entities[b].update(a);
					this.camera.follow(this.player), (this.player.pos.x > this.camera.max.x || this.player.pos.x + this.player.width < this.camera.min.x || this.player.pos.y > this.camera.max.y || this.player.pos.y + this.player.height < this.camera.min.y) && this.player.kill(a), j.isPressed("morph") && this.morphs[this.activemorph] && this.morphs[this.activemorph].count > 0 && this.morph(this.morphs[this.activemorph].type) && (a.playSound("transform"), a.shake(300, 20)), this.doMorph()
				},
				draw: function(a) {
					for (var b = 0; b < this.layers.length; b++) this.layers[b].foreground || this.layers[b].draw(a, this.stats);
					this.entities.sort(function(a, b) {
						return a.foreground || b.background && !a.background ? 1 : b.foreground || a.background && !b.background ? -1 : a.pos.y < b.pos.y ? 1 : a.pos.y > b.pos.y ? -1 : a.pos.x > b.pos.x ? 1 : a.pos.x < b.pos.x ? -1 : 0
					});
					for (var b = 0; b < this.entities.length; b++) this.entities[b].draw(a);
					for (var b = 0; b < this.layers.length; b++) this.layers[b].foreground && this.layers[b].draw(a, this.stats)
				}
			});
		b.exports = l
	}, {
		"./engine/perspective-layer": 18,
		"./engine/collision-layer": 19,
		"./engine/image-layer": 20,
		"./engine/animation": 21,
		"./config": 5,
		"./engine/camera": 22,
		"./engine/physics": 7,
		"./entities/entities": 23,
		"./engine/input": 4,
		"./engine/keys": 12
	}],
	13: [function(a, b) {
		var c = a("../config").message,
			d = {
				spawn: function(a, b, d, e, f, g) {
					var h = $('<div class="message center"></div>'),
						i = "#container";
					return e && e.el && (i = e.el), $(i).append(h), h.text(a), h.css("top", c.top), h.css("color", b), d ? (e !== !1 && (e ? (f || (e.opacity = e.opacity || 0), h.animate(e, d, function() {
						f || $(this).remove(), g && g()
					})) : h.fadeOut(d, function() {
						$(this).remove()
					})), h) : h
				}
			};
		b.exports = d
	}, {
		"../config": 5
	}],
	15: [function(a, b) {
		var c = a("./box2dweb");
		(function() {
			var a = c.Collision.Shapes.b2PolygonShape,
				b = c.Common.Math.b2Vec2,
				d = (c.Dynamics.b2Body, c.Dynamics.b2FixtureDef, function(c, d, e, g) {
					g = null != g ? g : 30;
					var h, i, j, k, l, m = e.length,
						n = [];
					for (h = 0; m > h; h++) n.push(new b(e[h].x * g, e[h].y * g));
					for (k = f(n), m = k.length, h = 0; m > h; h++) {
						for (e = [], n = k[h], j = n.length, i = 0; j > i; i++) e.push(new b(n[i].x / g, n[i].y / g));
						l = new a, l.SetAsVector(e), d.shape = l, c.CreateFixture(d)
					}
				}),
				e = function(a) {
					var b, c, d, e, f, g, i, j = a.length,
						k = 0,
						m = !1;
					for (b = 0; j > b; b++) {
						for (e = j - 1 > b ? b + 1 : 0, f = b > 0 ? b - 1 : j - 1, i = !1, c = 0; j > c; c++) c != b && c != e && (i || (g = l(a[b].x, a[b].y, a[e].x, a[e].y, a[c].x, a[c].y), g > 0 && (i = !0)), c != f && (d = j - 1 > c ? c + 1 : 0, h(a[b].x, a[b].y, a[e].x, a[e].y, a[c].x, a[c].y, a[d].x, a[d].y) && (k = 1)));
						i || (m = !0)
					}
					return m && (k = 1 == k ? 3 : 2), k
				},
				f = function(a) {
					var b, c, d, e, f, h, k, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G = [],
						H = [];
					for (H.push(a); H.length;) {
						for (b = H[0], d = b.length, F = !0, c = 0; d > c; c++)
							if (p = c, q = d - 1 > c ? c + 1 : c + 1 - d, r = d - 2 > c ? c + 2 : c + 2 - d, s = b[p], t = b[q], u = b[r], f = l(s.x, s.y, t.x, t.y, u.x, u.y), 0 > f) {
								for (F = !1, o = Number.MAX_VALUE, e = 0; d > e; e++) e != p && e != q && (v = e, w = d - 1 > e ? e + 1 : 0, x = b[v], y = b[w], D = g(s.x, s.y, t.x, t.y, x.x, x.y, y.x, y.y), D && (k = t.x - D.x, n = t.y - D.y, h = k * k + n * n, o > h && (A = v, z = w, E = D, o = h)));
								for (o == Number.MAX_VALUE && m(), B = [], C = [], v = A, w = z, x = b[v], y = b[w], j(E.x, E.y, y.x, y.y) || B.push(E), j(E.x, E.y, x.x, x.y) || C.push(E), A = -1, z = p;;) {
									if (z == w) {
										(0 > A || A >= d) && m(), i(y.x, y.y, b[A].x, b[A].y, s.x, s.y) || B.push(b[z]);
										break
									}
									B.push(b[z]), A = z, 0 > z - 1 ? z = d - 1 : z--
								}
								for (B = B.reverse(), A = -1, z = q;;) {
									if (z == v) {
										(0 > A || A >= d) && m(), z != v || i(x.x, x.y, b[A].x, b[A].y, t.x, t.y) || C.push(b[z]);
										break
									}
									C.push(b[z]), A = z, z + 1 > d - 1 ? z = 0 : z++
								}
								H.push(B, C), H.shift();
								break
							} F && G.push(H.shift())
					}
					return G
				},
				g = function(a, c, d, e, f, g, h, j) {
					var k, l = f - a,
						m = g - c,
						n = d - a,
						o = e - c,
						p = h - f,
						q = j - g,
						r = o * p - n * q;
					k = (p * m - q * l) / r;
					var s = a + k * n,
						t = c + k * o,
						u = i(d, e, a, c, s, t),
						v = i(s, t, f, g, h, j);
					return u && v ? new b(s, t) : null
				},
				h = function(a, c, d, e, f, g, h, j) {
					var k, l = f - a,
						m = g - c,
						n = d - a,
						o = e - c,
						p = h - f,
						q = j - g,
						r = o * p - n * q;
					k = (p * m - q * l) / r;
					var s = a + k * n,
						t = c + k * o,
						u = i(s, t, a, c, d, e),
						v = i(s, t, f, g, h, j);
					return u && v ? new b(s, t) : null
				},
				i = function(a, b, c, d, e, f) {
					var g = c + .1 >= a && a >= e - .1 || a >= c - .1 && e + .1 >= a,
						h = d + .1 >= b && b >= f - .1 || b >= d - .1 && f + .1 >= b;
					return g && h && k(a, b, c, d, e, f)
				},
				j = function(a, b, c, d) {
					var e = c >= a ? c - a : a - c,
						f = d >= b ? d - b : b - d;
					return .1 > e && .1 > f
				},
				k = function(a, b, c, d, e, f) {
					if (e - c > .1 || c - e > .1) {
						var g = (f - d) / (e - c),
							h = g * (a - c) + d,
							i = h > b ? h - b : b - h;
						return .1 > i
					}
					return .1 > a - c || .1 > c - a
				},
				l = function(a, b, c, d, e, f) {
					return a * d + c * f + e * b - b * c - d * e - f * a
				},
				m = function() {
					throw new Error("A problem has occurred. Use the Validate() method to see where the problem is.")
				};
			this.Box2DSeparator = {
				separate: d,
				validate: e
			}
		}).call(this), b.exports = this.Box2DSeparator
	}, {
		"./box2dweb": 14
	}],
	16: [function(a, b) {
		var c = a("../config"),
			d = Class.extend({
				loaded: !1,
				path: "",
				width: 0,
				height: 0,
				image: null,
				scaled: {},
				scale: [],
				_onloadCallback: null,
				init: function(a, b, c) {
					this.path = a, this.scale = b && b.scale ? b.scale : [1], this.scaled = {}, this._onloadCallback = c, this._load()
				},
				applyScale: function(a) {
					return Math.round(a * c.display.scale)
				},
				drawArea: function(a, b, d, e, f, g, h, i, j, k, l) {
					var m = c.display.realwidth,
						n = c.display.realheight;
					if (!l) {
						if (0 > d + h || d > m || 0 > e + i || e > n) return;
						if (c.fog.enabled && (d < c.fog.area.x || d + h > m - c.fog.area.x || e < c.fog.area.y || e + i > n - c.fog.area.y)) return;
						0 > d && d + h > 0 && (h += d, f -= d, d = 0), m > d && d + h > m && (h -= d + h - m), 0 > e && e + i > 0 && (i += e, g -= e, e = 0), n > e && e + i > n && (i -= e + i - n)
					}
					j && (d = d * j - (0 > j ? h : 0)), k && (e = e * k - (0 > k ? i : 0)), a.drawImage(b, f, g, h, i, d, e, h, i)
				},
				draw: function(a, b, c, d) {
					if (this.loaded) {
						var e = this.scaled[d] || this.image;
						this.drawArea(a, e, this.applyScale(b), this.applyScale(c), 0, 0, e.width, e.height)
					}
				},
				_load: function() {
					this.loaded || (this.image = new Image, this.image.onload = this._onload.bind(this), this.image.onerror = this._onerror.bind(this), this.image.src = this.path)
				},
				_onload: function() {
					this.loaded = !0, this.width = this.image.width, this.height = this.image.height, this.resizeAll(), this._onloadCallback(this.path)
				},
				resizeAll: function() {
					for (var a = 0; a < this.scale.length; a++) this.scaled[this.scale[a]] = this.resize(this.image, this.scale[a])
				},
				_onerror: function() {
					throw "An error happened while loading " + this.path
				},
				resize: function(a, b) {
					if (1 === this.scale && 1 === c.display.scale) return a;
					b = this.applyScale(b);
					var d = document.createElement("canvas");
					d.width = a.width, d.height = a.height;
					var e = d.getContext("2d");
					e.drawImage(a, 0, 0);
					var f = e.getImageData(0, 0, a.width, a.height).data,
						g = a.width * b,
						h = a.height * b,
						i = document.createElement("canvas");
					i.width = g, i.height = h;
					for (var j = i.getContext("2d"), k = j.getImageData(0, 0, g, h), l = k.data, m = 0, n = 0, o = 0; o < this.height; ++o)
						for (var p = 0; b > p; ++p)
							for (var q = 0; q < this.width; ++q) {
								m = 4 * (o * this.width + q);
								for (var r = 0; b > r; ++r) {
									var s = m;
									l[n++] = f[s++], l[n++] = f[s++], l[n++] = f[s++], l[n++] = f[s++]
								}
							}
					return j.putImageData(k, 0, 0), i
				}
			});
		b.exports = d
	}, {
		"../config": 5
	}],
	17: [function(a, b) {
		var c = a("./graphic"),
			d = a("../config"),
			e = c.extend({
				tileheight: 0,
				tilewidth: 0,
				pivot: {
					x: 0,
					y: 0
				},
				r: 360 * Math.PI / 180,
				init: function(a, b, c) {
					this.parent(a, b, c), this.tileheight = b.tileheight || b.tilesize, this.tilewidth = b.tilewidth || b.tilesize, this.pivot = {}, this.pivot.x = this.tilewidth / 2, this.pivot.y = this.tileheight / 2
				},
				drawTile: function(a, b, c, e, f, g, h, i, j) {
					if (this.loaded && !(0 >= i)) {
						var k = this.getRect(e || 0, f),
							l = this.scaled[f] || this.image;
						g = g || {};
						var m = g.x ? -1 : 1,
							n = g.y ? -1 : 1;
						if (b = this.applyScale(b) + ~~d.display.offset.x, c = this.applyScale(c) + ~~d.display.offset.y, h) {
							var o = d.display.realwidth,
								p = d.display.realheight,
								q = h % this.r,
								r = q > 2.35 ? b - this.applyScale(k.width) : b,
								s = q > .78 && 2.35 > q ? c - this.applyScale(k.height) : c,
								t = k.width,
								u = k.height;
							if (0 > r + t || r > o || 0 > s + u || s > p) return;
							if (d.fog.enabled && (r < d.fog.area.x || r + t > o - d.fog.area.x || s < d.fog.area.y || s + u > p - d.fog.area.y)) return
						}
						a.save(), void 0 !== i && 1 > i && (a.globalAlpha = Math.max(0, Math.min(i, 1))), g && a.scale(m, n), h && (a.translate(b, c), a.rotate(h), b = 0, c = 0, j = !0), this.drawArea(a, l, b, c, k.x, k.y, k.width, k.height, m, n, j), a.restore()
					}
				},
				getRect: function(a, b) {
					b = b || 1;
					var c = a >= 0 ? this.tilewidth : this.width,
						d = a >= 0 ? this.tileheight : this.height;
					0 >= a && (a = 0);
					var e = ~~(a * this.tilewidth) % this.width,
						f = ~~(a * this.tilewidth / this.width) * this.tileheight;
					return {
						x: this.applyScale(e * b),
						y: this.applyScale(f * b),
						width: this.applyScale(c * b),
						height: this.applyScale(d * b)
					}
				}
			});
		b.exports = e
	}, {
		"./graphic": 16,
		"../config": 5
	}],
	21: [function(a, b) {
		var c = Class.extend({
			tilesheet: null,
			scale: null,
			frametime: null,
			sequence: null,
			loop: null,
			looped: !1,
			frame: 0,
			tile: 0,
			flip: {
				x: !1,
				y: !1
			},
			alpha: 1,
			offset: {
				x: 0,
				y: 0
			},
			init: function(a, b, c, d, e) {
				if (!a) throw "Tilesheet not found!";
				this.flip = {
					x: !1,
					y: !1
				}, this.offset = {
					x: 0,
					y: 0
				}, this.scale = b, this.tilesheet = a, this.frameTime = c, this.sequence = d, this.loop = void 0 == e ? !0 : !1, this._initTime = (new Date).getTime(), this.tile = this.sequence[0]
			},
			reset: function() {
				this._initTime = (new Date).getTime(), this.tile = this.sequence[0], this.looped = !1
			},
			update: function() {
				var a = (new Date).getTime(),
					b = ~~((a - this._initTime) / 1e3 / this.frameTime);
				!this.loop && b > this.sequence.length - 1 ? (this.frame = this.sequence.length - 1, this.looped = !0) : this.frame = b % this.sequence.length, this.tile = this.sequence[this.frame]
			},
			forceNextFrame: function() {
				this.frame = (this.frame + 1) % sequence.length, this.tile = this.sequence[this.frame]
			},
			draw: function(a, b, c, d) {
				this.tilesheet.drawTile(a, b + this.offset.x, c + this.offset.y, this.tile, this.scale, this.flip, d, this.alpha)
			}
		});
		b.exports = c
	}, {}],
	19: [function(a, b) {
		var c = a("./physics"),
			d = Class.extend({
				name: null,
				bodies: [],
				init: function(a) {
					this.name = a.name, a = a.data;
					for (var b = 0; b < a.length; b++) {
						var d = a[b];
						d.polygon ? this.bodies.push(c.createCollisionPolygon(d.polygon, d.x, d.y, d.properties)) : d.polyline ? this.addPolyLine(d) : d.ellipse || this.bodies.push(c.createCollisionBox(d.x, d.y, d.width, d.height, d.properties))
					}
				},
				addPolyLine: function(a) {
					for (var b = a.y, d = 0, e = a.polyline.length; e > d; d++) {
						var f = a.polyline[d].y,
							g = b + f,
							h = 0,
							i = g % 15;
						0 !== i && ((13 === i || 5 === i) && (h = -1), (11 === i || 3 === i) && (h = 1), a.polyline[d].y = f + h)
					}
					this.bodies.push(c.createCollisionPolyline(a.polyline, a.x, a.y, a.properties))
				},
				update: function() {},
				draw: function() {}
			});
		b.exports = d
	}, {
		"./physics": 7
	}],
	20: [function(a, b) {
		var c = a("./layer"),
			d = a("../config"),
			e = a("./assets"),
			f = c.extend({
				asset: null,
				images: [],
				needDeaths: 0,
				init: function(a, b, c, f, g) {
					this.images = [], this.parent(a, b, c, f, g), Object.$merge(a.properties, d.image), this.needDeaths = a.properties.needDeaths || 0, this.asset = Object.$get(e.Graphics, a.properties.asset);
					for (var h = a.properties.firstgid, i = 0; i < a.data.length; i++) {
						var j = a.data[i];
						this.images.push({
							tile: j.gid - h,
							x: j.x,
							y: j.y - this.asset.tileheight,
							angle: j.rotation,
							ignoreoffscreen: j.igos || !1,
							alpha: j.alpha,
							flip: j.flip
						})
					}
				},
				draw: function(a, b) {
					if (!(b.deaths < this.needDeaths))
						for (var c = 0; c < this.images.length; c++) {
							var d = this.images[c];
							this.asset.drawTile(a, d.x, d.y, d.tile, this.scale, d.flip, d.angle, d.alpha, d.ignoreoffscreen)
						}
				}
			});
		b.exports = f
	}, {
		"./layer": 24,
		"../config": 5,
		"./assets": 10
	}],
	18: [function(a, b) {
		var c = a("./layer"),
			d = a("../config"),
			e = a("./assets"),
			f = c.extend({
				asset: null,
				pWidth: 1,
				pHeight: 1,
				offsetX: 0,
				offsetY: 0,
				orrX: 0,
				orrY: 0,
				depth: 0,
				tilesPerRow: 0,
				init: function(a, b, c, f, g) {
					this.parent(a, b, c, f, g), Object.$merge(a.properties, d.perspective), this.tilesPerRow = d.perspective.tilesPerRow;
					for (var h = [], i = 0; i < this.data.length; i++) {
						var j = this.data[i] - 1;
						h[i] = 0 > j ? -1 : ~~(j / this.tilesPerRow) * this.tilesPerRow * 2 + j % this.tilesPerRow
					}
					this.data = h, this.asset = Object.$get(e.Graphics, a.properties.asset), this.definition = a.properties.definition, this.pWidth = parseInt(a.properties.pWidth), this.pHeight = parseInt(a.properties.pHeight), this.depth = parseInt(a.properties.depth);
					var k = a.properties.align;
					k && (k = k.split("-"), this.orrX = "l" == k[1] ? 0 : f - this.pWidth + 1, this.orrY = "t" == k[0] ? 0 : g - this.pHeight + 1), this.offsetX = this.orrX + this.orrX * this.depth, this.offsetY = this.orrY + this.orrY * this.depth;
					var l = a.properties.prerendered;
					(void 0 == l || l) && this.preRender()
				},
				draw: function(a) {
					var b = d.perspective.flip,
						c = this.tilewidth * this.scale,
						e = this.tileheight * this.scale,
						f = d.display.offset.x / (c * d.display.scale) << 0,
						g = d.display.offset.y / (e * d.display.scale) << 0,
						h = ((d.display.width + 2 * this.orrX) / c << 0) - f,
						i = ((d.display.height + 2 * this.orrY) / e << 0) - g;
					f = Math.max(0, -f), g = Math.max(0, -g), h = Math.min(this.width - 1, h), i = Math.min(this.height - 1, i);
					for (var j, k, l, m, n = h; n >= f; n--)
						for (var o = i; o >= g; o--) j = b ? h - (n - f) : n, m = this.data[j + o * this.width], 0 > m || (k = (j * this.tilewidth + (b ? -this.orrX * this.depth : this.offsetX)) * this.scale, l = (o * this.tileheight + this.offsetY) * this.scale, m += b ? this.tilesPerRow : 0, this.asset.drawTile(a, k, l, m, this.scale));
					this.asset.drawRegion = null
				}
			});
		b.exports = f
	}, {
		"./layer": 24,
		"../config": 5,
		"./assets": 10
	}],
	22: [function(a, b) {
		var c = a("../config");
		Number.prototype.limit = function(a, b) {
			return Math.min(b, Math.max(a, this))
		};
		var d = Class.extend({
			trap: {
				pos: {
					x: 0,
					y: 0
				},
				size: {
					x: 128,
					y: 16
				}
			},
			max: {
				x: 0,
				y: 0
			},
			min: {
				x: 0,
				y: 0
			},
			offset: {
				x: 0,
				y: 0
			},
			pos: {
				x: 0,
				y: 0
			},
			damping: 5,
			lookAhead: {
				x: 0,
				y: 0
			},
			currentLookAhead: {
				x: 0,
				y: 0
			},
			init: function(a, b, c) {
				this.offset.x = a, this.offset.y = b, this.damping = c
			},
			set: function(a) {
				this.pos.x = a.pos.x - this.offset.x, this.pos.y = a.pos.y - this.offset.y, this.trap.pos.x = a.pos.x - this.trap.size.x / 2, this.trap.pos.y = a.pos.y - this.trap.size.y
			},
			follow: function(a) {
				this.pos.x = this.move("x", a.pos.x, a.width), this.pos.y = this.move("y", a.pos.y, a.height), c.display.offset.x = -this.pos.x * c.display.scale + c.display.shake.x, c.display.offset.y = -this.pos.y * c.display.scale + c.display.shake.y
			},
			move: function(a, b, c) {
				return b < this.trap.pos[a] ? (this.trap.pos[a] = b, this.currentLookAhead[a] = this.lookAhead[a]) : b + c > this.trap.pos[a] + this.trap.size[a] && (this.trap.pos[a] = b + c - this.trap.size[a], this.currentLookAhead[a] = -this.lookAhead[a]), (this.pos[a] - .16 * (this.pos[a] - this.trap.pos[a] + this.offset[a] + this.currentLookAhead[a]) * this.damping).limit(this.min[a], this.max[a])
			},
			draw: function(a) {
				a.fillStyle = "rgba(255,0,255,0.3)", a.fillRect((this.trap.pos.x - this.pos.x) * c.display.scale, (this.trap.pos.y - this.pos.y) * c.display.scale, this.trap.size.x * c.display.scale, this.trap.size.y * c.display.scale)
			}
		});
		b.exports = d
	}, {
		"../config": 5
	}],
	23: [function(a, b) {
		b.exports = {
			Intro: a("./actions/intro"),
			ChangeSpawn: a("./actions/changespawn"),
			EndLevel: a("./actions/endlevel"),
			Button: a("./scenery/button"),
			Door: a("./scenery/door"),
			Lava: a("./scenery/lava"),
			Laser: a("./scenery/laser"),
			LaserBlock: a("./scenery/laserblock"),
			Platform: a("./scenery/platform"),
			Player: a("./player"),
			Control: {
				Test: a("./control/test")
			},
			Spawn: {
				Test: a("./spawn/test"),
				Movable: a("./spawn/movable"),
				Immovable: a("./spawn/immovable"),
				Floater: a("./spawn/floater"),
				Upfloater: a("./spawn/upfloater"),
				Bouncer: a("./spawn/bouncy")
			}
		}
	}, {
		"./actions/changespawn": 25,
		"./actions/intro": 26,
		"./scenery/button": 27,
		"./actions/endlevel": 28,
		"./scenery/door": 29,
		"./scenery/lava": 30,
		"./scenery/laser": 31,
		"./scenery/laserblock": 32,
		"./scenery/platform": 33,
		"./player": 34,
		"./control/test": 35,
		"./spawn/test": 36,
		"./spawn/immovable": 37,
		"./spawn/movable": 38,
		"./spawn/floater": 39,
		"./spawn/upfloater": 40,
		"./spawn/bouncy": 41
	}],
	24: [function(a, b) {
		var c = Class.extend({
			name: null,
			data: [],
			width: 1,
			height: 1,
			tilewidth: 1,
			tileheight: 1,
			scale: 1,
			foreground: !1,
			init: function(a, b, c, d, e) {
				this.name = a.name, this.data = a.data, this.width = b, this.height = c, this.tilewidth = d, this.tileheight = e, this.foreground = a.properties && a.properties.foreground
			},
			preRender: function() {}
		});
		b.exports = c
	}, {}],
	34: [function(a, b) {
		var c = a("./entity"),
			d = a("../engine/input"),
			e = a("../config"),
			f = Box2D.Common.Math.b2Vec2,
			g = 18,
			h = 110,
			i = c.extend({
				canJump: !1,
				wentUp: !1,
				width: 16,
				height: 18,
				morphing: !1,
				offset: {
					x: 2,
					y: 1
				},
				bodyType: "Player",
				couldJump: !1,
				hitTime: 0,
				killed: !1,
				init: function(a, b, c) {
					this.parent(a, b, 1), this.initAnim(c || "sprites.player")
				},
				initAnim: function(a) {
					this.addAnimation("stand", a, this.scale, .1, [0]), this.addAnimation("walk", a, this.scale, .1, [1, 2, 3]), this.addAnimation("jump", a, this.scale, .15, [4, 5]), this.addAnimation("morph", a, this.scale, .06, [9, 10, 11, 12, 13, 14, 15, 14, 13], !1), this.addAnimation("endlevel", a, this.scale, .15, [16, 17, 18]), this.addAnimation("hit", a, this.scale, .02, [19, 20]), this.animation = this.animations.stand, this.animations.walk.flip.x = !0
				},
				endLevel: function(a, b) {
					this.animation = this.animations.endlevel, this.animation.flip.x = !b;
					var c = this.body.GetPosition();
					c.y -= this.height / 2;
					var d = b ? -1 : 1;
					this.body.SetPosition(c), this.body.SetType(1), this.body.SetLinearVelocity(new f(30 * d, -15))
				},
				kill: function(a, b) {
					this.animation !== this.animations.endlevel && (this.animation !== this.animations.hit && (this.killed = !0, this.morphing = !1, a.level.morphing = !1, this.animation = this.animations.hit, this.animation.flip.x = !0, this.hitTime = b || 300, a.shake(b || 300, 20), a.playSound("fail")), this.hitTime = this.hitTime - e.tick, this.hitTime < 0 && a.level.respawnPlayer(!0))
				},
				respawn: function(a, b) {
					this.setPos(a, b), this.animation = this.animations.stand
				},
				update: function(a) {
					this.hitTime > 0 && this.kill(a), this.parent(), this.morphing && (this.animation != this.animations.morph ? (this.animation = this.animations.morph, this.animation.flip.x = this.animations.walk.flip.x, this.animation.reset()) : this.animation.looped && (this.morphing = !1)), this.animation == this.animations.endlevel && (this.animation.alpha -= .008), this.morphing || this.animation == this.animations.endlevel || this.animation == this.animations.hit || d.isDown(0) || this.handleMovement(a), !this.couldJump && this.canJump() && a.playSound("fall", !0), this.couldJump = this.canJump()
				},
				initMorph: function() {
					return this.animation != this.animations.endlevel && this.animation != this.animations.hit && (this.morphing = !0), this.morphing
				},
				isMorphing: function() {
					return this.morphing
				},
				canJump: function() {
					return this.body.m_userData.footContacts > 0
				},
				handleMovement: function(a) {
					var b = this.body.GetLinearVelocity(),
						c = d.isDown("left"),
						i = d.isDown("right"),
						j = d.isDown("up");
					this.animation = this.animations.stand;
					var k, l = 0,
						m = 0;
					(c ^ i || 0 != b.x) && (this.animation = this.animations.walk, c && (l -= g, e.perspective.flip = !0, this.animation.flip.x = !1), i && (l += g, e.perspective.flip = !1, this.animation.flip.x = !0), k = l - b.x, m = this.body.GetMass() * k, this.body.ApplyImpulse(new f(m, 0), this.body.GetWorldCenter())), this.canJump() ? this.killed = !1 : this.animation = this.animations.jump, j && this.canJump() && (a.playSound("jump", !0), m = this.body.GetMass() * h, this.body.ApplyImpulse(new f(0, m), this.body.GetWorldCenter())), this.animation.flip = this.animations.walk.flip
				}
			});
		b.exports = i
	}, {
		"./entity": 42,
		"../config": 5,
		"../engine/input": 4
	}],
	28: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				done: !1,
				flip: !1,
				init: function(a, b, c) {
					this.parent(a, b, 1, {
						width: c.width,
						height: c.height,
						isSensor: !0,
						bodytype: "b2_staticBody"
					}), this.flip = c.properties && c.properties.flip
				},
				update: function(a) {
					!this.done && this.body.m_userData.playerCollision && (a.playSound("pabam"), a.endLevel(this.flip), this.done = !0)
				},
				draw: function(a) {
					this.parent(a)
				}
			});
		b.exports = d
	}, {
		"../entity": 42
	}],
	27: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				triggered: !1,
				width: 17,
				height: 16,
				align: null,
				init: function(a, b, c) {
					this.offset = {
						x: 0,
						y: 0
					}, this.align = c.properties.align || "t", this.axis = c.properties.axis || "y", ("t" === this.align || "t" === this.align.substr(0, 1)) && (this.offset.y = this.height - c.height), ("l" === this.align || "l" === this.align.substr(1)) && (this.offset.x = this.width - c.width), this.parent(a, b, 1, {
						x: a,
						y: b,
						width: c.width,
						height: c.height,
						isSensor: !0,
						bodytype: "b2_staticBody"
					});
					var d = "x" === this.axis ? 2 : 0;
					if (this.addAnimation("pressed", "sprites.button", 1, .1, [1 + d]), this.addAnimation("unpressed", "sprites.button", 1, .1, [0 + d]), "b" === this.align || "b" === this.align.substr(0, 1))
						for (var e in this.animations) this.animations[e].flip.y = !0;
					if ("r" === this.align || "r" === this.align.substr(1))
						for (var e in this.animations) this.animations[e].flip.x = !0
				},
				countValid: function(a) {
					for (var b = 0, c = 0, d = a.length; d > c; c++) a[c] && a[c].activatesButton && b++;
					return b
				},
				update: function(a) {
					this.animation && this.animation.update();
					var b;
					this.body.m_userData.playerCollision ? b = [{
						ent: a.level.player
					}] : this.body.m_userData.collisions && this.countValid(this.body.m_userData.collisions) > 0 && (b = this.body.m_userData.collisions), !this.triggered && b && (this.trigger(b, a), a.playSound("on"), this.animation = this.animations.pressed), this.triggered && !b && (this.untrigger(a), a.playSound("off"), this.animation = this.animations.unpressed), this.triggered = !!b
				}
			});
		b.exports = d
	}, {
		"../entity": 42
	}],
	25: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				done: 0,
				init: function(a, b, c) {
					this.parent(a, b, 1, {
						width: c.width,
						height: c.height,
						isSensor: !0,
						bodytype: "b2_staticBody"
					})
				},
				update: function(a) {
					this.done || !this.body.m_userData.playerCollision || a.level.player.killed || (a.level.setSpawn(this.pos.x, this.pos.y), this.done = !0, a.playSound("sparkle"), a.showMessage("Spawnpoint set!", "#95FBAE", 1e3, {
						top: "-=50"
					}))
				},
				draw: function() {}
			});
		b.exports = d
	}, {
		"../entity": 42
	}],
	31: [function(a, b) {
		var c = a("../entity"),
			d = a("../../config"),
			e = (a("../../engine/assets"), c.extend({
				active: !0,
				background: !0,
				axis: "x",
				direction: 1,
				collisions: null,
				distance: 0,
				currentDistance: 0,
				delay: 0,
				color: "#ff0000",
				alpha: 1,
				ticks: 0,
				init: function(a, b, c) {
					var d = c.properties || {};
					this.direction = d.flip ? -1 : 1, this.color = d.color || "#ff0000", a++, c.width--, this.axis = c.width > c.height ? "x" : "y", this.direction < 0 && (a = "x" === this.axis ? a + c.width : a, b = "y" === this.axis ? b + c.height : b), "x" === this.axis ? c.height = 4 : c.width = 4, this.parent(a, b, 1, {
						isSensor: !0,
						width: c.width * ("x" === this.axis ? this.direction : 1),
						height: c.height * ("y" === this.axis ? this.direction : 1),
						bodytype: "b2_staticBody"
					}), this.width = c.width, this.height = c.height, this.distance = ("x" === this.axis ? c.width : c.height) * this.direction, this.active = !(c.properties && c.properties.inactive)
				},
				triggered: function() {
					this.active = !1
				},
				untriggered: function() {
					this.active = !0
				},
				update: function(a) {
					if (this.active) {
						if (this.physicsInfo.collisions.length > 0) {
							for (var b = this.distance + this.pos[this.axis], c = 0, d = this.physicsInfo.collisions.length; d > c; c++) {
								var e = this.physicsInfo.collisions[c];
								b = this.direction > 0 ? Math.max(this.pos[this.axis], Math.min(e.pos[this.axis], b)) : Math.min(this.pos[this.axis], Math.max(e.pos[this.axis] + e["y" === this.axis ? "height" : "width"], b))
							}
							this.currentDistance = b - this.pos[this.axis]
						} else this.currentDistance = this.distance;
						if (this.physicsInfo.playerCollision) {
							var f = a.level.player,
								g = !1;
							this.direction > 0 ? this.pos[this.axis] + this.currentDistance > f.pos[this.axis] && (this.currentDistance = f.pos[this.axis] - this.pos[this.axis], g = !0) : this.pos[this.axis] + this.currentDistance < f.pos[this.axis] + f["y" === this.axis ? "height" : "width"] && (this.currentDistance = f.pos[this.axis] + f["y" === this.axis ? "height" : "width"] - this.pos[this.axis], g = !0), g && f.hitTime <= 0 && f.kill(a)
						}
					}
				},
				draw: function(a) {
					if (this.active) {
						this.ticks = d.tick + this.ticks, this.ticks > 40 * Math.random() + 20 && (this.alpha = .8 * Math.random() + .2, this.ticks = 0);
						var b = "x" == this.axis ? this.currentDistance : this.width,
							c = "y" == this.axis ? this.currentDistance : this.height;
						this.fillRect(a, this.pos.x, this.pos.y, b, c)
					}
				},
				fillRect: function(a, b, c, e, f) {
					d.display.realwidth, d.display.realheight;
					b = this.applyScale(b) + ~~d.display.offset.x, c = this.applyScale(c) + ~~d.display.offset.y, e = this.applyScale(e), f = this.applyScale(f);
					var g;
					0 > f && (g = c, c = g + f, f = -f), 0 > e && (g = b, b = g + e, e = -e), a.save(), a.globalAlpha = this.alpha;
					var h = this.applyScale(1),
						i = (this.applyScale(2), this.applyScale(3));
					a.fillStyle = this.color, a.fillRect(b, c, e, f), a.fillStyle = "rgba(255, 255, 255, 0.4)", a.fillRect(b, c, "x" == this.axis ? e : h, "y" == this.axis ? f : h), a.fillStyle = "rgba(0, 0, 0, 0.7)", a.fillRect(b + ("x" == this.axis ? 0 : i), c + ("y" == this.axis ? 0 : i), "x" == this.axis ? e : h, "y" == this.axis ? f : h), a.restore()
				}
			}));
		b.exports = e
	}, {
		"../../engine/assets": 10,
		"../../config": 5,
		"../entity": 42
	}],
	30: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				init: function(a, b, c) {
					this.parent(a, b, 1, {
						width: c.width,
						height: c.height,
						isSensor: !0,
						bodytype: "b2_staticBody"
					})
				},
				update: function(a) {
					this.body.m_userData.playerCollision && a.level.player.kill(a, 500)
				},
				draw: function() {}
			});
		b.exports = d
	}, {
		"../entity": 42
	}],
	29: [function(a, b) {
		var c = a("../entity"),
			d = a("../../config"),
			e = c.extend({
				width: 17,
				height: 32,
				background: !0,
				offset: {
					y: 6,
					x: 0
				},
				open: !1,
				triggerCount: 0,
				speed: 10,
				activatesButton: !1,
				init: function(a, b, c) {
					this.parent(a, b, 1, {
						fixed: "y",
						motor: {
							speed: -this.speed,
							maxForce: 1e5
						}
					}), this.neededTriggers = c.properties && c.properties.neededTriggers ? parseInt(c.properties.neededTriggers) : 1, this.addAnimation("closed", "sprites.door", 1, .1, [0]), this.addAnimation("open", "sprites.door", 1, .1, [1]), this.addAnimation("closed_0_2", "sprites.door", 1, .1, [2]), this.addAnimation("closed_1_2", "sprites.door", 1, .1, [3]), this.addAnimation("open_2_2", "sprites.door", 1, .1, [4]), this.animflip = {
						x: !1,
						y: !1
					}, this.animoffset = {
						x: 0,
						y: 0
					};
					for (var d in this.animations) this.animations[d].flip = this.animflip, this.animations[d].offset = this.animoffset;
					this.animation = this.animations["closed" + this.getTriggerAnim()]
				},
				update: function(a) {
					this.parent(a), this.animflip.x = !d.perspective.flip, this.animoffset.x = d.perspective.flip ? 0 : -5, this.angle = 0
				},
				getTriggerAnim: function() {
					return 2 !== this.neededTriggers ? "" : "_" + Math.max(0, Math.min(this.triggerCount, 2)) + "_2"
				},
				triggered: function(a, b) {
					++this.triggerCount === this.neededTriggers ? (this.trigger(a, b), this.open || b.playSound("correct"), this.open = !0, this.joint.SetMotorSpeed(this.speed), this.animation = this.animations["open" + this.getTriggerAnim()]) : this.animation = this.animations["closed" + this.getTriggerAnim()]
				},
				untriggered: function(a, b) {
					--this.triggerCount < this.neededTriggers ? (this.untrigger(b), this.open && b.playSound("wrong"), this.open = !1, this.joint.SetMotorSpeed(-this.speed), this.animation = this.animations["closed" + this.getTriggerAnim()]) : this.animation = this.animations["open" + this.getTriggerAnim()]
				}
			});
		b.exports = e
	}, {
		"../entity": 42,
		"../../config": 5
	}],
	26: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				done: !1,
				init: function(a, b, c) {
					this.parent(a, b, 1, {
						width: c.width,
						height: c.height,
						isSensor: !0,
						bodytype: "b2_staticBody"
					})
				},
				update: function() {
					!this.done && this.body.m_userData.playerCollision && ($("#morphs").fadeIn(500), $("#morphs div:first-child").addClass("flash"), this.done = !0)
				},
				draw: function() {}
			});
		b.exports = d
	}, {
		"../entity": 42
	}],
	33: [function(a, b) {
		var c = a("../entity"),
			d = a("../../config"),
			e = c.extend({
				width: 33,
				height: 6,
				background: !0,
				offset: {
					y: 3,
					x: 0
				},
				active: !0,
				axis: "x",
				loop: !0,
				direction: 1,
				speed: 10,
				triggerCount: 0,
				neededTriggers: 0,
				activatesButton: !1,
				init: function(a, b, c) {
					b = b + c.height - 10;
					var d = c.properties || {};
					this.axis = c.width > c.height ? "x" : "y", d.inactive && (this.active = !1);
					var e = "x" === this.axis ? c.width : c.height;
					this.parent(a, b, 1, {
						density: 100,
						top: {
							friction: 1e4
						},
						motor: {
							speed: this.direction * this.speed,
							maxForce: 1e5
						},
						fixed: this.axis,
						limit: {
							upper: e,
							lower: 0
						}
					}), this.neededTriggers = c.properties && c.properties.neededTriggers ? parseInt(c.properties.neededTriggers) : 1, this.addAnimation("inactive", "sprites.platform", 1, .1, [0]), this.addAnimation("active", "sprites.platform", 1, .1, [1]), this.addAnimation("active_2_2", "sprites.platform", 1, .1, [2]), this.addAnimation("inactive_1_2", "sprites.platform", 1, .1, [3]), this.addAnimation("inactive_0_2", "sprites.platform", 1, .1, [4]), this.animflip = {
						x: !1,
						y: !1
					}, this.animoffset = {
						x: 0,
						y: 0
					};
					for (var f in this.animations) this.animations[f].flip = this.animflip, this.animations[f].offset = this.animoffset;
					this.animation = this.animations[(this.active ? "" : "in") + "active" + this.getTriggerAnim()]
				},
				getTriggerAnim: function() {
					return 2 !== this.neededTriggers ? "" : "_" + Math.max(0, Math.min(this.triggerCount, 2)) + "_2"
				},
				triggered: function(a, b) {
					++this.triggerCount === this.neededTriggers ? (this.trigger(a, b), this.active = !0, this.animation = this.animations["active" + this.getTriggerAnim()]) : this.animation = this.animations["inactive" + this.getTriggerAnim()]
				},
				untriggered: function(a) {
					--this.triggerCount < this.neededTriggers ? (this.untrigger(a), this.active = !1, this.animation = this.animations["inactive" + this.getTriggerAnim()]) : this.animation = this.animations["active" + this.getTriggerAnim()]
				},
				update: function(a) {
					this.animflip.x = d.perspective.flip, this.animoffset.x = d.perspective.flip ? 0 : -5, this.parent(a);
					var b = this.body.GetLinearVelocity()[this.axis],
						c = this.joint.GetJointTranslation();
					c - 1 <= this.joint.GetLowerLimit() || -1 === this.direction && b > -.001 ? this.direction = 1 : (c + 2 >= this.joint.GetUpperLimit() || 1 === this.direction && .001 > b) && (this.direction = -1), this.joint.SetMotorSpeed(this.active ? this.direction * this.speed : 0), this.angle = 0
				}
			});
		b.exports = e
	}, {
		"../entity": 42,
		"../../config": 5
	}],
	32: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				active: !0,
				neededTriggers: 1,
				triggerCount: 0,
				width: 22,
				height: 21,
				offset: {
					x: 0,
					y: 0
				},
				reverse: !1,
				init: function(a, b, c) {
					this.parent(a, b, 1), this.addAnimation("inactive", "sprites.laser", 1, .1, [1]), this.addAnimation("active", "sprites.laser", 1, .1, [0]), this.addAnimation("inactive_0_2", "sprites.laser", 1, .1, [4]), this.addAnimation("inactive_1_2", "sprites.laser", 1, .1, [3]), this.addAnimation("inactive_2_2", "sprites.laser", 1, .1, [4]), this.addAnimation("active_0_2", "sprites.laser", 1, .1, [2]), this.addAnimation("active_1_2", "sprites.laser", 1, .1, [3]), this.addAnimation("active_2_2", "sprites.laser", 1, .1, [2]), this.neededTriggers = c.properties && c.properties.neededTriggers ? parseInt(c.properties.neededTriggers) : 1, this.reverse = c.properties && "true" == c.properties.reverse, this.animation = this.animations[(this.reverse ? "in" : "") + "active" + this.getTriggerAnim()]
				},
				getTriggerAnim: function() {
					return 2 !== this.neededTriggers ? "" : "_" + Math.max(0, Math.min(2 - this.triggerCount, 2)) + "_2"
				},
				initBody: function() {},
				triggered: function(a, b) {
					++this.triggerCount === this.neededTriggers ? (this.reverse ? this.untrigger(a, b) : this.trigger(a, b), this.active && b.playSound("correct"), this.active = !1, this.animation = this.animations[(this.reverse ? "" : "in") + "active" + this.getTriggerAnim()]) : this.animation = this.animations[(this.reverse ? "in" : "") + "active" + this.getTriggerAnim()]
				},
				untriggered: function(a, b) {
					--this.triggerCount < this.neededTriggers ? (this.reverse ? this.trigger(a, b) : this.untrigger(b), this.active || b.playSound("wrong"), this.active = !0, this.animation = this.animations[(this.reverse ? "in" : "") + "active" + this.getTriggerAnim()]) : this.animation = this.animations[(this.reverse ? "" : "in") + "active" + this.getTriggerAnim()]
				},
				update: function() {
					this.animation && this.animation.update()
				}
			});
		b.exports = d
	}, {
		"../entity": 42
	}],
	36: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				width: 16,
				height: 16,
				offset: {
					x: 0,
					y: 0
				},
				init: function(a, b) {
					this.parent(a, b, 1), this.addAnimation("stand", "debug.placeholder", this.scale, .1, [0])
				}
			});
		d.control = !1, d.pauseWhileMorph = !1, b.exports = d
	}, {
		"../entity": 42
	}],
	38: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				width: 15,
				height: 15,
				offset: {
					x: .5,
					y: 1
				},
				init: function(a, b) {
					var c = {
						density: 40,
						bottom: {
							friction: .2
						},
						top: {
							friction: .2
						}
					};
					this.parent(a, b, 1, c), this.addAnimation("stand", "sprites.spawn", this.scale, .1, [2])
				}
			});
		d.control = !1, d.pauseWhileMorph = !1, d.bgpos = {
			x: 120,
			y: 0
		}, d.info = "Moveable - Spawn a pushable block entity", b.exports = d
	}, {
		"../entity": 42
	}],
	35: [function(a, b) {
		var c = a("../player"),
			d = c.extend({
				width: 16,
				height: 16,
				offset: {
					x: 0,
					y: 0
				},
				init: function(a, b) {
					this.parent(a, b, "debug.placeholder")
				}
			});
		d.control = !0, d.pauseWhileMorph = !1, b.exports = d
	}, {
		"../player": 34
	}],
	37: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				width: 15,
				height: 15,
				offset: {
					x: .5,
					y: 1
				},
				init: function(a, b) {
					var c = {
						fixed: "y",
						density: 40
					};
					this.parent(a, b, 1, c), this.addAnimation("stand", "sprites.spawn", this.scale, .1, [1])
				}
			});
		d.control = !1, d.pauseWhileMorph = !1, d.bgpos = {
			x: 60,
			y: 0
		}, d.info = "Immoveable - Spawns a static block you can jump on", b.exports = d
	}, {
		"../entity": 42
	}],
	40: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				width: 15,
				height: 15,
				offset: {
					x: .5,
					y: 1
				},
				speed: 3,
				init: function(a, b) {
					a += 2;
					var c = {
						fixed: "y",
						density: 400,
						top: {
							friction: .2
						},
						motor: {
							speed: this.speed,
							maxForce: 1e7
						}
					};
					this.parent(a, b, 1, c), this.addAnimation("stand", "sprites.spawn", this.scale, .1, [5])
				}
			});
		d.control = !1, d.pauseWhileMorph = !0, d.bgpos = {
			x: 300,
			y: 0
		}, d.info = "Upfloater - Spawns a block that rises", b.exports = d
	}, {
		"../entity": 42
	}],
	39: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				width: 15,
				height: 15,
				offset: {
					x: .5,
					y: 1
				},
				init: function(a, b) {
					var c = {
						fixed: "y",
						density: 1e3,
						top: {
							friction: .2
						},
						limit: {
							lower: 0,
							upper: 0
						}
					};
					this.parent(a, b, 1, c), this.addAnimation("stand", "sprites.spawn", this.scale, .1, [3])
				}
			});
		d.control = !1, d.pauseWhileMorph = !0, d.bgpos = {
			x: 180,
			y: 0
		}, d.info = "Floater - Spawns a floating block", b.exports = d
	}, {
		"../entity": 42
	}],
	41: [function(a, b) {
		var c = a("../entity"),
			d = c.extend({
				width: 15,
				height: 15,
				offset: {
					x: .5,
					y: 1
				},
				init: function(a, b) {
					var c = {
						density: 40,
						bottom: {
							friction: .2,
							restitution: 0
						},
						restitution: .8
					};
					this.parent(a, b, 1, c), this.addAnimation("stand", "sprites.spawn", this.scale, .1, [4])
				}
			});
		d.control = !1, d.pauseWhileMorph = !1, d.bgpos = {
			x: 240,
			y: 0
		}, d.info = "Bouncer - Spawn a bounceable entity", b.exports = d
	}, {
		"../entity": 42
	}],
	42: [function(a, b) {
		var c = a("../engine/assets"),
			d = a("../engine/animation"),
			e = a("../config"),
			f = (a("../engine/input"), a("../engine/physics")),
			g = Box2D.Common.Math.b2Vec2,
			h = 0,
			i = Class.extend({
				width: 16,
				height: 16,
				foreground: !1,
				background: !1,
				pos: {
					x: 100,
					y: 100
				},
				offset: {
					x: 0,
					y: 0
				},
				body: null,
				joint: null,
				scale: 1,
				animations: {},
				animation: null,
				angle: 0,
				bodyType: "Box",
				targets: null,
				hash: null,
				physicsInfo: null,
				activatesButton: !0,
				init: function(a, b, c, d) {
					this.hash = h++, this.pos = {
						x: a,
						y: b
					}, this.scale = c, this.animations = {}, this.initBody(d)
				},
				applyScale: function(a) {
					return Math.round(a * e.display.scale)
				},
				setPos: function(a, b) {
					this.body.SetPosition(new g(a, b)), this.body.SetAwake(!0), this.body.SetLinearVelocity(new g(0, 0))
				},
				initBody: function(a) {
					a && (a.ent = this);
					var b = f["add" + this.bodyType + "Entity"](this.pos.x + this.offset.x, this.pos.y + this.offset.y, this.width * this.scale, this.height * this.scale, a);
					b && b.body && b.joint ? (this.body = b.body, this.joint = b.joint) : this.body = b, a && a.isSensor && (this.physicsInfo = this.body.m_userData)
				},
				removeBody: function() {
					f.removeBody(this.body)
				},
				addAnimation: function(a, b, e, f, g, h) {
					"object" != typeof b && (b = Object.$get(c.Graphics, b)), this.animations[a] = new d(b, e, f, g, h), this.animation = this.animations[a]
				},
				triggered: function() {},
				untriggered: function() {},
				trigger: function(a, b) {
					if (this.targets)
						for (var c = 0; c < this.targets.length; c++) this.targets[c].triggered(a || this, b)
				},
				untrigger: function(a) {
					if (this.targets)
						for (var b = 0; b < this.targets.length; b++) this.targets[b].untriggered(this, a)
				},
				update: function() {
					if (this.animation && this.animation.update(), this.body) {
						var a = this.body.GetPosition();
						this.pos.x = a.x, this.pos.y = a.y, this.angle = this.body.GetAngle()
					}
				},
				draw: function(a) {
					this.animation && this.animation.draw(a, this.pos.x - this.offset.x, this.pos.y - this.offset.y, this.angle)
				}
			});
		b.exports = i
	}, {
		"../engine/assets": 10,
		"../engine/animation": 21,
		"../config": 5,
		"../engine/physics": 7,
		"../engine/input": 4
	}]
}, {}, [1]);
